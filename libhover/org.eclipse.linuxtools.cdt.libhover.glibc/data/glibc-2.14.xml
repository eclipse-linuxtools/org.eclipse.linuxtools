<!-- This file automatically generated by an Eclipse utility -->
<!DOCTYPE descriptions [

  <!ELEMENT descriptions (construct)*>

  <!ELEMENT construct (structure|function)*>
  <!ATTLIST construct
    id ID #REQUIRED
    type CDATA #REQUIRED
  >

  <!ELEMENT structure       (synopsis?, elements?)?>

  <!ELEMENT elements     (element*)>

  <!ELEMENT element (synopsis*)>
  <!ATTLIST element
    content CDATA #REQUIRED
  >

  <!ELEMENT synopsis     (#PCDATA)*>

  <!ELEMENT function     (prototype,headers?,synopsis)>
  <!ATTLIST function
    returntype CDATA #REQUIRED
  >

  <!ELEMENT prototype    (parameter+)?>

  <!ELEMENT parameter (#PCDATA)*>
  <!ATTLIST parameter
    content CDATA #REQUIRED
  >

  <!ELEMENT headers      (header+)?>

  <!ELEMENT header (#PCDATA)*>
  <!ATTLIST header
    filename CDATA #REQUIRED
  >

]>

<descriptions>
  <!-- Following is needed to comply with the GFDL regarding modification and invariant sections. -->
  <construct id="function-0-REQUIRED-SECTIONS" type="function">
    <function returntype="void">
      <prototype>
      </prototype>
      <synopsis>
The GNU C Library (Eclipse Libhover Version)

Based on The GNU C Library
EDITION 0.12
VERSION 2.8
UPDATED 2007-10-27
ISBN 1-882114-55-8

This file documents the GNU C library.

This is based on Edition 0.12, last updated 2007-10-27
of The GNU C Library Reference Manual, for version 2.8.

Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002,
2003, 2007, 2008, 2010 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``Free Software Needs Free Documentation''
and ``GNU Lesser General Public License'', the Front-Cover texts being
``A GNU Manual'', and with the Back-Cover Texts as in (a) below.  A
copy of the license is included in the section entitled "GNU Free
Documentation License".

(a) The FSF's Back-Cover Text is: ``You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom.''

Authors
Sandra Loosemore
with
Richard M. Stallman, Roland McGrath, Andrew Oram, and Ulrich Drepper
Edition 0.12
last updated 2007-10-27
for version 2.8

Modified for use with Eclipse libhover plug-in by Jeff Johnston.

Modified documentation published by Eclipse Linux Tools project

Cover art for the Free Software Foundation's printed edition
by Etienne Suvasa.

==================================================================================================

Free Software Needs Free Documentation

The biggest deficiency in the free software community today is not in
the software---it is the lack of good free documentation that we can
include with the free software.  Many of our most important
programs do not come with free reference manuals and free introductory
texts.  Documentation is an essential part of any software package;
when an important free software package does not come with a free
manual and a free tutorial, that is a major gap.  We have many such
gaps today.

Consider Perl, for instance.  The tutorial manuals that people
normally use are non-free.  How did this come about?  Because the
authors of those manuals published them with restrictive terms---no
copying, no modification, source files not available---which exclude
them from the free software world.

That wasn't the first time this sort of thing happened, and it was far
from the last.  Many times we have heard a GNU user eagerly describe a
manual that he is writing, his intended contribution to the community,
only to learn that he had ruined everything by signing a publication
contract to make it non-free.

Free documentation, like free software, is a matter of freedom, not
price.  The problem with the non-free manual is not that publishers
charge a price for printed copies---that in itself is fine.  (The Free
Software Foundation sells printed copies of manuals, too.)  The
problem is the restrictions on the use of the manual.  Free manuals
are available in source code form, and give you permission to copy and
modify.  Non-free manuals do not allow this.

The criteria of freedom for a free manual are roughly the same as for
free software.  Redistribution (including the normal kinds of
commercial redistribution) must be permitted, so that the manual can
accompany every copy of the program, both on-line and on paper.

Permission for modification of the technical content is crucial too.
When people modify the software, adding or changing features, if they
are conscientious they will change the manual too---so they can
provide accurate and clear documentation for the modified program.  A
manual that leaves you no choice but to write a new manual to document
a changed version of the program is not really available to our
community.

Some kinds of limits on the way modification is handled are
acceptable.  For example, requirements to preserve the original
author's copyright notice, the distribution terms, or the list of
authors, are ok.  It is also no problem to require modified versions
to include notice that they were modified.  Even entire sections that
may not be deleted or changed are acceptable, as long as they deal
with nontechnical topics (like this one).  These kinds of restrictions
are acceptable because they don't obstruct the community's normal use
of the manual.

However, it must be possible to modify all the @emph{technical}
content of the manual, and then distribute the result in all the usual
media, through all the usual channels.  Otherwise, the restrictions
obstruct the use of the manual, it is not free, and we need another
manual to replace it.

Please spread the word about this issue.  Our community continues to
lose manuals to proprietary publishing.  If we spread the word that
free software needs free reference manuals and free tutorials, perhaps
the next person who wants to contribute by writing documentation will
realize, before it is too late, that only free manuals contribute to
the free software community.

If you are writing documentation, please insist on publishing it under
the GNU Free Documentation License or another free documentation
license.  Remember that this decision requires your approval---you
don't have to let the publisher decide.  Some commercial publishers
will use a free license if you insist, but they will not propose the
option; it is up to you to raise the issue and say firmly that this is
what you want.  If the publisher you are dealing with refuses, please
try other publishers.  If you're not sure whether a proposed license
is free, write to @email{licensing@@gnu.org}.

You can encourage commercial publishers to sell more free, copylefted
manuals and tutorials by buying them, and particularly by buying
copies from the publishers that paid for their writing or for major
improvements.  Meanwhile, try to avoid buying non-free documentation
at all.  Check the distribution terms of a manual before you buy it,
and insist that whoever seeks your business must respect your freedom.
Check the history of the book, and try reward the publishers that have
paid or pay the authors to work on it.

The Free Software Foundation maintains a list of free documentation
published by other publishers, at
http://www.fsf.org/doc/other-free-books.html.

====================================================================================================

GNU Lesser General Public License

Version 2.1, February 1999

Copyright @copyright{} 1991, 1999 Free Software Foundation, Inc.
59 Temple Place -- Suite 330, Boston, MA 02111-1307, USA

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.

[This is the first released version of the Lesser GPL.  It also counts
as the successor of the GNU Library Public License, version 2, hence the
version number 2.1.]

Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
Licenses are intended to guarantee your freedom to share and change
free software---to make sure the software is free for all its users.

  This license, the Lesser General Public License, applies to some
specially designated software---typically libraries---of the Free
Software Foundation and other authors who decide to use it.  You can use
it too, but we suggest you first think carefully about whether this
license or the ordinary General Public License is the better strategy to
use in any particular case, based on the explanations below.

  When we speak of free software, we are referring to freedom of use,
not price.  Our General Public Licenses are designed to make sure that
you have the freedom to distribute copies of free software (and charge
for this service if you wish); that you receive source code or can get
it if you want it; that you can change the software and use pieces of it
in new free programs; and that you are informed that you can do these
things.

  To protect your rights, we need to make restrictions that forbid
distributors to deny you these rights or to ask you to surrender these
rights.  These restrictions translate to certain responsibilities for
you if you distribute copies of the library or if you modify it.

  For example, if you distribute copies of the library, whether gratis
or for a fee, you must give the recipients all the rights that we gave
you.  You must make sure that they, too, receive or can get the source
code.  If you link other code with the library, you must provide
complete object files to the recipients, so that they can relink them
with the library after making changes to the library and recompiling
it.  And you must show them these terms so they know their rights.

  We protect your rights with a two-step method: (1) we copyright the
library, and (2) we offer you this license, which gives you legal
permission to copy, distribute and/or modify the library.

  To protect each distributor, we want to make it very clear that
there is no warranty for the free library.  Also, if the library is
modified by someone else and passed on, the recipients should know
that what they have is not the original version, so that the original
author's reputation will not be affected by problems that might be
introduced by others.

  Finally, software patents pose a constant threat to the existence of
any free program.  We wish to make sure that a company cannot
effectively restrict the users of a free program by obtaining a
restrictive license from a patent holder.  Therefore, we insist that
any patent license obtained for a version of the library must be
consistent with the full freedom of use specified in this license.

  Most GNU software, including some libraries, is covered by the
ordinary GNU General Public License.  This license, the GNU Lesser
General Public License, applies to certain designated libraries, and
is quite different from the ordinary General Public License.  We use
this license for certain libraries in order to permit linking those
libraries into non-free programs.

  When a program is linked with a library, whether statically or using
a shared library, the combination of the two is legally speaking a
combined work, a derivative of the original library.  The ordinary
General Public License therefore permits such linking only if the
entire combination fits its criteria of freedom.  The Lesser General
Public License permits more lax criteria for linking other code with
the library.

  We call this license the @dfn{Lesser} General Public License because it
does @emph{Less} to protect the user's freedom than the ordinary General
Public License.  It also provides other free software developers Less
of an advantage over competing non-free programs.  These disadvantages
are the reason we use the ordinary General Public License for many
libraries.  However, the Lesser license provides advantages in certain
special circumstances.

  For example, on rare occasions, there may be a special need to
encourage the widest possible use of a certain library, so that it becomes
a de-facto standard.  To achieve this, non-free programs must be
allowed to use the library.  A more frequent case is that a free
library does the same job as widely used non-free libraries.  In this
case, there is little to gain by limiting the free library to free
software only, so we use the Lesser General Public License.

  In other cases, permission to use a particular library in non-free
programs enables a greater number of people to use a large body of
free software.  For example, permission to use the GNU C Library in
non-free programs enables many more people to use the whole GNU
operating system, as well as its variant, the GNU/Linux operating
system.

  Although the Lesser General Public License is Less protective of the
users' freedom, it does ensure that the user of a program that is
linked with the Library has the freedom and the wherewithal to run
that program using a modified version of the Library.

  The precise terms and conditions for copying, distribution and
modification follow.  Pay close attention to the difference between a
``work based on the library'' and a ``work that uses the library''.  The
former contains code derived from the library, whereas the latter must
be combined with the library in order to run.

TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

0.
This License Agreement applies to any software library or other program
which contains a notice placed by the copyright holder or other
authorized party saying it may be distributed under the terms of this
Lesser General Public License (also called ``this License'').  Each
licensee is addressed as ``you''.

  A ``library'' means a collection of software functions and/or data
prepared so as to be conveniently linked with application programs
(which use some of those functions and data) to form executables.

  The ``Library'', below, refers to any such software library or work
which has been distributed under these terms.  A ``work based on the
Library'' means either the Library or any derivative work under
copyright law: that is to say, a work containing the Library or a
portion of it, either verbatim or with modifications and/or translated
straightforwardly into another language.  (Hereinafter, translation is
included without limitation in the term ``modification''.)

  ``Source code'' for a work means the preferred form of the work for
making modifications to it.  For a library, complete source code means
all the source code for all modules it contains, plus any associated
interface definition files, plus the scripts used to control compilation
and installation of the library.

  Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running a program using the Library is not restricted, and output from
such a program is covered only if its contents constitute a work based
on the Library (independent of the use of the Library in a tool for
writing it).  Whether that is true depends on what the Library does
and what the program that uses the Library does.

1.
You may copy and distribute verbatim copies of the Library's
complete source code as you receive it, in any medium, provided that
you conspicuously and appropriately publish on each copy an
appropriate copyright notice and disclaimer of warranty; keep intact
all the notices that refer to this License and to the absence of any
warranty; and distribute a copy of this License along with the
Library.

  You may charge a fee for the physical act of transferring a copy,
and you may at your option offer warranty protection in exchange for a
fee.

2.
You may modify your copy or copies of the Library or any portion
of it, thus forming a work based on the Library, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

a. The modified work must itself be a software library.

b. You must cause the files modified to carry prominent notices
stating that you changed the files and the date of any change.

c. You must cause the whole of the work to be licensed at no
charge to all third parties under the terms of this License.

d. If a facility in the modified Library refers to a function or a
table of data to be supplied by an application program that uses
the facility, other than as an argument passed when the facility
is invoked, then you must make a good faith effort to ensure that,
in the event an application does not supply such function or
table, the facility still operates, and performs whatever part of
its purpose remains meaningful.

(For example, a function in a library to compute square roots has
a purpose that is entirely well-defined independent of the
application.  Therefore, Subsection 2d requires that any
application-supplied function or table used by this function must
be optional: if the application does not supply it, the square
root function must still compute square roots.)
@end enumerate

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Library,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Library, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote
it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Library.

In addition, mere aggregation of another work not based on the Library
with the Library (or with a work based on the Library) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

3.
You may opt to apply the terms of the ordinary GNU General Public
License instead of this License to a given copy of the Library.  To do
this, you must alter all the notices that refer to this License, so
that they refer to the ordinary GNU General Public License, version 2,
instead of to this License.  (If a newer version than version 2 of the
ordinary GNU General Public License has appeared, then you can specify
that version instead if you wish.)  Do not make any other change in
these notices.

  Once this change is made in a given copy, it is irreversible for
that copy, so the ordinary GNU General Public License applies to all
subsequent copies and derivative works made from that copy.

  This option is useful when you wish to copy part of the code of
the Library into a program that is not a library.

4.
You may copy and distribute the Library (or a portion or
derivative of it, under Section 2) in object code or executable form
under the terms of Sections 1 and 2 above provided that you accompany
it with the complete corresponding machine-readable source code, which
must be distributed under the terms of Sections 1 and 2 above on a
medium customarily used for software interchange.

  If distribution of object code is made by offering access to copy
from a designated place, then offering equivalent access to copy the
source code from the same place satisfies the requirement to
distribute the source code, even though third parties are not
compelled to copy the source along with the object code.

5.
A program that contains no derivative of any portion of the
Library, but is designed to work with the Library by being compiled or
linked with it, is called a ``work that uses the Library''.  Such a
work, in isolation, is not a derivative work of the Library, and
therefore falls outside the scope of this License.

  However, linking a ``work that uses the Library'' with the Library
creates an executable that is a derivative of the Library (because it
contains portions of the Library), rather than a ``work that uses the
library''.  The executable is therefore covered by this License.
Section 6 states terms for distribution of such executables.

  When a ``work that uses the Library'' uses material from a header file
that is part of the Library, the object code for the work may be a
derivative work of the Library even though the source code is not.
Whether this is true is especially significant if the work can be
linked without the Library, or if the work is itself a library.  The
threshold for this to be true is not precisely defined by law.

  If such an object file uses only numerical parameters, data
structure layouts and accessors, and small macros and small inline
functions (ten lines or less in length), then the use of the object
file is unrestricted, regardless of whether it is legally a derivative
work.  (Executables containing this object code plus portions of the
Library will still fall under Section 6.)

  Otherwise, if the work is a derivative of the Library, you may
distribute the object code for the work under the terms of Section 6.
Any executables containing that work also fall under Section 6,
whether or not they are linked directly with the Library itself.

6.
As an exception to the Sections above, you may also combine or
link a ``work that uses the Library'' with the Library to produce a
work containing portions of the Library, and distribute that work
under terms of your choice, provided that the terms permit
modification of the work for the customer's own use and reverse
engineering for debugging such modifications.

  You must give prominent notice with each copy of the work that the
Library is used in it and that the Library and its use are covered by
this License.  You must supply a copy of this License.  If the work
during execution displays copyright notices, you must include the
copyright notice for the Library among them, as well as a reference
directing the user to the copy of this License.  Also, you must do one
of these things:

a. Accompany the work with the complete corresponding
machine-readable source code for the Library including whatever
changes were used in the work (which must be distributed under
Sections 1 and 2 above); and, if the work is an executable linked
with the Library, with the complete machine-readable ``work that
uses the Library'', as object code and/or source code, so that the
user can modify the Library and then relink to produce a modified
executable containing the modified Library.  (It is understood
that the user who changes the contents of definitions files in the
Library will not necessarily be able to recompile the application
to use the modified definitions.)

b. Use a suitable shared library mechanism for linking with the Library.  A
suitable mechanism is one that (1) uses at run time a copy of the
library already present on the user's computer system, rather than
copying library functions into the executable, and (2) will operate
properly with a modified version of the library, if the user installs
one, as long as the modified version is interface-compatible with the
version that the work was made with.

c. Accompany the work with a written offer, valid for at
least three years, to give the same user the materials
specified in Subsection 6a, above, for a charge no more
than the cost of performing this distribution.

d. If distribution of the work is made by offering access to copy
from a designated place, offer equivalent access to copy the above
specified materials from the same place.

e. Verify that the user has already received a copy of these
materials or that you have already sent this user a copy.
@end enumerate

  For an executable, the required form of the ``work that uses the
Library'' must include any data and utility programs needed for
reproducing the executable from it.  However, as a special exception,
the materials to be distributed need not include anything that is
normally distributed (in either source or binary form) with the major
components (compiler, kernel, and so on) of the operating system on
which the executable runs, unless that component itself accompanies the
executable.

  It may happen that this requirement contradicts the license
restrictions of other proprietary libraries that do not normally
accompany the operating system.  Such a contradiction means you cannot
use both them and the Library together in an executable that you
distribute.

7.
You may place library facilities that are a work based on the
Library side-by-side in a single library together with other library
facilities not covered by this License, and distribute such a combined
library, provided that the separate distribution of the work based on
the Library and of the other library facilities is otherwise
permitted, and provided that you do these two things:

a. Accompany the combined library with a copy of the same work
based on the Library, uncombined with any other library
facilities.  This must be distributed under the terms of the
Sections above.

b. Give prominent notice with the combined library of the fact
that part of it is a work based on the Library, and explaining
where to find the accompanying uncombined form of the same work.

8.
You may not copy, modify, sublicense, link with, or distribute
the Library except as expressly provided under this License.  Any
attempt otherwise to copy, modify, sublicense, link with, or
distribute the Library is void, and will automatically terminate your
rights under this License.  However, parties who have received copies,
or rights, from you under this License will not have their licenses
terminated so long as such parties remain in full compliance.

9.
You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Library or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Library (or any work based on the
Library), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Library or works based on it.

10.
Each time you redistribute the Library (or any work based on the
Library), the recipient automatically receives a license from the
original licensor to copy, distribute, link with or modify the Library
subject to these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties with
this License.

11.
If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Library at all.  For example, if a patent
license would not permit royalty-free redistribution of the Library by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Library.

If any portion of this section is held invalid or unenforceable under any
particular circumstance, the balance of the section is intended to apply,
and the section as a whole is intended to apply in other circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

12.
If the distribution and/or use of the Library is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Library under this License may add
an explicit geographical distribution limitation excluding those countries,
so that distribution is permitted only in or among countries not thus
excluded.  In such case, this License incorporates the limitation as if
written in the body of this License.

13.
The Free Software Foundation may publish revised and/or new
versions of the Lesser General Public License from time to time.
Such new versions will be similar in spirit to the present version,
but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Library
specifies a version number of this License which applies to it and
``any later version'', you have the option of following the terms and
conditions either of that version or of any later version published by
the Free Software Foundation.  If the Library does not specify a
license version number, you may choose any version ever published by
the Free Software Foundation.

14.
If you wish to incorporate parts of the Library into other free
programs whose distribution conditions are incompatible with these,
write to the author to ask for permission.  For software which is
copyrighted by the Free Software Foundation, write to the Free
Software Foundation; we sometimes make exceptions for this.  Our
decision will be guided by the two goals of preserving the free status
of all derivatives of our free software and of promoting the sharing
and reuse of software generally.

NO WARRANTY

15.
BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
OTHER PARTIES PROVIDE THE LIBRARY ``AS IS'' WITHOUT WARRANTY OF ANY
KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

16.
IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES.

END OF TERMS AND CONDITIONS

How to Apply These Terms to Your New Libraries

  If you develop a new library, and you want it to be of the greatest
possible use to the public, we recommend making it free software that
everyone can redistribute and change.  You can do so by permitting
redistribution under these terms (or, alternatively, under the terms of the
ordinary General Public License).

  To apply these terms, attach the following notices to the library.  It is
safest to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least the
``copyright'' line and a pointer to where the full notice is found.

    one line to give the library's name and an idea of what it does.
    Copyright (C) year name of author

    This library is free software; you can redistribute it and/or modify it
    under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2.1 of the License, or (at
    your option) any later version.

    This library is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
    USA.

Also add information on how to contact you by electronic and paper mail.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a ``copyright disclaimer'' for the library, if
necessary.  Here is a sample; alter the names:

    Yoyodyne, Inc., hereby disclaims all copyright interest in the library
    `Frob' (a library for tweaking knobs) written by James Random Hacker.

    signature of Ty Coon, 1 April 1990
    Ty Coon, President of Vice

That's all there is to it!

====================================================================================================

GNU Free Documentation License

Version 1.1, March 2000

Copyright @copyright{} 2000 Free Software Foundation, Inc.
59 Temple Place, Suite 330, Boston, MA  02111-1307, USA

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
@end display

0.
PREAMBLE

The purpose of this License is to make a manual, textbook, or other
written document @dfn{free} in the sense of freedom: to assure everyone
the effective freedom to copy and redistribute it, with or without
modifying it, either commercially or noncommercially.  Secondarily,
this License preserves for the author and publisher a way to get
credit for their work, while not being considered responsible for
modifications made by others.

This License is a kind of ``copyleft'', which means that derivative
works of the document must themselves be free in the same sense.  It
complements the GNU General Public License, which is a copyleft
license designed for free software.

We have designed this License in order to use it for manuals for free
software, because free software needs free documentation: a free
program should come with manuals providing the same freedoms that the
software does.  But this License is not limited to software manuals;
it can be used for any textual work, regardless of subject matter or
whether it is published as a printed book.  We recommend this License
principally for works whose purpose is instruction or reference.

1.
APPLICABILITY AND DEFINITIONS

This License applies to any manual or other work that contains a
notice placed by the copyright holder saying it can be distributed
under the terms of this License.  The ``Document'', below, refers to any
such manual or work.  Any member of the public is a licensee, and is
addressed as ``you''.

A ``Modified Version'' of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with
modifications and/or translated into another language.

A ``Secondary Section'' is a named appendix or a front-matter section of
the Document that deals exclusively with the relationship of the
publishers or authors of the Document to the Document's overall subject
(or to related matters) and contains nothing that could fall directly
within that overall subject.  (For example, if the Document is in part a
textbook of mathematics, a Secondary Section may not explain any
mathematics.)  The relationship could be a matter of historical
connection with the subject or with related matters, or of legal,
commercial, philosophical, ethical or political position regarding
them.

The ``Invariant Sections'' are certain Secondary Sections whose titles
are designated, as being those of Invariant Sections, in the notice
that says that the Document is released under this License.

The ``Cover Texts'' are certain short passages of text that are listed,
as Front-Cover Texts or Back-Cover Texts, in the notice that says that
the Document is released under this License.

A ``Transparent'' copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the
general public, whose contents can be viewed and edited directly and
straightforwardly with generic text editors or (for images composed of
pixels) generic paint programs or (for drawings) some widely available
drawing editor, and that is suitable for input to text formatters or
for automatic translation to a variety of formats suitable for input
to text formatters.  A copy made in an otherwise Transparent file
format whose markup has been designed to thwart or discourage
subsequent modification by readers is not Transparent.  A copy that is
not ``Transparent'' is called ``Opaque''.

Examples of suitable formats for Transparent copies include plain
@sc{ascii} without markup, Texinfo input format, La@TeX{} input format,
@acronym{SGML} or @acronym{XML} using a publicly available
@acronym{DTD}, and standard-conforming simple @acronym{HTML} designed
for human modification.  Opaque formats include PostScript,
@acronym{PDF}, proprietary formats that can be read and edited only by
proprietary word processors, @acronym{SGML} or @acronym{XML} for which
the @acronym{DTD} and/or processing tools are not generally available,
and the machine-generated @acronym{HTML} produced by some word
processors for output purposes only.

The ``Title Page'' means, for a printed book, the title page itself,
plus such following pages as are needed to hold, legibly, the material
this License requires to appear in the title page.  For works in
formats which do not have any title page as such, ``Title Page'' means
the text near the most prominent appearance of the work's title,
preceding the beginning of the body of the text.

2.
VERBATIM COPYING

You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies
to the Document are reproduced in all copies, and that you add no other
conditions whatsoever to those of this License.  You may not use
technical measures to obstruct or control the reading or further
copying of the copies you make or distribute.  However, you may accept
compensation in exchange for copies.  If you distribute a large enough
number of copies you must also follow the conditions in section 3.

You may also lend copies, under the same conditions stated above, and
you may publicly display copies.

3.
COPYING IN QUANTITY

If you publish printed copies of the Document numbering more than 100,
and the Document's license notice requires Cover Texts, you must enclose
the copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
the back cover.  Both covers must also clearly and legibly identify
you as the publisher of these copies.  The front cover must present
the full title with all words of the title equally prominent and
visible.  You may add other material on the covers in addition.
Copying with changes limited to the covers, as long as they preserve
the title of the Document and satisfy these conditions, can be treated
as verbatim copying in other respects.

If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.

If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transparent
copy along with each Opaque copy, or state in or with each Opaque copy
a publicly-accessible computer-network location containing a complete
Transparent copy of the Document, free of added material, which the
general network-using public has access to download anonymously at no
charge using public-standard network protocols.  If you use the latter
option, you must take reasonably prudent steps, when you begin
distribution of Opaque copies in quantity, to ensure that this
Transparent copy will remain thus accessible at the stated location
until at least one year after the last time you distribute an Opaque
copy (directly or through your agents or retailers) of that edition to
the public.

It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to give
them a chance to provide you with an updated version of the Document.

4.
MODIFICATIONS

You may copy and distribute a Modified Version of the Document under
the conditions of sections 2 and 3 above, provided that you release
the Modified Version under precisely this License, with the Modified
Version filling the role of the Document, thus licensing distribution
and modification of the Modified Version to whoever possesses a copy
of it.  In addition, you must do these things in the Modified Version:

A.
Use in the Title Page (and on the covers, if any) a title distinct
from that of the Document, and from those of previous versions
(which should, if there were any, be listed in the History section
of the Document).  You may use the same title as a previous version
if the original publisher of that version gives permission.

B.
List on the Title Page, as authors, one or more persons or entities
responsible for authorship of the modifications in the Modified
Version, together with at least five of the principal authors of the
Document (all of its principal authors, if it has less than five).

C.
State on the Title page the name of the publisher of the
Modified Version, as the publisher.

D.
Preserve all the copyright notices of the Document.

E.
Add an appropriate copyright notice for your modifications
adjacent to the other copyright notices.

F.
Include, immediately after the copyright notices, a license notice
giving the public permission to use the Modified Version under the
terms of this License, in the form shown in the Addendum below.

G.
Preserve in that license notice the full lists of Invariant Sections
and required Cover Texts given in the Document's license notice.

H.
Include an unaltered copy of this License.

I.
Preserve the section entitled ``History'', and its title, and add to
it an item stating at least the title, year, new authors, and
publisher of the Modified Version as given on the Title Page.  If
there is no section entitled ``History'' in the Document, create one
stating the title, year, authors, and publisher of the Document as
given on its Title Page, then add an item describing the Modified
Version as stated in the previous sentence.

J.
Preserve the network location, if any, given in the Document for
public access to a Transparent copy of the Document, and likewise
the network locations given in the Document for previous versions
it was based on.  These may be placed in the ``History'' section.
You may omit a network location for a work that was published at
least four years before the Document itself, or if the original
publisher of the version it refers to gives permission.

K.
In any section entitled ``Acknowledgments'' or ``Dedications'',
preserve the section's title, and preserve in the section all the
substance and tone of each of the contributor acknowledgments
and/or dedications given therein.

L.
Preserve all the Invariant Sections of the Document,
unaltered in their text and in their titles.  Section numbers
or the equivalent are not considered part of the section titles.

M.
Delete any section entitled ``Endorsements''.  Such a section
may not be included in the Modified Version.

N.
Do not retitle any existing section as ``Endorsements''
or to conflict in title with any Invariant Section.

If the Modified Version includes new front-matter sections or
appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or all
of these sections as invariant.  To do this, add their titles to the
list of Invariant Sections in the Modified Version's license notice.
These titles must be distinct from any other section titles.

You may add a section entitled ``Endorsements'', provided it contains
nothing but endorsements of your Modified Version by various
parties---for example, statements of peer review or that the text has
been approved by an organization as the authoritative definition of a
standard.

You may add a passage of up to five words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list
of Cover Texts in the Modified Version.  Only one passage of
Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity.  If the Document already
includes a cover text for the same cover, previously added by you or
by arrangement made by the same entity you are acting on behalf of,
you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.

The author(s) and publisher(s) of the Document do not by this License
give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.

5.
COMBINING DOCUMENTS

You may combine the Document with other documents released under this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its
license notice.

The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy.  If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by
adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number.
Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.

In the combination, you must combine any sections entitled ``History''
in the various original documents, forming one section entitled
``History''; likewise combine any sections entitled ``Acknowledgments'',
and any sections entitled ``Dedications''.  You must delete all sections
entitled ``Endorsements.''

6.
COLLECTIONS OF DOCUMENTS

You may make a collection consisting of the Document and other documents
released under this License, and replace the individual copies of this
License in the various documents with a single copy that is included in
the collection, provided that you follow the rules of this License for
verbatim copying of each of the documents in all other respects.

You may extract a single document from such a collection, and distribute
it individually under this License, provided you insert a copy of this
License into the extracted document, and follow this License in all
other respects regarding verbatim copying of that document.

7.
AGGREGATION WITH INDEPENDENT WORKS

A compilation of the Document or its derivatives with other separate
and independent documents or works, in or on a volume of a storage or
distribution medium, does not as a whole count as a Modified Version
of the Document, provided no compilation copyright is claimed for the
compilation.  Such a compilation is called an ``aggregate'', and this
License does not apply to the other self-contained works thus compiled
with the Document, on account of their being thus compiled, if they
are not themselves derivative works of the Document.

If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one quarter
of the entire aggregate, the Document's Cover Texts may be placed on
covers that surround only the Document within the aggregate.
Otherwise they must appear on covers around the whole aggregate.

8.
TRANSLATION

Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section 4.
Replacing Invariant Sections with translations requires special
permission from their copyright holders, but you may include
translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections.  You may include a
translation of this License provided that you also include the
original English version of this License.  In case of a disagreement
between the translation and the original English version of this
License, the original English version will prevail.

9.
TERMINATION

You may not copy, modify, sublicense, or distribute the Document except
as expressly provided for under this License.  Any other attempt to
copy, modify, sublicense or distribute the Document is void, and will
automatically terminate your rights under this License.  However,
parties who have received copies, or rights, from you under this
License will not have their licenses terminated so long as such
parties remain in full compliance.

10.
FUTURE REVISIONS OF THIS LICENSE

The Free Software Foundation may publish new, revised versions
of the GNU Free Documentation License from time to time.  Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.  See
@uref{http://www.gnu.org/copyleft/}.

Each version of the License is given a distinguishing version number.
If the Document specifies that a particular numbered version of this
License ``or any later version'' applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation.  If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.
@end enumerate

ADDENDUM: How to use this License for your documents

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and
license notices just after the title page:

  Copyright (C)  year  your name.
  Permission is granted to copy, distribute and/or modify this document
  under the terms of the GNU Free Documentation License, Version 1.1
  or any later version published by the Free Software Foundation;
  with the Invariant Sections being @var{list their titles}, with the
  Front-Cover Texts being @var{list}, and with the Back-Cover Texts being @var{list}.
  A copy of the license is included in the section entitled ``GNU
  Free Documentation License''.

If you have no Invariant Sections, write ``with no Invariant Sections''
instead of saying which ones are invariant.  If you have no
Front-Cover Texts, write ``no Front-Cover Texts'' instead of
``Front-Cover Texts being @var{list}''; likewise for Back-Cover Texts.

If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License,
to permit their use in free software.

========================================================================================

A transparent copy of this modified document can be found along-side the binary .libhover file
in the org.eclipse.cdt.libhover.glibc plug-in jar under the data directory.  The plug-in can be
unzipped via "unzip".  The original un-modified document can be generated from the sources which
can be found at: http://ftp.gnu.org/gnu/glibc/glibc-2.14.tar.gz

      </synopsis>
    </function>
  </construct>
  <construct id="function-getpass" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *prompt"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; &lt;CODE&gt;getpass&lt;/CODE&gt; outputs &lt;VAR&gt;prompt&lt;/VAR&gt;, then reads a string in from the
         terminal without echoing it.  It tries to connect to the real terminal,
         &lt;TT&gt;/dev/tty&lt;/TT&gt;, if possible, to encourage users not to put plaintext
         passwords in files; otherwise, it uses &lt;CODE&gt;stdin&lt;/CODE&gt; and &lt;CODE&gt;stderr&lt;/CODE&gt;.
         &lt;CODE&gt;getpass&lt;/CODE&gt; also disables the INTR, QUIT, and SUSP characters on the
         terminal using the &lt;CODE&gt;ISIG&lt;/CODE&gt; terminal attribute .
         The terminal is flushed before and after &lt;CODE&gt;getpass&lt;/CODE&gt;, so that
         characters of a mistyped password are not accidentally visible.
         &lt;br&gt;&lt;br&gt; In other C libraries, &lt;CODE&gt;getpass&lt;/CODE&gt; may only return the first
         &lt;CODE&gt;PASS_MAX&lt;/CODE&gt; bytes of a password.  The GNU C library has no limit, so
         &lt;CODE&gt;PASS_MAX&lt;/CODE&gt; is undefined.
         &lt;br&gt;&lt;br&gt; The prototype for this function is in &lt;TT&gt;unistd.h&lt;/TT&gt;.  &lt;CODE&gt;PASS_MAX&lt;/CODE&gt;
         would be defined in &lt;TT&gt;limits.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-crypt" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *key"/>
        <parameter content="const char *salt"/>
      </prototype>
      <headers>
        <header filename = "crypt.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;crypt&lt;/CODE&gt; function takes a password, &lt;VAR&gt;key&lt;/VAR&gt;, as a string, and
         a &lt;VAR&gt;salt&lt;/VAR&gt; character array which is described below, and returns a
         printable ASCII string which starts with another salt.  It is believed
         that, given the output of the function, the best way to find a &lt;VAR&gt;key&lt;/VAR&gt;
         that will produce that output is to guess values of &lt;VAR&gt;key&lt;/VAR&gt; until the
         original value of &lt;VAR&gt;key&lt;/VAR&gt; is found.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;salt&lt;/VAR&gt; parameter does two things.  Firstly, it selects which
         algorithm is used, the MD5-based one or the DES-based one.  Secondly, it
         makes life harder for someone trying to guess passwords against a file
         containing many passwords; without a &lt;VAR&gt;salt&lt;/VAR&gt;, an intruder can make a
         guess, run &lt;CODE&gt;crypt&lt;/CODE&gt; on it once, and compare the result with all the
         passwords.  With a &lt;VAR&gt;salt&lt;/VAR&gt;, the intruder must run &lt;CODE&gt;crypt&lt;/CODE&gt; once
         for each different salt.
         &lt;br&gt;&lt;br&gt; For the MD5-based algorithm, the &lt;VAR&gt;salt&lt;/VAR&gt; should consist of the string
         &lt;CODE&gt;$1$&lt;/CODE&gt;, followed by up to 8 characters, terminated by either
         another &lt;CODE&gt;$&lt;/CODE&gt; or the end of the string.  The result of &lt;CODE&gt;crypt&lt;/CODE&gt;
         will be the &lt;VAR&gt;salt&lt;/VAR&gt;, followed by a &lt;CODE&gt;$&lt;/CODE&gt; if the salt didn't end
         with one, followed by 22 characters from the alphabet
         &lt;CODE&gt;./0-9A-Za-z&lt;/CODE&gt;, up to 34 characters total.  Every character in the
         &lt;VAR&gt;key&lt;/VAR&gt; is significant.
         &lt;br&gt;&lt;br&gt; For the DES-based algorithm, the &lt;VAR&gt;salt&lt;/VAR&gt; should consist of two
         characters from the alphabet &lt;CODE&gt;./0-9A-Za-z&lt;/CODE&gt;, and the result of
         &lt;CODE&gt;crypt&lt;/CODE&gt; will be those two characters followed by 11 more from the
         same alphabet, 13 in total.  Only the first 8 characters in the
         &lt;VAR&gt;key&lt;/VAR&gt; are significant.
         &lt;br&gt;&lt;br&gt; The MD5-based algorithm has no limit on the useful length of the
         password used, and is slightly more secure.  It is therefore preferred
         over the DES-based algorithm.
         &lt;br&gt;&lt;br&gt; When the user enters their password for the first time, the &lt;VAR&gt;salt&lt;/VAR&gt;
         should be set to a new string which is reasonably random.  To verify a
         password against the result of a previous call to &lt;CODE&gt;crypt&lt;/CODE&gt;, pass
         the result of the previous call as the &lt;VAR&gt;salt&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-crypt_r" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *key"/>
        <parameter content="const char *salt"/>
        <parameter content="{struct crypt_data *} data"/>
      </prototype>
      <headers>
        <header filename = "crypt.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;crypt_r&lt;/CODE&gt; function does the same thing as &lt;CODE&gt;crypt&lt;/CODE&gt;, but
         takes an extra parameter which includes space for its result (among
         other things), so it can be reentrant.  &lt;CODE&gt;data-&gt;&lt;/CODE&gt;initialized must be
         cleared to zero before the first time &lt;CODE&gt;crypt_r&lt;/CODE&gt; is called.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;crypt_r&lt;/CODE&gt; function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-setkey" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="const char *key"/>
      </prototype>
      <headers>
        <header filename = "crypt.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;setkey&lt;/CODE&gt; function sets an internal data structure to be an
         expanded form of &lt;VAR&gt;key&lt;/VAR&gt;.  &lt;VAR&gt;key&lt;/VAR&gt; is specified as an array of 64
         bits each stored in a &lt;CODE&gt;char&lt;/CODE&gt;, the first bit is &lt;CODE&gt;key[0]&lt;/CODE&gt; and
         the 64th bit is &lt;CODE&gt;key[63]&lt;/CODE&gt;.  The &lt;VAR&gt;key&lt;/VAR&gt; should have the correct
         parity.
        </synopsis>
    </function>
  </construct>
  <construct id="function-encrypt" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="char *block"/>
        <parameter content="int edflag"/>
      </prototype>
      <headers>
        <header filename = "crypt.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;encrypt&lt;/CODE&gt; function encrypts &lt;VAR&gt;block&lt;/VAR&gt; if
         &lt;VAR&gt;edflag&lt;/VAR&gt; is 0, otherwise it decrypts &lt;VAR&gt;block&lt;/VAR&gt;, using a key
         previously set by &lt;CODE&gt;setkey&lt;/CODE&gt;.  The result is
         placed in &lt;VAR&gt;block&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; Like &lt;CODE&gt;setkey&lt;/CODE&gt;, &lt;VAR&gt;block&lt;/VAR&gt; is specified as an array of 64 bits each
         stored in a &lt;CODE&gt;char&lt;/CODE&gt;, but there are no parity bits in &lt;VAR&gt;block&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-setkey_r" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="const char *key"/>
        <parameter content="{struct crypt_data *} data"/>
      </prototype>
      <headers>
        <header filename = "crypt.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; These are reentrant versions of &lt;CODE&gt;setkey&lt;/CODE&gt; and &lt;CODE&gt;encrypt&lt;/CODE&gt;.  The
         only difference is the extra parameter, which stores the expanded
         version of &lt;VAR&gt;key&lt;/VAR&gt;.  Before calling &lt;CODE&gt;setkey_r&lt;/CODE&gt; the first time,
         &lt;CODE&gt;data-&gt;initialized&lt;/CODE&gt; must be cleared to zero.
        </synopsis>
    </function>
  </construct>
  <construct id="function-encrypt_r" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="char *block"/>
        <parameter content="int edflag"/>
        <parameter content="{struct crypt_data *} data"/>
      </prototype>
      <headers>
        <header filename = "crypt.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; These are reentrant versions of &lt;CODE&gt;setkey&lt;/CODE&gt; and &lt;CODE&gt;encrypt&lt;/CODE&gt;.  The
         only difference is the extra parameter, which stores the expanded
         version of &lt;VAR&gt;key&lt;/VAR&gt;.  Before calling &lt;CODE&gt;setkey_r&lt;/CODE&gt; the first time,
         &lt;CODE&gt;data-&gt;initialized&lt;/CODE&gt; must be cleared to zero.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ecb_crypt" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="char *key"/>
        <parameter content="char *blocks"/>
        <parameter content="unsigned len"/>
        <parameter content="unsigned mode"/>
      </prototype>
      <headers>
        <header filename = "rpc/des_crypt.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; The function &lt;CODE&gt;ecb_crypt&lt;/CODE&gt; encrypts or decrypts one or more blocks
         using DES.  Each block is encrypted independently.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;blocks&lt;/VAR&gt; and the &lt;VAR&gt;key&lt;/VAR&gt; are stored packed in 8-bit bytes, so
         that the first bit of the key is the most-significant bit of
         &lt;CODE&gt;key[0]&lt;/CODE&gt; and the 63rd bit of the key is stored as the
         least-significant bit of &lt;CODE&gt;key[7]&lt;/CODE&gt;.  The &lt;VAR&gt;key&lt;/VAR&gt; should have the
         correct parity.
         &lt;br&gt;&lt;br&gt; &lt;VAR&gt;len&lt;/VAR&gt; is the number of bytes in &lt;VAR&gt;blocks&lt;/VAR&gt;.  It should be a
         multiple of 8 (so that there is a whole number of blocks to encrypt).
         &lt;VAR&gt;len&lt;/VAR&gt; is limited to a maximum of &lt;CODE&gt;DES_MAXDATA&lt;/CODE&gt; bytes.
         &lt;br&gt;&lt;br&gt; The result of the encryption replaces the input in &lt;VAR&gt;blocks&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;mode&lt;/VAR&gt; parameter is the bitwise OR of two of the following:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;DES_ENCRYPT&lt;/CODE&gt;
&lt;DD&gt;
         This constant, used in the &lt;VAR&gt;mode&lt;/VAR&gt; parameter, specifies that
         &lt;VAR&gt;blocks&lt;/VAR&gt; is to be encrypted.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;DES_DECRYPT&lt;/CODE&gt;
&lt;DD&gt;
         This constant, used in the &lt;VAR&gt;mode&lt;/VAR&gt; parameter, specifies that
         &lt;VAR&gt;blocks&lt;/VAR&gt; is to be decrypted.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;DES_HW&lt;/CODE&gt;
&lt;DD&gt;
         This constant, used in the &lt;VAR&gt;mode&lt;/VAR&gt; parameter, asks to use a hardware
         device.  If no hardware device is available, encryption happens anyway,
         but in software.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;DES_SW&lt;/CODE&gt;
&lt;DD&gt;
         This constant, used in the &lt;VAR&gt;mode&lt;/VAR&gt; parameter, specifies that no
         hardware device is to be used.
         &lt;/DL&gt;
         &lt;br&gt;&lt;br&gt; The result of the function will be one of these values:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;DESERR_NONE&lt;/CODE&gt;
&lt;DD&gt;
         The encryption succeeded.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;DESERR_NOHWDEVICE&lt;/CODE&gt;
&lt;DD&gt;
         The encryption succeeded, but there was no hardware device available.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;DESERR_HWERROR&lt;/CODE&gt;
&lt;DD&gt;
         The encryption failed because of a hardware problem.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;DESERR_BADPARAM&lt;/CODE&gt;
&lt;DD&gt;
         The encryption failed because of a bad parameter, for instance &lt;VAR&gt;len&lt;/VAR&gt;
         is not a multiple of 8 or &lt;VAR&gt;len&lt;/VAR&gt; is larger than &lt;CODE&gt;DES_MAXDATA&lt;/CODE&gt;.
         &lt;/DL&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-DES_FAILED" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int err"/>
      </prototype>
      <headers>
        <header filename = "rpc/des_crypt.h"/>
      </headers>
        <synopsis>
        This macro returns 1 if &lt;VAR&gt;err&lt;/VAR&gt; is a `success' result code from
         &lt;CODE&gt;ecb_crypt&lt;/CODE&gt; or &lt;CODE&gt;cbc_crypt&lt;/CODE&gt;, and 0 otherwise.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cbc_crypt" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="char *key"/>
        <parameter content="char *blocks"/>
        <parameter content="unsigned len"/>
        <parameter content="unsigned mode"/>
        <parameter content="char *ivec"/>
      </prototype>
      <headers>
        <header filename = "rpc/des_crypt.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; The function &lt;CODE&gt;cbc_crypt&lt;/CODE&gt; encrypts or decrypts one or more blocks
         using DES in Cipher Block Chaining mode.
         &lt;br&gt;&lt;br&gt; For encryption in CBC mode, each block is exclusive-ored with &lt;VAR&gt;ivec&lt;/VAR&gt;
         before being encrypted, then &lt;VAR&gt;ivec&lt;/VAR&gt; is replaced with the result of
         the encryption, then the next block is processed.  Decryption is the
         reverse of this process.
         &lt;br&gt;&lt;br&gt; This has the advantage that blocks which are the same before being
         encrypted are very unlikely to be the same after being encrypted, making
         it much harder to detect patterns in the data.
         &lt;br&gt;&lt;br&gt; Usually, &lt;VAR&gt;ivec&lt;/VAR&gt; is set to 8 random bytes before encryption starts.
         Then the 8 random bytes are transmitted along with the encrypted data
         (without themselves being encrypted), and passed back in as &lt;VAR&gt;ivec&lt;/VAR&gt;
         for decryption.  Another possibility is to set &lt;VAR&gt;ivec&lt;/VAR&gt; to 8 zeroes
         initially, and have the first the block encrypted consist of 8 random
         bytes.
         &lt;br&gt;&lt;br&gt; Otherwise, all the parameters are similar to those for &lt;CODE&gt;ecb_crypt&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-des_setparity" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="char *key"/>
      </prototype>
      <headers>
        <header filename = "rpc/des_crypt.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; The function &lt;CODE&gt;des_setparity&lt;/CODE&gt; changes the 64-bit &lt;VAR&gt;key&lt;/VAR&gt;, stored
         packed in 8-bit bytes, to have odd parity by altering the low bits of
         each byte.
        </synopsis>
    </function>
  </construct>
  <construct id="function-gethostname" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="char *name"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        This function returns the host name of the system on which it is called,
         in the array &lt;VAR&gt;name&lt;/VAR&gt;.  The &lt;VAR&gt;size&lt;/VAR&gt; argument specifies the size of
         this array, in bytes.  Note that this is &lt;EM&gt;not&lt;/EM&gt; the DNS hostname.
         If the system participates in DNS, this is the FQDN (see above).
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; on success and &lt;CODE&gt;-1&lt;/CODE&gt; on failure.  In
         the GNU C library, &lt;CODE&gt;gethostname&lt;/CODE&gt; fails if &lt;VAR&gt;size&lt;/VAR&gt; is not large
         enough; then you can try again with a larger array.  The following
         &lt;CODE&gt;errno&lt;/CODE&gt; error condition is defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;ENAMETOOLONG&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;size&lt;/VAR&gt; argument is less than the size of the host name plus one.

         &lt;br&gt;&lt;br&gt; On some systems, there is a symbol for the maximum possible host name
         length: &lt;CODE&gt;MAXHOSTNAMELEN&lt;/CODE&gt;.  It is defined in &lt;TT&gt;sys/param.h&lt;/TT&gt;.
         But you can't count on this to exist, so it is cleaner to handle
         failure and try again.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;gethostname&lt;/CODE&gt; stores the beginning of the host name in &lt;VAR&gt;name&lt;/VAR&gt;
         even if the host name won't entirely fit.  For some purposes, a
         truncated host name is good enough.  If it is, you can ignore the
         error code.
        </synopsis>
    </function>
  </construct>
  <construct id="function-sethostname" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *name"/>
        <parameter content="size_t length"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;sethostname&lt;/CODE&gt; function sets the host name of the system that
         calls it to &lt;VAR&gt;name&lt;/VAR&gt;, a string with length &lt;VAR&gt;length&lt;/VAR&gt;.  Only
         privileged processes are permitted to do this.
         &lt;br&gt;&lt;br&gt; Usually &lt;CODE&gt;sethostname&lt;/CODE&gt; gets called just once, at system boot time.
         Often, the program that calls it sets it to the value it finds in the
         file &lt;CODE&gt;/etc/hostname&lt;/CODE&gt;.
         /etc/hostname
         &lt;br&gt;&lt;br&gt; Be sure to set the host name to the full host name, not just the DNS
         hostname (see above).
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; on success and &lt;CODE&gt;-1&lt;/CODE&gt; on failure.
         The following &lt;CODE&gt;errno&lt;/CODE&gt; error condition is defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EPERM&lt;/CODE&gt;
&lt;DD&gt;
         This process cannot set the host name because it is not privileged.

        </synopsis>
    </function>
  </construct>
  <construct id="function-getdomainnname" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="char *name"/>
        <parameter content="size_t length"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
         domain name
          domain name
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;getdomainname&lt;/CODE&gt; returns the NIS (aka YP) domain name of the system
         on which it is called.  Note that this is not the more popular DNS
         domain name.  Get that with &lt;CODE&gt;gethostname&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The specifics of this function are analogous to &lt;CODE&gt;gethostname&lt;/CODE&gt;, above.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-setdomainname" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *name"/>
        <parameter content="size_t length"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
         domain name
          domain name
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;getdomainname&lt;/CODE&gt; sets the NIS (aka YP) domain name of the system
         on which it is called.  Note that this is not the more popular DNS
         domain name.  Set that with &lt;CODE&gt;sethostname&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The specifics of this function are analogous to &lt;CODE&gt;sethostname&lt;/CODE&gt;, above.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-gethostid" type="function">
    <function returntype="long int">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        This function returns the ``host ID'' of the machine the program is
         running on.  By convention, this is usually the primary Internet IP address
         of that machine, converted to a &lt;CODE&gt;long int&lt;/CODE&gt;.  However, on some
         systems it is a meaningless but unique number which is hard-coded for
         each machine.
         &lt;br&gt;&lt;br&gt; This is not widely used.  It arose in BSD 4.2, but was dropped in BSD 4.4.
         It is not required by POSIX.
         &lt;br&gt;&lt;br&gt; The proper way to query the IP address is to use &lt;CODE&gt;gethostbyname&lt;/CODE&gt;
         on the results of &lt;CODE&gt;gethostname&lt;/CODE&gt;.  For more information on IP addresses,
         .
        </synopsis>
    </function>
  </construct>
  <construct id="function-sethostid" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="long int id"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;sethostid&lt;/CODE&gt; function sets the ``host ID'' of the host machine
         to &lt;VAR&gt;id&lt;/VAR&gt;.  Only privileged processes are permitted to do this.  Usually
         it happens just once, at system boot time.
         &lt;br&gt;&lt;br&gt; The proper way to establish the primary IP address of a system
         is to configure the IP address resolver to associate that IP address with
         the system's host name as returned by &lt;CODE&gt;gethostname&lt;/CODE&gt;.  For example,
         put a record for the system in &lt;TT&gt;/etc/hosts&lt;/TT&gt;.
         &lt;br&gt;&lt;br&gt; See &lt;CODE&gt;gethostid&lt;/CODE&gt; above for more information on host ids.
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; on success and &lt;CODE&gt;-1&lt;/CODE&gt; on failure.
         The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EPERM&lt;/CODE&gt;
&lt;DD&gt;
         This process cannot set the host name because it is not privileged.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOSYS
         The operating system does not support setting the host ID.  On some
         systems, the host ID is a meaningless but unique number hard-coded for
         each machine.

        </synopsis>
    </function>
  </construct>
  <construct id="struct-utsname" type="struct">
    <structure>
        <synopsis>
        The &lt;CODE&gt;utsname&lt;/CODE&gt; structure is used to hold information returned
         by the &lt;CODE&gt;uname&lt;/CODE&gt; function.  It has the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="char sysname[]">
            <synopsis>
            This is the name of the operating system in use.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="char release[]">
            <synopsis>
            This is the current release level of the operating system implementation.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="char version[]">
            <synopsis>
            This is the current version level within the release of the operating
             system.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="char machine[]">
            <synopsis>
            This is a description of the type of hardware that is in use.
             &lt;br&gt;&lt;br&gt; Some systems provide a mechanism to interrogate the kernel directly for
             this information.  On systems without such a mechanism, the GNU C
             library fills in this field based on the configuration name that was
             specified when building and installing the library.
             &lt;br&gt;&lt;br&gt; GNU uses a three-part name to describe a system configuration; the three
             parts are &lt;VAR&gt;cpu&lt;/VAR&gt;, &lt;VAR&gt;manufacturer&lt;/VAR&gt; and &lt;VAR&gt;system-type&lt;/VAR&gt;, and they
             are separated with dashes.  Any possible combination of three names is
             potentially meaningful, but most such combinations are meaningless in
             practice and even the meaningful ones are not necessarily supported by
             any particular GNU program.
             &lt;br&gt;&lt;br&gt; Since the value in &lt;CODE&gt;machine&lt;/CODE&gt; is supposed to describe just the
             hardware, it consists of the first two parts of the configuration name:
             &lt;samp&gt;&lt;VAR&gt;cpu&lt;/VAR&gt;-&lt;VAR&gt;manufacturer&lt;/VAR&gt;&lt;/samp&gt;.  For example, it might be one of these:
             &lt;br&gt;&lt;br&gt;
             &lt;CODE&gt;"sparc-sun"&lt;/CODE&gt;,
             &lt;CODE&gt;"i386-&lt;VAR&gt;anything&lt;/VAR&gt;"&lt;/CODE&gt;,
             &lt;CODE&gt;"m68k-hp"&lt;/CODE&gt;,
             &lt;CODE&gt;"m68k-sony"&lt;/CODE&gt;,
             &lt;CODE&gt;"m68k-sun"&lt;/CODE&gt;,
             &lt;CODE&gt;"mips-dec"&lt;/CODE&gt;

             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="char nodename[]">
            <synopsis>
            This is the host name of this particular computer.  In the GNU C
             library, the value is the same as that returned by &lt;CODE&gt;gethostname&lt;/CODE&gt;;
             see Host Identification.
             &lt;br&gt;&lt;br&gt; @ gethostname() is implemented with a call to uname().
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-uname" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="struct utsname *info"/>
      </prototype>
      <headers>
        <header filename = "sys/utsname.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;uname&lt;/CODE&gt; function fills in the structure pointed to by
         &lt;VAR&gt;info&lt;/VAR&gt; with information about the operating system and host machine.
         A non-negative value indicates that the data was successfully stored.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;-1&lt;/CODE&gt; as the value indicates an error.  The only error possible is
         &lt;CODE&gt;EFAULT&lt;/CODE&gt;, which we normally don't mention as it is always a
         possibility.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-fstab" type="struct">
    <structure>
        <synopsis>
        This structure is used with the &lt;CODE&gt;getfsent&lt;/CODE&gt;, &lt;CODE&gt;getfsspec&lt;/CODE&gt;, and
         &lt;CODE&gt;getfsfile&lt;/CODE&gt; functions.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="char *fs_spec">
            <synopsis>
            This element describes the device from which the filesystem is mounted.
             Normally this is the name of a special device, such as a hard disk
             partition, but it could also be a more or less generic string.  For
             NFS it would be a hostname and directory name combination.
             &lt;br&gt;&lt;br&gt; Even though the element is not declared &lt;CODE&gt;const&lt;/CODE&gt; it shouldn't be
             modified.  The missing &lt;CODE&gt;const&lt;/CODE&gt; has historic reasons, since this
             function predates ISO C.  The same is true for the other string
             elements of this structure.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="char *fs_file">
            <synopsis>
            This describes the mount point on the local system.  I.e., accessing any
             file in this filesystem has implicitly or explicitly this string as a
             prefix.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="char *fs_vfstype">
            <synopsis>
            This is the type of the filesystem.  Depending on what the underlying
             kernel understands it can be any string.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="char *fs_mntops">
            <synopsis>
            This is a string containing options passed to the kernel with the
             &lt;CODE&gt;mount&lt;/CODE&gt; call.  Again, this can be almost anything.  There can be
             more than one option, separated from the others by a comma.  Each option
             consists of a name and an optional value part, introduced by an &lt;CODE&gt;=&lt;/CODE&gt;
             character.
             &lt;br&gt;&lt;br&gt; If the value of this element must be processed it should ideally be done
             using the &lt;CODE&gt;getsubopt&lt;/CODE&gt; function; see Suboptions.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="const char *fs_type">
            <synopsis>
            This name is poorly chosen.  This element points to a string (possibly
             in the &lt;CODE&gt;fs_mntops&lt;/CODE&gt; string) which describes the modes with which the
             filesystem is mounted.  &lt;TT&gt;fstab&lt;/TT&gt; defines five macros to describe the
             possible values:
             &lt;br&gt;&lt;br&gt; &lt;DL&gt;

            </synopsis>
        </element>
        <element content="FSTAB_RW">
            <synopsis>
            The filesystems gets mounted with read and write enabled.
            </synopsis>
        </element>
        <element content="FSTAB_RQ">
            <synopsis>
            The filesystems gets mounted with read and write enabled.  Write access
             is restricted by quotas.
            </synopsis>
        </element>
        <element content="FSTAB_RO">
            <synopsis>
            The filesystem gets mounted read-only.
            </synopsis>
        </element>
        <element content="FSTAB_SW">
            <synopsis>
            This is not a real filesystem, it is a swap device.
            </synopsis>
        </element>
        <element content="FSTAB_XX">
            <synopsis>
            This entry from the &lt;TT&gt;fstab&lt;/TT&gt; file is totally ignored.
             &lt;/DL&gt;
             &lt;br&gt;&lt;br&gt; Testing for equality with these value must happen using &lt;CODE&gt;strcmp&lt;/CODE&gt;
             since these are all strings.  Comparing the pointer will probably always
             fail.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int fs_freq">
            <synopsis>
            This element describes the dump frequency in days.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-setfsent" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "fstab.h"/>
      </headers>
        <synopsis>
        This function makes sure that the internal read pointer for the
         &lt;TT&gt;fstab&lt;/TT&gt; file is at the beginning of the file.  This is done by
         either opening the file or resetting the read pointer.
         &lt;br&gt;&lt;br&gt; Since the file handle is internal to the libc this function is not
         thread-safe.
         &lt;br&gt;&lt;br&gt; This function returns a non-zero value if the operation was successful
         and the &lt;CODE&gt;getfs*&lt;/CODE&gt; functions can be used to read the entries of the
         file.
        </synopsis>
    </function>
  </construct>
  <construct id="function-endfsent" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "fstab.h"/>
      </headers>
        <synopsis>
        This function makes sure that all resources acquired by a prior call to
         &lt;CODE&gt;setfsent&lt;/CODE&gt; (explicitly or implicitly by calling &lt;CODE&gt;getfsent&lt;/CODE&gt;) are
         freed.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getfsent" type="function">
    <function returntype="struct fstab *">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "fstab.h"/>
      </headers>
        <synopsis>
        This function returns the next entry of the &lt;TT&gt;fstab&lt;/TT&gt; file.  If this
         is the first call to any of the functions handling &lt;TT&gt;fstab&lt;/TT&gt; since
         program start or the last call of &lt;CODE&gt;endfsent&lt;/CODE&gt;, the file will be
         opened.
         &lt;br&gt;&lt;br&gt; The function returns a pointer to a variable of type &lt;CODE&gt;struct
         fstab&lt;/CODE&gt;.  This variable is shared by all threads and therefore this
         function is not thread-safe.  If an error occurred &lt;CODE&gt;getfsent&lt;/CODE&gt;
         returns a &lt;CODE&gt;NULL&lt;/CODE&gt; pointer.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getfsspec" type="function">
    <function returntype="struct fstab *">
      <prototype>
        <parameter content="const char *name"/>
      </prototype>
      <headers>
        <header filename = "fstab.h"/>
      </headers>
        <synopsis>
        This function returns the next entry of the &lt;TT&gt;fstab&lt;/TT&gt; file which has
         a string equal to &lt;VAR&gt;name&lt;/VAR&gt; pointed to by the &lt;CODE&gt;fs_spec&lt;/CODE&gt; element.
         Since there is normally exactly one entry for each special device it
         makes no sense to call this function more than once for the same
         argument.  If this is the first call to any of the functions handling
         &lt;TT&gt;fstab&lt;/TT&gt; since program start or the last call of &lt;CODE&gt;endfsent&lt;/CODE&gt;,
         the file will be opened.
         &lt;br&gt;&lt;br&gt; The function returns a pointer to a variable of type &lt;CODE&gt;struct
         fstab&lt;/CODE&gt;.  This variable is shared by all threads and therefore this
         function is not thread-safe.  If an error occurred &lt;CODE&gt;getfsent&lt;/CODE&gt;
         returns a &lt;CODE&gt;NULL&lt;/CODE&gt; pointer.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getfsfile" type="function">
    <function returntype="struct fstab *">
      <prototype>
        <parameter content="const char *name"/>
      </prototype>
      <headers>
        <header filename = "fstab.h"/>
      </headers>
        <synopsis>
        This function returns the next entry of the &lt;TT&gt;fstab&lt;/TT&gt; file which has
         a string equal to &lt;VAR&gt;name&lt;/VAR&gt; pointed to by the &lt;CODE&gt;fs_file&lt;/CODE&gt; element.
         Since there is normally exactly one entry for each mount point it
         makes no sense to call this function more than once for the same
         argument.  If this is the first call to any of the functions handling
         &lt;TT&gt;fstab&lt;/TT&gt; since program start or the last call of &lt;CODE&gt;endfsent&lt;/CODE&gt;,
         the file will be opened.
         &lt;br&gt;&lt;br&gt; The function returns a pointer to a variable of type &lt;CODE&gt;struct
         fstab&lt;/CODE&gt;.  This variable is shared by all threads and therefore this
         function is not thread-safe.  If an error occurred &lt;CODE&gt;getfsent&lt;/CODE&gt;
         returns a &lt;CODE&gt;NULL&lt;/CODE&gt; pointer.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-mntent" type="struct">
    <structure>
        <synopsis>
        This structure is used with the &lt;CODE&gt;getmntent&lt;/CODE&gt;, &lt;CODE&gt;getmntent_t&lt;/CODE&gt;,
         &lt;CODE&gt;addmntent&lt;/CODE&gt;, and &lt;CODE&gt;hasmntopt&lt;/CODE&gt; functions.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="char *mnt_fsname">
            <synopsis>
            This element contains a pointer to a string describing the name of the
             special device from which the filesystem is mounted.  It corresponds to
             the &lt;CODE&gt;fs_spec&lt;/CODE&gt; element in &lt;CODE&gt;struct fstab&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="char *mnt_dir">
            <synopsis>
            This element points to a string describing the mount point of the
             filesystem.  It corresponds to the &lt;CODE&gt;fs_file&lt;/CODE&gt; element in
             &lt;CODE&gt;struct fstab&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="char *mnt_type">
            <synopsis>
            &lt;CODE&gt;mnt_type&lt;/CODE&gt; describes the filesystem type and is therefore
             equivalent to &lt;CODE&gt;fs_vfstype&lt;/CODE&gt; in &lt;CODE&gt;struct fstab&lt;/CODE&gt;.  &lt;TT&gt;mntent.h&lt;/TT&gt;
             defines a few symbolic names for some of the values this string can have.
             But since the kernel can support arbitrary filesystems it does not
             make much sense to give them symbolic names.  If one knows the symbol
             name one also knows the filesystem name.  Nevertheless here follows the
             list of the symbols provided in &lt;TT&gt;mntent.h&lt;/TT&gt;.
             &lt;br&gt;&lt;br&gt; &lt;DL&gt;

            </synopsis>
        </element>
        <element content="MNTTYPE_IGNORE">
            <synopsis>
            This symbol expands to &lt;CODE&gt;"ignore"&lt;/CODE&gt;.  The value is sometime used in
             &lt;TT&gt;fstab&lt;/TT&gt; files to make sure entries are not used without removing them.
            </synopsis>
        </element>
        <element content="MNTTYPE_NFS">
            <synopsis>
            Expands to &lt;CODE&gt;"nfs"&lt;/CODE&gt;.  Using this macro sometimes could make sense
             since it names the default NFS implementation, in case both version 2
             and 3 are supported.
            </synopsis>
        </element>
        <element content="MNTTYPE_SWAP">
            <synopsis>
            This symbol expands to &lt;CODE&gt;"swap"&lt;/CODE&gt;.  It names the special &lt;TT&gt;fstab&lt;/TT&gt;
             entry which names one of the possibly multiple swap partitions.
             &lt;/DL&gt;
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="char *mnt_opts">
            <synopsis>
            The element contains a string describing the options used while mounting
             the filesystem.  As for the equivalent element &lt;CODE&gt;fs_mntops&lt;/CODE&gt; of
             &lt;CODE&gt;struct fstab&lt;/CODE&gt; it is best to use the function &lt;CODE&gt;getsubopt&lt;/CODE&gt;
              to access the parts of this string.
             &lt;br&gt;&lt;br&gt; The &lt;TT&gt;mntent.h&lt;/TT&gt; file defines a number of macros with string values
             which correspond to some of the options understood by the kernel.  There
             might be many more options which are possible so it doesn't make much sense
             to rely on these macros but to be consistent here is the list:
             &lt;br&gt;&lt;br&gt; &lt;DL&gt;

            </synopsis>
        </element>
        <element content="MNTOPT_DEFAULTS">
            <synopsis>
            Expands to &lt;CODE&gt;"defaults"&lt;/CODE&gt;.  This option should be used alone since it
             indicates all values for the customizable values are chosen to be the
             default.
            </synopsis>
        </element>
        <element content="MNTOPT_RO">
            <synopsis>
            Expands to &lt;CODE&gt;"ro"&lt;/CODE&gt;.  See the &lt;CODE&gt;FSTAB_RO&lt;/CODE&gt; value, it means the
             filesystem is mounted read-only.
            </synopsis>
        </element>
        <element content="MNTOPT_RW">
            <synopsis>
            Expand to &lt;CODE&gt;"rw"&lt;/CODE&gt;.  See the &lt;CODE&gt;FSTAB_RW&lt;/CODE&gt; value, it means the
             filesystem is mounted with read and write permissions.
            </synopsis>
        </element>
        <element content="MNTOPT_SUID">
            <synopsis>
            Expands to &lt;CODE&gt;"suid"&lt;/CODE&gt;.  This means that the SUID bit  is respected when a program from the filesystem is
             started.
            </synopsis>
        </element>
        <element content="MNTOPT_NOSUID">
            <synopsis>
            Expands to &lt;CODE&gt;"nosuid"&lt;/CODE&gt;.  This is the opposite of &lt;CODE&gt;MNTOPT_SUID&lt;/CODE&gt;,
             the SUID bit for all files from the filesystem is ignored.
            </synopsis>
        </element>
        <element content="MNTOPT_NOAUTO">
            <synopsis>
            Expands to &lt;CODE&gt;"noauto"&lt;/CODE&gt;.  At startup time the &lt;CODE&gt;mount&lt;/CODE&gt; program
             will ignore this entry if it is started with the &lt;CODE&gt;-a&lt;/CODE&gt; option to
             mount all filesystems mentioned in the &lt;TT&gt;fstab&lt;/TT&gt; file.
             &lt;/DL&gt;
             &lt;br&gt;&lt;br&gt; As for the &lt;CODE&gt;FSTAB_*&lt;/CODE&gt; entries introduced above it is important to
             use &lt;CODE&gt;strcmp&lt;/CODE&gt; to check for equality.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="mnt_freq">
            <synopsis>
            This elements corresponds to &lt;CODE&gt;fs_freq&lt;/CODE&gt; and also specifies the
             frequency in days in which dumps are made.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-setmntent" type="function">
    <function returntype="FILE *">
      <prototype>
        <parameter content="const char *file"/>
        <parameter content="const char *mode"/>
      </prototype>
      <headers>
        <header filename = "mntent.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;setmntent&lt;/CODE&gt; function prepares the file named &lt;VAR&gt;FILE&lt;/VAR&gt; which
         must be in the format of a &lt;TT&gt;fstab&lt;/TT&gt; and &lt;TT&gt;mtab&lt;/TT&gt; file for the
         upcoming processing through the other functions of the family.  The
         &lt;VAR&gt;mode&lt;/VAR&gt; parameter can be chosen in the way the &lt;VAR&gt;opentype&lt;/VAR&gt;
         parameter for &lt;CODE&gt;fopen&lt;/CODE&gt;  can be chosen.  If
         the file is opened for writing the file is also allowed to be empty.
         &lt;br&gt;&lt;br&gt; If the file was successfully opened &lt;CODE&gt;setmntent&lt;/CODE&gt; returns a file
         descriptor for future use.  Otherwise the return value is &lt;CODE&gt;NULL&lt;/CODE&gt;
         and &lt;CODE&gt;errno&lt;/CODE&gt; is set accordingly.
        </synopsis>
    </function>
  </construct>
  <construct id="function-endmntent" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "mntent.h"/>
      </headers>
        <synopsis>
        This function takes for the &lt;VAR&gt;stream&lt;/VAR&gt; parameter a file handle which
         previously was returned from the &lt;CODE&gt;setmntent&lt;/CODE&gt; call.
         &lt;CODE&gt;endmntent&lt;/CODE&gt; closes the stream and frees all resources.
         &lt;br&gt;&lt;br&gt; The return value is 1 unless an error occurred in which case it
         is 0.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getmntent" type="function">
    <function returntype="struct mntent *">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "mntent.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getmntent&lt;/CODE&gt; function takes as the parameter a file handle
         previously returned by successful call to &lt;CODE&gt;setmntent&lt;/CODE&gt;.  It returns
         a pointer to a static variable of type &lt;CODE&gt;struct mntent&lt;/CODE&gt; which is
         filled with the information from the next entry from the file currently
         read.
         &lt;br&gt;&lt;br&gt; The file format used prescribes the use of spaces or tab characters to
         separate the fields.  This makes it harder to use name containing one
         of these characters (e.g., mount points using spaces).  Therefore
         these characters are encoded in the files and the &lt;CODE&gt;getmntent&lt;/CODE&gt;
         function takes care of the decoding while reading the entries back in.
         &lt;CODE&gt;'\040'&lt;/CODE&gt; is used to encode a space character, &lt;CODE&gt;'\011'&lt;/CODE&gt; to
         encode a tab character, &lt;CODE&gt;'\012'&lt;/CODE&gt; to encode a newline character,
         and &lt;CODE&gt;'\\'&lt;/CODE&gt; to encode a backslash.
         &lt;br&gt;&lt;br&gt; If there was an error or the end of the file is reached the return value
         is &lt;CODE&gt;NULL&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This function is not thread-safe since all calls to this function return
         a pointer to the same static variable.  &lt;CODE&gt;getmntent_r&lt;/CODE&gt; should be
         used in situations where multiple threads access the file.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getmntent_r" type="function">
    <function returntype="struct mntent *">
      <prototype>
        <parameter content="FILE *stream"/>
        <parameter content="struct mentent *result"/>
        <parameter content="char *buffer"/>
        <parameter content="int bufsize"/>
      </prototype>
      <headers>
        <header filename = "mntent.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getmntent_r&lt;/CODE&gt; function is the reentrant variant of
         &lt;CODE&gt;getmntent&lt;/CODE&gt;.  It also returns the next entry from the file and
         returns a pointer.  The actual variable the values are stored in is not
         static, though.  Instead the function stores the values in the variable
         pointed to by the &lt;VAR&gt;result&lt;/VAR&gt; parameter.  Additional information (e.g.,
         the strings pointed to by the elements of the result) are kept in the
         buffer of size &lt;VAR&gt;bufsize&lt;/VAR&gt; pointed to by &lt;VAR&gt;buffer&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; Escaped characters (space, tab, backslash) are converted back in the
         same way as it happens for &lt;CODE&gt;getmentent&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The function returns a &lt;CODE&gt;NULL&lt;/CODE&gt; pointer in error cases.  Errors could be:
         &lt;OL&gt;
         &lt;LI&gt;
         error while reading the file,
         &lt;LI&gt;
         end of file reached,
         &lt;LI&gt;
         &lt;VAR&gt;bufsize&lt;/VAR&gt; is too small for reading a complete new entry.
         &lt;/OL&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-addmntent" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
        <parameter content="const struct mntent *mnt"/>
      </prototype>
      <headers>
        <header filename = "mntent.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;addmntent&lt;/CODE&gt; function allows adding a new entry to the file
         previously opened with &lt;CODE&gt;setmntent&lt;/CODE&gt;.  The new entries are always
         appended.  I.e., even if the position of the file descriptor is not at
         the end of the file this function does not overwrite an existing entry
         following the current position.
         &lt;br&gt;&lt;br&gt; The implication of this is that to remove an entry from a file one has
         to create a new file while leaving out the entry to be removed and after
         closing the file remove the old one and rename the new file to the
         chosen name.
         &lt;br&gt;&lt;br&gt; This function takes care of spaces and tab characters in the names to be
         written to the file.  It converts them and the backslash character into
         the format describe in the &lt;CODE&gt;getmntent&lt;/CODE&gt; description above.
         &lt;br&gt;&lt;br&gt; This function returns 0 in case the operation was successful.
         Otherwise the return value is 1 and &lt;CODE&gt;errno&lt;/CODE&gt; is set
         appropriately.
        </synopsis>
    </function>
  </construct>
  <construct id="function-hasmntopt" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const struct mntent *mnt"/>
        <parameter content="const char *opt"/>
      </prototype>
      <headers>
        <header filename = "mntent.h"/>
      </headers>
        <synopsis>
        This function can be used to check whether the string pointed to by the
         &lt;CODE&gt;mnt_opts&lt;/CODE&gt; element of the variable pointed to by &lt;VAR&gt;mnt&lt;/VAR&gt; contains
         the option &lt;VAR&gt;opt&lt;/VAR&gt;.  If this is true a pointer to the beginning of the
         option in the &lt;CODE&gt;mnt_opts&lt;/CODE&gt; element is returned.  If no such option
         exists the function returns &lt;CODE&gt;NULL&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This function is useful to test whether a specific option is present but
         when all options have to be processed one is better off with using the
         &lt;CODE&gt;getsubopt&lt;/CODE&gt; function to iterate over all options in the string.
        </synopsis>
    </function>
  </construct>
  <construct id="function-mount" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *special_file"/>
        <parameter content="const char *dir"/>
        <parameter content="const char *fstype"/>
        <parameter content="unsigned long int options"/>
        <parameter content="const void *data"/>
      </prototype>
      <headers>
        <header filename = "sys/mount.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; &lt;CODE&gt;mount&lt;/CODE&gt; mounts or remounts a filesystem.  The two operations are
         quite different and are merged rather unnaturally into this one function.
         The &lt;CODE&gt;MS_REMOUNT&lt;/CODE&gt; option, explained below, determines whether
         &lt;CODE&gt;mount&lt;/CODE&gt; mounts or remounts.
         &lt;br&gt;&lt;br&gt; For a mount, the filesystem on the block device represented by the
         device special file named &lt;VAR&gt;special_file&lt;/VAR&gt; gets mounted over the mount
         point &lt;VAR&gt;dir&lt;/VAR&gt;.  This means that the directory &lt;VAR&gt;dir&lt;/VAR&gt; (along with any
         files in it) is no longer visible; in its place (and still with the name
         &lt;VAR&gt;dir&lt;/VAR&gt;) is the root directory of the filesystem on the device.
         &lt;br&gt;&lt;br&gt; As an exception, if the filesystem type (see below) is one which is not
         based on a device (e.g. ``proc''), &lt;CODE&gt;mount&lt;/CODE&gt; instantiates a
         filesystem and mounts it over &lt;VAR&gt;dir&lt;/VAR&gt; and ignores &lt;VAR&gt;special_file&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; For a remount, &lt;VAR&gt;dir&lt;/VAR&gt; specifies the mount point where the filesystem
         to be remounted is (and remains) mounted and &lt;VAR&gt;special_file&lt;/VAR&gt; is
         ignored.  Remounting a filesystem means changing the options that control
         operations on the filesystem while it is mounted.  It does not mean
         unmounting and mounting again.
         &lt;br&gt;&lt;br&gt; For a mount, you must identify the type of the filesystem as
         &lt;VAR&gt;fstype&lt;/VAR&gt;.  This type tells the kernel how to access the filesystem
         and can be thought of as the name of a filesystem driver.  The
         acceptable values are system dependent.  On a system with a Linux kernel
         and the &lt;CODE&gt;proc&lt;/CODE&gt; filesystem, the list of possible values is in the
         file &lt;TT&gt;filesystems&lt;/TT&gt; in the &lt;CODE&gt;proc&lt;/CODE&gt; filesystem (e.g. type
         &lt;KBD&gt;cat /proc/filesystems&lt;/KBD&gt; to see the list).  With a Linux kernel, the
         types of filesystems that &lt;CODE&gt;mount&lt;/CODE&gt; can mount, and their type names,
         depends on what filesystem drivers are configured into the kernel or
         loaded as loadable kernel modules.  An example of a common value for
         &lt;VAR&gt;fstype&lt;/VAR&gt; is &lt;CODE&gt;ext2&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; For a remount, &lt;CODE&gt;mount&lt;/CODE&gt; ignores &lt;VAR&gt;fstype&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; &lt;VAR&gt;options&lt;/VAR&gt; specifies a variety of options that apply until the
         filesystem is unmounted or remounted.  The precise meaning of an option
         depends on the filesystem and with some filesystems, an option may have
         no effect at all.  Furthermore, for some filesystems, some of these
         options (but never &lt;CODE&gt;MS_RDONLY&lt;/CODE&gt;) can be overridden for individual
         file accesses via &lt;CODE&gt;ioctl&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;VAR&gt;options&lt;/VAR&gt; is a bit string with bit fields defined using the
         following mask and masked value macros:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;MS_MGC_MASK&lt;/CODE&gt;
&lt;DD&gt;
         This multibit field contains a magic number.  If it does not have the value
         &lt;CODE&gt;MS_MGC_VAL&lt;/CODE&gt;, &lt;CODE&gt;mount&lt;/CODE&gt; assumes all the following bits are zero and
         the &lt;VAR&gt;data&lt;/VAR&gt; argument is a null string, regardless of their actual values.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;MS_REMOUNT&lt;/CODE&gt;
&lt;DD&gt;
         This bit on means to remount the filesystem.  Off means to mount it.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; MS_RDONLY
         This bit on specifies that no writing to the filesystem shall be allowed
         while it is mounted.  This cannot be overridden by &lt;CODE&gt;ioctl&lt;/CODE&gt;.  This
         option is available on nearly all filesystems.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; S_IMMUTABLE
         This bit on specifies that no writing to the files in the filesystem
         shall be allowed while it is mounted.  This can be overridden for a
         particular file access by a properly privileged call to &lt;CODE&gt;ioctl&lt;/CODE&gt;.
         This option is a relatively new invention and is not available on many
         filesystems.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; S_APPEND
         This bit on specifies that the only file writing that shall be allowed
         while the filesystem is mounted is appending.  Some filesystems allow
         this to be overridden for a particular process by a properly privileged
         call to &lt;CODE&gt;ioctl&lt;/CODE&gt;.  This is a relatively new invention and is not
         available on many filesystems.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; MS_NOSUID
         This bit on specifies that Setuid and Setgid permissions on files in the
         filesystem shall be ignored while it is mounted.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; MS_NOEXEC
         This bit on specifies that no files in the filesystem shall be executed
         while the filesystem is mounted.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; MS_NODEV
         This bit on specifies that no device special files in the filesystem
         shall be accessible while the filesystem is mounted.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; MS_SYNCHRONOUS
         This bit on specifies that all writes to the filesystem while it is
         mounted shall be synchronous; i.e., data shall be synced before each
         write completes rather than held in the buffer cache.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; MS_MANDLOCK
         This bit on specifies that mandatory locks on files shall be permitted while
         the filesystem is mounted.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; MS_NOATIME
         This bit on specifies that access times of files shall not be updated when
         the files are accessed while the filesystem is mounted.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; MS_NODIRATIME
         This bit on specifies that access times of directories shall not be updated
         when the directories are accessed while the filesystem in mounted.
         &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; Any bits not covered by the above masks should be set off; otherwise,
         results are undefined.
         &lt;br&gt;&lt;br&gt; The meaning of &lt;VAR&gt;data&lt;/VAR&gt; depends on the filesystem type and is controlled
         entirely by the filesystem driver in the kernel.
         &lt;br&gt;&lt;br&gt; Example:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         &lt;br&gt;
         #include &lt;sys/mount.h&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; mount("/dev/hdb", "/cdrom", MS_MGC_VAL | MS_RDONLY | MS_NOSUID, "");&lt;br&gt;
         &lt;br&gt;&lt;br&gt; mount("/dev/hda2", "/mnt", MS_MGC_VAL | MS_REMOUNT, "");&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; Appropriate arguments for &lt;CODE&gt;mount&lt;/CODE&gt; are conventionally recorded in
         the &lt;TT&gt;fstab&lt;/TT&gt; table.  .
         &lt;br&gt;&lt;br&gt; The return value is zero if the mount or remount is successful.  Otherwise,
         it is &lt;CODE&gt;-1&lt;/CODE&gt; and &lt;CODE&gt;errno&lt;/CODE&gt; is set appropriately.  The values of
         &lt;CODE&gt;errno&lt;/CODE&gt; are filesystem dependent, but here is a general list:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;LI&gt; EPERM
         The process is not superuser.
         &lt;LI&gt; ENODEV
         The file system type &lt;VAR&gt;fstype&lt;/VAR&gt; is not known to the kernel.
         &lt;LI&gt; ENOTBLK
         The file &lt;VAR&gt;dev&lt;/VAR&gt; is not a block device special file.
         &lt;LI&gt; EBUSY
         &lt;br&gt;&lt;br&gt; &lt;OL&gt;
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         The device is already mounted.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         The mount point is busy.  (E.g. it is some process' working directory or
         has a filesystem mounted on it already).
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         The request is to remount read-only, but there are files open for write.
         &lt;/OL&gt;
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         &lt;OL&gt;
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         A remount was attempted, but there is no filesystem mounted over the
         specified mount point.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         The supposed filesystem has an invalid superblock.
         &lt;br&gt;&lt;br&gt; &lt;/OL&gt;
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EACCES
         &lt;OL&gt;
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         The filesystem is inherently read-only (possibly due to a switch on the
         device) and the process attempted to mount it read/write (by setting the
         &lt;CODE&gt;MS_RDONLY&lt;/CODE&gt; bit off).
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         &lt;VAR&gt;special_file&lt;/VAR&gt; or &lt;VAR&gt;dir&lt;/VAR&gt; is not accessible due to file permissions.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         &lt;VAR&gt;special_file&lt;/VAR&gt; is not accessible because it is in a filesystem that is
         mounted with the &lt;CODE&gt;MS_NODEV&lt;/CODE&gt; option.
         &lt;br&gt;&lt;br&gt; &lt;/OL&gt;
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EM_FILE
         The table of dummy devices is full.  &lt;CODE&gt;mount&lt;/CODE&gt; needs to create a
         dummy device (aka ``unnamed'' device) if the filesystem being mounted is
         not one that uses a device.
         &lt;br&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-umount2" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *file"/>
        <parameter content="int flags"/>
      </prototype>
      <headers>
        <header filename = "sys/mount.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; &lt;CODE&gt;umount2&lt;/CODE&gt; unmounts a filesystem.
         &lt;br&gt;&lt;br&gt; You can identify the filesystem to unmount either by the device special
         file that contains the filesystem or by the mount point.  The effect is
         the same.  Specify either as the string &lt;VAR&gt;file&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; &lt;VAR&gt;flags&lt;/VAR&gt; contains the one-bit field identified by the following
         mask macro:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;MNT_FORCE&lt;/CODE&gt;
&lt;DD&gt;
         This bit on means to force the unmounting even if the filesystem is
         busy, by making it unbusy first.  If the bit is off and the filesystem is
         busy, &lt;CODE&gt;umount2&lt;/CODE&gt; fails with &lt;CODE&gt;errno&lt;/CODE&gt; = &lt;CODE&gt;EBUSY&lt;/CODE&gt;.  Depending
         on the filesystem, this may override all, some, or no busy conditions.
         &lt;br&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; All other bits in &lt;VAR&gt;flags&lt;/VAR&gt; should be set to zero; otherwise, the result
         is undefined.
         &lt;br&gt;&lt;br&gt; Example:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         &lt;br&gt;
         #include &lt;sys/mount.h&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; umount2("/mnt", MNT_FORCE);&lt;br&gt;
         &lt;br&gt;&lt;br&gt; umount2("/dev/hdd1", 0);&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; After the filesystem is unmounted, the directory that was the mount point
         is visible, as are any files in it.
         &lt;br&gt;&lt;br&gt; As part of unmounting, &lt;CODE&gt;umount2&lt;/CODE&gt; syncs the filesystem.
         &lt;br&gt;&lt;br&gt; If the unmounting is successful, the return value is zero.  Otherwise, it
         is &lt;CODE&gt;-1&lt;/CODE&gt; and &lt;CODE&gt;errno&lt;/CODE&gt; is set accordingly:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;LI&gt; EPERM
         The process is not superuser.
         &lt;LI&gt; EBUSY
         The filesystem cannot be unmounted because it is busy.  E.g. it contains
         a directory that is some process's working directory or a file that some
         process has open.  With some filesystems in some cases, you can avoid
         this failure with the &lt;CODE&gt;MNT_FORCE&lt;/CODE&gt; option.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         &lt;VAR&gt;file&lt;/VAR&gt; validly refers to a file, but that file is neither a mount
         point nor a device special file of a currently mounted filesystem.
         &lt;br&gt;&lt;br&gt;
&lt;/DL&gt;
         &lt;br&gt;&lt;br&gt; This function is not available on all systems.
        </synopsis>
    </function>
  </construct>
  <construct id="function-umount" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *file"/>
      </prototype>
      <headers>
        <header filename = "sys/mount.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; &lt;CODE&gt;umount&lt;/CODE&gt; does the same thing as &lt;CODE&gt;umount2&lt;/CODE&gt; with &lt;VAR&gt;flags&lt;/VAR&gt; set
         to zeroes.  It is more widely available than &lt;CODE&gt;umount2&lt;/CODE&gt; but since it
         lacks the possibility to forcefully unmount a filesystem is deprecated
         when &lt;CODE&gt;umount2&lt;/CODE&gt; is also available.
        </synopsis>
    </function>
  </construct>
  <construct id="function-sysctl" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int *names"/>
        <parameter content="int nlen"/>
        <parameter content="void *oldval"/>
        <parameter content="size_t *oldlenp"/>
        <parameter content="void *newval"/>
        <parameter content="size_t newlen"/>
      </prototype>
      <headers>
        <header filename = "sysctl.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; &lt;CODE&gt;sysctl&lt;/CODE&gt; gets or sets a specified system parameter.  There are so
         many of these parameters that it is not practical to list them all here,
         but here are some examples:
         &lt;br&gt;&lt;br&gt; &lt;OL&gt;
         &lt;LI&gt; network domain name
         &lt;LI&gt; paging parameters
         &lt;LI&gt; network Address Resolution Protocol timeout time
         &lt;LI&gt; maximum number of files that may be open
         &lt;LI&gt; root filesystem device
         &lt;LI&gt; when kernel was built
         &lt;/OL&gt;
         &lt;br&gt;&lt;br&gt; The set of available parameters depends on the kernel configuration and
         can change while the system is running, particularly when you load and
         unload loadable kernel modules.
         &lt;br&gt;&lt;br&gt; The system parameters with which &lt;CODE&gt;syslog&lt;/CODE&gt; is concerned are arranged
         in a hierarchical structure like a hierarchical filesystem.  To identify
         a particular parameter, you specify a path through the structure in a
         way analogous to specifying the pathname of a file.  Each component of
         the path is specified by an integer and each of these integers has a
         macro defined for it by &lt;TT&gt;sysctl.h&lt;/TT&gt;.  &lt;VAR&gt;names&lt;/VAR&gt; is the path, in
         the form of an array of integers.  Each component of the path is one
         element of the array, in order.  &lt;VAR&gt;nlen&lt;/VAR&gt; is the number of components
         in the path.
         &lt;br&gt;&lt;br&gt; For example, the first component of the path for all the paging
         parameters is the value &lt;CODE&gt;CTL_VM&lt;/CODE&gt;.  For the free page thresholds, the
         second component of the path is &lt;CODE&gt;VM_FREEPG&lt;/CODE&gt;.  So to get the free
         page threshold values, make &lt;VAR&gt;names&lt;/VAR&gt; an array containing the two
         elements &lt;CODE&gt;CTL_VM&lt;/CODE&gt; and &lt;CODE&gt;VM_FREEPG&lt;/CODE&gt; and make &lt;VAR&gt;nlen&lt;/VAR&gt; = 2.
         &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt; The format of the value of a parameter depends on the parameter.
         Sometimes it is an integer; sometimes it is an ASCII string; sometimes
         it is an elaborate structure.  In the case of the free page thresholds
         used in the example above, the parameter value is a structure containing
         several integers.
         &lt;br&gt;&lt;br&gt; In any case, you identify a place to return the parameter's value with
         &lt;VAR&gt;oldval&lt;/VAR&gt; and specify the amount of storage available at that
         location as *&lt;VAR&gt;oldlenp&lt;/VAR&gt;.  *&lt;VAR&gt;oldlenp&lt;/VAR&gt; does double duty because it
         is also the output location that contains the actual length of the
         returned value.
         &lt;br&gt;&lt;br&gt; If you don't want the parameter value returned, specify a null pointer
         for &lt;VAR&gt;oldval&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; To set the parameter, specify the address and length of the new value
         as &lt;VAR&gt;newval&lt;/VAR&gt; and &lt;VAR&gt;newlen&lt;/VAR&gt;.  If you don't want to set the parameter,
         specify a null pointer as &lt;VAR&gt;newval&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If you get and set a parameter in the same &lt;CODE&gt;sysctl&lt;/CODE&gt; call, the value
         returned is the value of the parameter before it was set.
         &lt;br&gt;&lt;br&gt; Each system parameter has a set of permissions similar to the
         permissions for a file (including the permissions on directories in its
         path) that determine whether you may get or set it.  For the purposes of
         these permissions, every parameter is considered to be owned by the
         superuser and Group 0 so processes with that effective uid or gid may
         have more access to system parameters.  Unlike with files, the superuser
         does not invariably have full permission to all system parameters, because
         some of them are designed not to be changed ever.
         &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt; &lt;CODE&gt;sysctl&lt;/CODE&gt; returns a zero return value if it succeeds.  Otherwise, it
         returns &lt;CODE&gt;-1&lt;/CODE&gt; and sets &lt;CODE&gt;errno&lt;/CODE&gt; appropriately.  Besides the
         failures that apply to all system calls, the following are the
         &lt;CODE&gt;errno&lt;/CODE&gt; codes for all possible failures:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EPERM&lt;/CODE&gt;
&lt;DD&gt;
         The process is not permitted to access one of the components of the
         path of the system parameter or is not permitted to access the system parameter
         itself in the way (read or write) that it requested.
         &lt;LI&gt; ENOTDIR
         There is no system parameter corresponding to &lt;VAR&gt;name&lt;/VAR&gt;.
         &lt;LI&gt; EFAULT
         &lt;VAR&gt;oldval&lt;/VAR&gt; is not null, which means the process wanted to read the parameter,
         but *&lt;VAR&gt;oldlenp&lt;/VAR&gt; is zero, so there is no place to return it.
         &lt;LI&gt; EINVAL
         &lt;OL&gt;
         &lt;LI&gt;
         The process attempted to set a system parameter to a value that is not valid
         for that parameter.
         &lt;LI&gt;
         The space provided for the return of the system parameter is not the right
         size for that parameter.
         &lt;/OL&gt;
         &lt;LI&gt; ENOMEM
         This value may be returned instead of the more correct &lt;CODE&gt;EINVAL&lt;/CODE&gt; in some
         cases where the space provided for the return of the system parameter is too
         small.
         &lt;br&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-uid_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="dtype-gid_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="function-getuid" type="function">
    <function returntype="uid_t">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "sys/types.h"/>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getuid&lt;/CODE&gt; function returns the real user ID of the process.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getgid" type="function">
    <function returntype="gid_t">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getgid&lt;/CODE&gt; function returns the real group ID of the process.
        </synopsis>
    </function>
  </construct>
  <construct id="function-geteuid" type="function">
    <function returntype="uid_t">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;geteuid&lt;/CODE&gt; function returns the effective user ID of the process.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getegid" type="function">
    <function returntype="gid_t">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getegid&lt;/CODE&gt; function returns the effective group ID of the process.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getgroups" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int count"/>
        <parameter content="gid_t *groups"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getgroups&lt;/CODE&gt; function is used to inquire about the supplementary
         group IDs of the process.  Up to &lt;VAR&gt;count&lt;/VAR&gt; of these group IDs are
         stored in the array &lt;VAR&gt;groups&lt;/VAR&gt;; the return value from the function is
         the number of group IDs actually stored.  If &lt;VAR&gt;count&lt;/VAR&gt; is smaller than
         the total number of supplementary group IDs, then &lt;CODE&gt;getgroups&lt;/CODE&gt;
         returns a value of &lt;CODE&gt;-1&lt;/CODE&gt; and &lt;CODE&gt;errno&lt;/CODE&gt; is set to &lt;CODE&gt;EINVAL&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;count&lt;/VAR&gt; is zero, then &lt;CODE&gt;getgroups&lt;/CODE&gt; just returns the total
         number of supplementary group IDs.  On systems that do not support
         supplementary groups, this will always be zero.
         &lt;br&gt;&lt;br&gt; Here's how to use &lt;CODE&gt;getgroups&lt;/CODE&gt; to read all the supplementary group
         IDs:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         &lt;br&gt;
         gid_t *&lt;br&gt;
         read_all_groups (void)&lt;br&gt;
         {&lt;br&gt;
           int ngroups = getgroups (0, NULL);&lt;br&gt;
           gid_t *groups&lt;br&gt;
             = (gid_t *) xmalloc (ngroups * sizeof (gid_t));&lt;br&gt;
           int val = getgroups (ngroups, groups);&lt;br&gt;
           if (val &lt; 0)&lt;br&gt;
             {&lt;br&gt;
               free (groups);&lt;br&gt;
               return NULL;&lt;br&gt;
             }&lt;br&gt;
           return groups;&lt;br&gt;
         }&lt;br&gt;
         &lt;br&gt;
         &lt;/pre&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-seteuid" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="uid_t neweuid"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        This function sets the effective user ID of a process to &lt;VAR&gt;newuid&lt;/VAR&gt;,
         provided that the process is allowed to change its effective user ID.  A
         privileged process (effective user ID zero) can change its effective
         user ID to any legal value.  An unprivileged process with a file user ID
         can change its effective user ID to its real user ID or to its file user
         ID.  Otherwise, a process may not change its effective user ID at all.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;seteuid&lt;/CODE&gt; function returns a value of &lt;CODE&gt;0&lt;/CODE&gt; to indicate
         successful completion, and a value of &lt;CODE&gt;-1&lt;/CODE&gt; to indicate an error.
         The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this
         function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EINVAL&lt;/CODE&gt;
&lt;DD&gt;
         The value of the &lt;VAR&gt;newuid&lt;/VAR&gt; argument is invalid.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EPERM
         The process may not change to the specified ID.

         &lt;br&gt;&lt;br&gt; Older systems (those without the &lt;CODE&gt;_POSIX_SAVED_IDS&lt;/CODE&gt; feature) do not
         have this function.
        </synopsis>
    </function>
  </construct>
  <construct id="function-setuid" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="uid_t newuid"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        If the calling process is privileged, this function sets both the real
         and effective user ID of the process to &lt;VAR&gt;newuid&lt;/VAR&gt;.  It also deletes
         the file user ID of the process, if any.  &lt;VAR&gt;newuid&lt;/VAR&gt; may be any
         legal value.  (Once this has been done, there is no way to recover the
         old effective user ID.)
         &lt;br&gt;&lt;br&gt; If the process is not privileged, and the system supports the
         &lt;CODE&gt;_POSIX_SAVED_IDS&lt;/CODE&gt; feature, then this function behaves like
         &lt;CODE&gt;seteuid&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The return values and error conditions are the same as for &lt;CODE&gt;seteuid&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-setreuid" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="uid_t ruid"/>
        <parameter content="uid_t euid"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        This function sets the real user ID of the process to &lt;VAR&gt;ruid&lt;/VAR&gt; and the
         effective user ID to &lt;VAR&gt;euid&lt;/VAR&gt;.  If &lt;VAR&gt;ruid&lt;/VAR&gt; is &lt;CODE&gt;-1&lt;/CODE&gt;, it means
         not to change the real user ID; likewise if &lt;VAR&gt;euid&lt;/VAR&gt; is &lt;CODE&gt;-1&lt;/CODE&gt;, it
         means not to change the effective user ID.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;setreuid&lt;/CODE&gt; function exists for compatibility with 4.3 BSD Unix,
         which does not support file IDs.  You can use this function to swap the
         effective and real user IDs of the process.  (Privileged processes are
         not limited to this particular usage.)  If file IDs are supported, you
         should use that feature instead of this function.  .
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; on success and &lt;CODE&gt;-1&lt;/CODE&gt; on failure.
         The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this
         function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EPERM&lt;/CODE&gt;
&lt;DD&gt;
         The process does not have the appropriate privileges; you do not
         have permission to change to the specified ID.

        </synopsis>
    </function>
  </construct>
  <construct id="function-setegid" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="gid_t newgid"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        This function sets the effective group ID of the process to
         &lt;VAR&gt;newgid&lt;/VAR&gt;, provided that the process is allowed to change its group
         ID.  Just as with &lt;CODE&gt;seteuid&lt;/CODE&gt;, if the process is privileged it may
         change its effective group ID to any value; if it isn't, but it has a
         file group ID, then it may change to its real group ID or file group ID;
         otherwise it may not change its effective group ID.
         &lt;br&gt;&lt;br&gt; Note that a process is only privileged if its effective &lt;EM&gt;user&lt;/EM&gt; ID
         is zero.  The effective group ID only affects access permissions.
         &lt;br&gt;&lt;br&gt; The return values and error conditions for &lt;CODE&gt;setegid&lt;/CODE&gt; are the same
         as those for &lt;CODE&gt;seteuid&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This function is only present if &lt;CODE&gt;_POSIX_SAVED_IDS&lt;/CODE&gt; is defined.
        </synopsis>
    </function>
  </construct>
  <construct id="function-setgid" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="gid_t newgid"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        This function sets both the real and effective group ID of the process
         to &lt;VAR&gt;newgid&lt;/VAR&gt;, provided that the process is privileged.  It also
         deletes the file group ID, if any.
         &lt;br&gt;&lt;br&gt; If the process is not privileged, then &lt;CODE&gt;setgid&lt;/CODE&gt; behaves like
         &lt;CODE&gt;setegid&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The return values and error conditions for &lt;CODE&gt;setgid&lt;/CODE&gt; are the same
         as those for &lt;CODE&gt;seteuid&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-setregid" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="gid_t rgid"/>
        <parameter content="gid_t egid"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        This function sets the real group ID of the process to &lt;VAR&gt;rgid&lt;/VAR&gt; and
         the effective group ID to &lt;VAR&gt;egid&lt;/VAR&gt;.  If &lt;VAR&gt;rgid&lt;/VAR&gt; is &lt;CODE&gt;-1&lt;/CODE&gt;, it
         means not to change the real group ID; likewise if &lt;VAR&gt;egid&lt;/VAR&gt; is
         &lt;CODE&gt;-1&lt;/CODE&gt;, it means not to change the effective group ID.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;setregid&lt;/CODE&gt; function is provided for compatibility with 4.3 BSD
         Unix, which does not support file IDs.  You can use this function to
         swap the effective and real group IDs of the process.  (Privileged
         processes are not limited to this usage.)  If file IDs are supported,
         you should use that feature instead of using this function.
         .
         &lt;br&gt;&lt;br&gt; The return values and error conditions for &lt;CODE&gt;setregid&lt;/CODE&gt; are the same
         as those for &lt;CODE&gt;setreuid&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-setgroups" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="size_t count"/>
        <parameter content="gid_t *groups"/>
      </prototype>
      <headers>
        <header filename = "grp.h"/>
      </headers>
        <synopsis>
        This function sets the process's supplementary group IDs.  It can only
         be called from privileged processes.  The &lt;VAR&gt;count&lt;/VAR&gt; argument specifies
         the number of group IDs in the array &lt;VAR&gt;groups&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; This function returns &lt;CODE&gt;0&lt;/CODE&gt; if successful and &lt;CODE&gt;-1&lt;/CODE&gt; on error.
         The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this
         function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EPERM&lt;/CODE&gt;
&lt;DD&gt;
         The calling process is not privileged.

        </synopsis>
    </function>
  </construct>
  <construct id="function-initgroups" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *user"/>
        <parameter content="gid_t group"/>
      </prototype>
      <headers>
        <header filename = "grp.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;initgroups&lt;/CODE&gt; function sets the process's supplementary group
         IDs to be the normal default for the user name &lt;VAR&gt;user&lt;/VAR&gt;.  The group
         &lt;VAR&gt;group&lt;/VAR&gt; is automatically included.
         &lt;br&gt;&lt;br&gt; This function works by scanning the group database for all the groups
         &lt;VAR&gt;user&lt;/VAR&gt; belongs to.  It then calls &lt;CODE&gt;setgroups&lt;/CODE&gt; with the list it
         has constructed.
         &lt;br&gt;&lt;br&gt; The return values and error conditions are the same as for
         &lt;CODE&gt;setgroups&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getgrouplist" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *user"/>
        <parameter content="gid_t group"/>
        <parameter content="gid_t *groups"/>
        <parameter content="int *ngroups"/>
      </prototype>
      <headers>
        <header filename = "grp.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getgrouplist&lt;/CODE&gt; function scans the group database for all the
         groups &lt;VAR&gt;user&lt;/VAR&gt; belongs to.  Up to *&lt;VAR&gt;ngroups&lt;/VAR&gt; group IDs
         corresponding to these groups are stored in the array &lt;VAR&gt;groups&lt;/VAR&gt;; the
         return value from the function is the number of group IDs actually
         stored.  If *&lt;VAR&gt;ngroups&lt;/VAR&gt; is smaller than the total number of groups
         found, then &lt;CODE&gt;getgrouplist&lt;/CODE&gt; returns a value of &lt;CODE&gt;-1&lt;/CODE&gt; and stores
         the actual number of groups in *&lt;VAR&gt;ngroups&lt;/VAR&gt;.  The group &lt;VAR&gt;group&lt;/VAR&gt; is
         automatically included in the list of groups returned by
         &lt;CODE&gt;getgrouplist&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; Here's how to use &lt;CODE&gt;getgrouplist&lt;/CODE&gt; to read all supplementary groups
         for &lt;VAR&gt;user&lt;/VAR&gt;:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         &lt;br&gt;
         gid_t *&lt;br&gt;
         supplementary_groups (char *user)&lt;br&gt;
         {&lt;br&gt;
           int ngroups = 16;&lt;br&gt;
           gid_t *groups&lt;br&gt;
             = (gid_t *) xmalloc (ngroups * sizeof (gid_t));&lt;br&gt;
           struct passwd *pw = getpwnam (user);&lt;br&gt;
         &lt;br&gt;&lt;br&gt;   if (pw == NULL)&lt;br&gt;
             return NULL;&lt;br&gt;
         &lt;br&gt;&lt;br&gt;   if (getgrouplist (pw-&gt;pw_name, pw-&gt;pw_gid, groups, &amp;ngroups) &lt; 0)&lt;br&gt;
             {&lt;br&gt;
               groups = xrealloc (ngroups * sizeof (gid_t));&lt;br&gt;
               getgrouplist (pw-&gt;pw_name, pw-&gt;pw_gid, groups, &amp;ngroups);&lt;br&gt;
             }&lt;br&gt;
           return groups;&lt;br&gt;
         }&lt;br&gt;
         &lt;br&gt;
         &lt;/pre&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-getlogin" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getlogin&lt;/CODE&gt; function returns a pointer to a string containing the
         name of the user logged in on the controlling terminal of the process,
         or a null pointer if this information cannot be determined.  The string
         is statically allocated and might be overwritten on subsequent calls to
         this function or to &lt;CODE&gt;cuserid&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cuserid" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="char *string"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;cuserid&lt;/CODE&gt; function returns a pointer to a string containing a
         user name associated with the effective ID of the process.  If
         &lt;VAR&gt;string&lt;/VAR&gt; is not a null pointer, it should be an array that can hold
         at least &lt;CODE&gt;L_cuserid&lt;/CODE&gt; characters; the string is returned in this
         array.  Otherwise, a pointer to a string in a static area is returned.
         This string is statically allocated and might be overwritten on
         subsequent calls to this function or to &lt;CODE&gt;getlogin&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The use of this function is deprecated since it is marked to be
         withdrawn in XPG4.2 and has already been removed from newer revisions of
         POSIX.1.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-exit_status" type="struct">
    <structure>
        <synopsis>
        The &lt;CODE&gt;exit_status&lt;/CODE&gt; data structure is used to hold information about
         the exit status of processes marked as &lt;CODE&gt;DEAD_PROCESS&lt;/CODE&gt; in the user
         accounting database.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="short int e_termination">
            <synopsis>
            The exit status of the process.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="struct-utmp" type="struct">
    <structure>
        <synopsis>
        The &lt;CODE&gt;utmp&lt;/CODE&gt; data structure is used to hold information about entries
         in the user accounting database.  On the GNU system it has the following
         members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="short int ut_type">
            <synopsis>
            Specifies the type of login; one of &lt;CODE&gt;EMPTY&lt;/CODE&gt;, &lt;CODE&gt;RUN_LVL&lt;/CODE&gt;,
             &lt;CODE&gt;BOOT_TIME&lt;/CODE&gt;, &lt;CODE&gt;OLD_TIME&lt;/CODE&gt;, &lt;CODE&gt;NEW_TIME&lt;/CODE&gt;, &lt;CODE&gt;INIT_PROCESS&lt;/CODE&gt;,
             &lt;CODE&gt;LOGIN_PROCESS&lt;/CODE&gt;, &lt;CODE&gt;USER_PROCESS&lt;/CODE&gt;, &lt;CODE&gt;DEAD_PROCESS&lt;/CODE&gt; or
             &lt;CODE&gt;ACCOUNTING&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="pid_t ut_pid">
            <synopsis>
            The process ID number of the login process.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="char ut_line[]">
            <synopsis>
            The device name of the tty (without &lt;TT&gt;/dev/&lt;/TT&gt;).
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="char ut_id[]">
            <synopsis>
            The inittab ID of the process.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="char ut_user[]">
            <synopsis>
            The user's login name.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="char ut_host[]">
            <synopsis>
            The name of the host from which the user logged in.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="struct exit_status ut_exit">
            <synopsis>
            The exit status of a process marked as &lt;CODE&gt;DEAD_PROCESS&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long ut_session">
            <synopsis>
            The Session ID, used for windowing.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="struct timeval ut_tv">
            <synopsis>
            Time the entry was made.  For entries of type &lt;CODE&gt;OLD_TIME&lt;/CODE&gt; this is
             the time when the system clock changed, and for entries of type
             &lt;CODE&gt;NEW_TIME&lt;/CODE&gt; this is the time the system clock was set to.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-setutent" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
        <header filename = "utmp.h"/>
      </headers>
        <synopsis>
        This function opens the user accounting database to begin scanning it.
         You can then call &lt;CODE&gt;getutent&lt;/CODE&gt;, &lt;CODE&gt;getutid&lt;/CODE&gt; or &lt;CODE&gt;getutline&lt;/CODE&gt; to
         read entries and &lt;CODE&gt;pututline&lt;/CODE&gt; to write entries.
         &lt;br&gt;&lt;br&gt; If the database is already open, it resets the input to the beginning of
         the database.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getutent" type="function">
    <function returntype="struct utmp *">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "utmp.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getutent&lt;/CODE&gt; function reads the next entry from the user
         accounting database.  It returns a pointer to the entry, which is
         statically allocated and may be overwritten by subsequent calls to
         &lt;CODE&gt;getutent&lt;/CODE&gt;.  You must copy the contents of the structure if you
         wish to save the information or you can use the &lt;CODE&gt;getutent_r&lt;/CODE&gt;
         function which stores the data in a user-provided buffer.
         &lt;br&gt;&lt;br&gt; A null pointer is returned in case no further entry is available.
        </synopsis>
    </function>
  </construct>
  <construct id="function-endutent" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "utmp.h"/>
      </headers>
        <synopsis>
        This function closes the user accounting database.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getutid" type="function">
    <function returntype="struct utmp *">
      <prototype>
        <parameter content="const struct utmp *id"/>
      </prototype>
      <headers>
        <header filename = "utmp.h"/>
      </headers>
        <synopsis>
        This function searches forward from the current point in the database
         for an entry that matches &lt;VAR&gt;id&lt;/VAR&gt;.  If the &lt;CODE&gt;ut_type&lt;/CODE&gt; member of the
         &lt;VAR&gt;id&lt;/VAR&gt; structure is one of &lt;CODE&gt;RUN_LVL&lt;/CODE&gt;, &lt;CODE&gt;BOOT_TIME&lt;/CODE&gt;,
         &lt;CODE&gt;OLD_TIME&lt;/CODE&gt; or &lt;CODE&gt;NEW_TIME&lt;/CODE&gt; the entries match if the
         &lt;CODE&gt;ut_type&lt;/CODE&gt; members are identical.  If the &lt;CODE&gt;ut_type&lt;/CODE&gt; member of
         the &lt;VAR&gt;id&lt;/VAR&gt; structure is &lt;CODE&gt;INIT_PROCESS&lt;/CODE&gt;, &lt;CODE&gt;LOGIN_PROCESS&lt;/CODE&gt;,
         &lt;CODE&gt;USER_PROCESS&lt;/CODE&gt; or &lt;CODE&gt;DEAD_PROCESS&lt;/CODE&gt;, the entries match if the
         &lt;CODE&gt;ut_type&lt;/CODE&gt; member of the entry read from the database is one of
         these four, and the &lt;CODE&gt;ut_id&lt;/CODE&gt; members match.  However if the
         &lt;CODE&gt;ut_id&lt;/CODE&gt; member of either the &lt;VAR&gt;id&lt;/VAR&gt; structure or the entry read
         from the database is empty it checks if the &lt;CODE&gt;ut_line&lt;/CODE&gt; members match
         instead.  If a matching entry is found, &lt;CODE&gt;getutid&lt;/CODE&gt; returns a pointer
         to the entry, which is statically allocated, and may be overwritten by a
         subsequent call to &lt;CODE&gt;getutent&lt;/CODE&gt;, &lt;CODE&gt;getutid&lt;/CODE&gt; or &lt;CODE&gt;getutline&lt;/CODE&gt;.
         You must copy the contents of the structure if you wish to save the
         information.
         &lt;br&gt;&lt;br&gt; A null pointer is returned in case the end of the database is reached
         without a match.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;getutid&lt;/CODE&gt; function may cache the last read entry.  Therefore,
         if you are using &lt;CODE&gt;getutid&lt;/CODE&gt; to search for multiple occurrences, it
         is necessary to zero out the static data after each call.  Otherwise
         &lt;CODE&gt;getutid&lt;/CODE&gt; could just return a pointer to the same entry over and
         over again.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getutline" type="function">
    <function returntype="struct utmp *">
      <prototype>
        <parameter content="const struct utmp *line"/>
      </prototype>
      <headers>
        <header filename = "utmp.h"/>
      </headers>
        <synopsis>
        This function searches forward from the current point in the database
         until it finds an entry whose &lt;CODE&gt;ut_type&lt;/CODE&gt; value is
         &lt;CODE&gt;LOGIN_PROCESS&lt;/CODE&gt; or &lt;CODE&gt;USER_PROCESS&lt;/CODE&gt;, and whose &lt;CODE&gt;ut_line&lt;/CODE&gt;
         member matches the &lt;CODE&gt;ut_line&lt;/CODE&gt; member of the &lt;VAR&gt;line&lt;/VAR&gt; structure.
         If it finds such an entry, it returns a pointer to the entry which is
         statically allocated, and may be overwritten by a subsequent call to
         &lt;CODE&gt;getutent&lt;/CODE&gt;, &lt;CODE&gt;getutid&lt;/CODE&gt; or &lt;CODE&gt;getutline&lt;/CODE&gt;.  You must copy the
         contents of the structure if you wish to save the information.
         &lt;br&gt;&lt;br&gt; A null pointer is returned in case the end of the database is reached
         without a match.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;getutline&lt;/CODE&gt; function may cache the last read entry.  Therefore
         if you are using &lt;CODE&gt;getutline&lt;/CODE&gt; to search for multiple occurrences, it
         is necessary to zero out the static data after each call.  Otherwise
         &lt;CODE&gt;getutline&lt;/CODE&gt; could just return a pointer to the same entry over and
         over again.
        </synopsis>
    </function>
  </construct>
  <construct id="function-pututline" type="function">
    <function returntype="struct utmp *">
      <prototype>
        <parameter content="const struct utmp *utmp"/>
      </prototype>
      <headers>
        <header filename = "utmp.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;pututline&lt;/CODE&gt; function inserts the entry &lt;CODE&gt;*&lt;VAR&gt;utmp&lt;/VAR&gt;&lt;/CODE&gt; at
         the appropriate place in the user accounting database.  If it finds that
         it is not already at the correct place in the database, it uses
         &lt;CODE&gt;getutid&lt;/CODE&gt; to search for the position to insert the entry, however
         this will not modify the static structure returned by &lt;CODE&gt;getutent&lt;/CODE&gt;,
         &lt;CODE&gt;getutid&lt;/CODE&gt; and &lt;CODE&gt;getutline&lt;/CODE&gt;.  If this search fails, the entry
         is appended to the database.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;pututline&lt;/CODE&gt; function returns a pointer to a copy of the entry
         inserted in the user accounting database, or a null pointer if the entry
         could not be added.  The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are
         defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EPERM&lt;/CODE&gt;
&lt;DD&gt;
         The process does not have the appropriate privileges; you cannot modify
         the user accounting database.

        </synopsis>
    </function>
  </construct>
  <construct id="function-getutent_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="struct utmp *buffer"/>
        <parameter content="struct utmp **result"/>
      </prototype>
      <headers>
        <header filename = "utmp.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getutent_r&lt;/CODE&gt; is equivalent to the &lt;CODE&gt;getutent&lt;/CODE&gt; function.  It
         returns the next entry from the database.  But instead of storing the
         information in a static buffer it stores it in the buffer pointed to by
         the parameter &lt;VAR&gt;buffer&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If the call was successful, the function returns &lt;CODE&gt;0&lt;/CODE&gt; and the
         pointer variable pointed to by the parameter &lt;VAR&gt;result&lt;/VAR&gt; contains a
         pointer to the buffer which contains the result (this is most probably
         the same value as &lt;VAR&gt;buffer&lt;/VAR&gt;).  If something went wrong during the
         execution of &lt;CODE&gt;getutent_r&lt;/CODE&gt; the function returns &lt;CODE&gt;-1&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getutid_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const struct utmp *id"/>
        <parameter content="struct utmp *buffer"/>
        <parameter content="struct utmp **result"/>
      </prototype>
      <headers>
        <header filename = "utmp.h"/>
      </headers>
        <synopsis>
        This function retrieves just like &lt;CODE&gt;getutid&lt;/CODE&gt; the next entry matching
         the information stored in &lt;VAR&gt;id&lt;/VAR&gt;.  But the result is stored in the
         buffer pointed to by the parameter &lt;VAR&gt;buffer&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If successful the function returns &lt;CODE&gt;0&lt;/CODE&gt; and the pointer variable
         pointed to by the parameter &lt;VAR&gt;result&lt;/VAR&gt; contains a pointer to the
         buffer with the result (probably the same as &lt;VAR&gt;result&lt;/VAR&gt;.  If not
         successful the function return &lt;CODE&gt;-1&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getutline_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const struct utmp *line"/>
        <parameter content="struct utmp *buffer"/>
        <parameter content="struct utmp **result"/>
      </prototype>
      <headers>
        <header filename = "utmp.h"/>
      </headers>
        <synopsis>
        This function retrieves just like &lt;CODE&gt;getutline&lt;/CODE&gt; the next entry
         matching the information stored in &lt;VAR&gt;line&lt;/VAR&gt;.  But the result is stored
         in the buffer pointed to by the parameter &lt;VAR&gt;buffer&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If successful the function returns &lt;CODE&gt;0&lt;/CODE&gt; and the pointer variable
         pointed to by the parameter &lt;VAR&gt;result&lt;/VAR&gt; contains a pointer to the
         buffer with the result (probably the same as &lt;VAR&gt;result&lt;/VAR&gt;.  If not
         successful the function return &lt;CODE&gt;-1&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-utmpname" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *file"/>
      </prototype>
      <headers>
        <header filename = "utmp.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;utmpname&lt;/CODE&gt; function changes the name of the database to be
         examined to &lt;VAR&gt;file&lt;/VAR&gt;, and closes any previously opened database.  By
         default &lt;CODE&gt;getutent&lt;/CODE&gt;, &lt;CODE&gt;getutid&lt;/CODE&gt;, &lt;CODE&gt;getutline&lt;/CODE&gt; and
         &lt;CODE&gt;pututline&lt;/CODE&gt; read from and write to the user accounting database.
         &lt;br&gt;&lt;br&gt; The following macros are defined for use as the &lt;VAR&gt;file&lt;/VAR&gt; argument:
         &lt;br&gt;&lt;br&gt; Macro {char *} _PATH_UTMP
         This macro is used to specify the user accounting database.

         &lt;br&gt;&lt;br&gt; Macro {char *} _PATH_WTMP
         This macro is used to specify the user accounting log file.

         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;utmpname&lt;/CODE&gt; function returns a value of &lt;CODE&gt;0&lt;/CODE&gt; if the new name
         was successfully stored, and a value of &lt;CODE&gt;-1&lt;/CODE&gt; to indicate an error.
         Note that &lt;CODE&gt;utmpname&lt;/CODE&gt; does not try to open the database, and that
         therefore the return value does not say anything about whether the
         database can be successfully opened.
        </synopsis>
    </function>
  </construct>
  <construct id="function-updwtmp" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="const char *wtmp_file"/>
        <parameter content="const struct utmp *utmp"/>
      </prototype>
      <headers>
        <header filename = "utmp.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;updwtmp&lt;/CODE&gt; function appends the entry *&lt;VAR&gt;utmp&lt;/VAR&gt; to the
         database specified by &lt;VAR&gt;wtmp_file&lt;/VAR&gt;.  For possible values for the
         &lt;VAR&gt;wtmp_file&lt;/VAR&gt; argument see the &lt;CODE&gt;utmpname&lt;/CODE&gt; function.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-utmpx" type="struct">
    <structure>
        <synopsis>
        The &lt;CODE&gt;utmpx&lt;/CODE&gt; data structure contains at least the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="short int ut_type">
            <synopsis>
            Specifies the type of login; one of &lt;CODE&gt;EMPTY&lt;/CODE&gt;, &lt;CODE&gt;RUN_LVL&lt;/CODE&gt;,
             &lt;CODE&gt;BOOT_TIME&lt;/CODE&gt;, &lt;CODE&gt;OLD_TIME&lt;/CODE&gt;, &lt;CODE&gt;NEW_TIME&lt;/CODE&gt;, &lt;CODE&gt;INIT_PROCESS&lt;/CODE&gt;,
             &lt;CODE&gt;LOGIN_PROCESS&lt;/CODE&gt;, &lt;CODE&gt;USER_PROCESS&lt;/CODE&gt; or &lt;CODE&gt;DEAD_PROCESS&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="pid_t ut_pid">
            <synopsis>
            The process ID number of the login process.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="char ut_line[]">
            <synopsis>
            The device name of the tty (without &lt;TT&gt;/dev/&lt;/TT&gt;).
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="char ut_id[]">
            <synopsis>
            The inittab ID of the process.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="char ut_user[]">
            <synopsis>
            The user's login name.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-setutxent" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "utmpx.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;setutent&lt;/CODE&gt;.  On the GNU system it is
         simply an alias for &lt;CODE&gt;setutent&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getutxent" type="function">
    <function returntype="struct utmpx *">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "utmpx.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getutxent&lt;/CODE&gt; function is similar to &lt;CODE&gt;getutent&lt;/CODE&gt;, but returns
         a pointer to a &lt;CODE&gt;struct utmpx&lt;/CODE&gt; instead of &lt;CODE&gt;struct utmp&lt;/CODE&gt;.  On
         the GNU system it simply is an alias for &lt;CODE&gt;getutent&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-endutxent" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "utmpx.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;endutent&lt;/CODE&gt;.  On the GNU system it is
         simply an alias for &lt;CODE&gt;endutent&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getutxid" type="function">
    <function returntype="struct utmpx *">
      <prototype>
        <parameter content="const struct utmpx *id"/>
      </prototype>
      <headers>
        <header filename = "utmpx.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;getutid&lt;/CODE&gt;, but uses &lt;CODE&gt;struct utmpx&lt;/CODE&gt;
         instead of &lt;CODE&gt;struct utmp&lt;/CODE&gt;.  On the GNU system it is simply an alias
         for &lt;CODE&gt;getutid&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getutxline" type="function">
    <function returntype="struct utmpx *">
      <prototype>
        <parameter content="const struct utmpx *line"/>
      </prototype>
      <headers>
        <header filename = "utmpx.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;getutid&lt;/CODE&gt;, but uses &lt;CODE&gt;struct utmpx&lt;/CODE&gt;
         instead of &lt;CODE&gt;struct utmp&lt;/CODE&gt;.  On the GNU system it is simply an alias
         for &lt;CODE&gt;getutline&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-pututxline" type="function">
    <function returntype="struct utmpx *">
      <prototype>
        <parameter content="const struct utmpx *utmp"/>
      </prototype>
      <headers>
        <header filename = "utmpx.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;pututxline&lt;/CODE&gt; function is functionally identical to
         &lt;CODE&gt;pututline&lt;/CODE&gt;, but uses &lt;CODE&gt;struct utmpx&lt;/CODE&gt; instead of &lt;CODE&gt;struct
         utmp&lt;/CODE&gt;.  On the GNU system, &lt;CODE&gt;pututxline&lt;/CODE&gt; is simply an alias for
         &lt;CODE&gt;pututline&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-utmpxname" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *file"/>
      </prototype>
      <headers>
        <header filename = "utmpx.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;utmpxname&lt;/CODE&gt; function is functionally identical to
         &lt;CODE&gt;utmpname&lt;/CODE&gt;.  On the GNU system, &lt;CODE&gt;utmpxname&lt;/CODE&gt; is simply an
         alias for &lt;CODE&gt;utmpname&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getutmp" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const struct utmpx *utmpx"/>
        <parameter content="struct utmp *utmp"/>
      </prototype>
      <headers>
        <header filename = "utmpx.h"/>
        <header filename = "utmp.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;getutmp&lt;/CODE&gt; copies the information, insofar as the structures are
         compatible, from &lt;VAR&gt;utmpx&lt;/VAR&gt; to &lt;VAR&gt;utmp&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getutmpx" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const struct utmp *utmp"/>
        <parameter content="struct utmpx *utmpx"/>
      </prototype>
      <headers>
        <header filename = "utmpx.h"/>
        <header filename = "utmp.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;getutmpx&lt;/CODE&gt; copies the information, insofar as the structures are
         compatible, from &lt;VAR&gt;utmp&lt;/VAR&gt; to &lt;VAR&gt;utmpx&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-login_tty" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int filedes"/>
      </prototype>
      <headers>
        <header filename = "utmp.h"/>
      </headers>
        <synopsis>
        This function makes &lt;VAR&gt;filedes&lt;/VAR&gt; the controlling terminal of the
         current process, redirects standard input, standard output and
         standard error output to this terminal, and closes &lt;VAR&gt;filedes&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; This function returns &lt;CODE&gt;0&lt;/CODE&gt; on successful completion, and &lt;CODE&gt;-1&lt;/CODE&gt;
         on error.
        </synopsis>
    </function>
  </construct>
  <construct id="function-login" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="const struct utmp *entry"/>
      </prototype>
      <headers>
        <header filename = "utmp.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;login&lt;/CODE&gt; functions inserts an entry into the user accounting
         database.  The &lt;CODE&gt;ut_line&lt;/CODE&gt; member is set to the name of the terminal
         on standard input.  If standard input is not a terminal &lt;CODE&gt;login&lt;/CODE&gt;
         uses standard output or standard error output to determine the name of
         the terminal.  If &lt;CODE&gt;struct utmp&lt;/CODE&gt; has a &lt;CODE&gt;ut_type&lt;/CODE&gt; member,
         &lt;CODE&gt;login&lt;/CODE&gt; sets it to &lt;CODE&gt;USER_PROCESS&lt;/CODE&gt;, and if there is an
         &lt;CODE&gt;ut_pid&lt;/CODE&gt; member, it will be set to the process ID of the current
         process.  The remaining entries are copied from &lt;VAR&gt;entry&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; A copy of the entry is written to the user accounting log file.
        </synopsis>
    </function>
  </construct>
  <construct id="function-logout" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *ut_line"/>
      </prototype>
      <headers>
        <header filename = "utmp.h"/>
      </headers>
        <synopsis>
        This function modifies the user accounting database to indicate that the
         user on &lt;VAR&gt;ut_line&lt;/VAR&gt; has logged out.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;logout&lt;/CODE&gt; function returns &lt;CODE&gt;1&lt;/CODE&gt; if the entry was successfully
         written to the database, or &lt;CODE&gt;0&lt;/CODE&gt; on error.
        </synopsis>
    </function>
  </construct>
  <construct id="function-logwtmp" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="const char *ut_line"/>
        <parameter content="const char *ut_name"/>
        <parameter content="const char *ut_host"/>
      </prototype>
      <headers>
        <header filename = "utmp.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;logwtmp&lt;/CODE&gt; function appends an entry to the user accounting log
         file, for the current time and the information provided in the
         &lt;VAR&gt;ut_line&lt;/VAR&gt;, &lt;VAR&gt;ut_name&lt;/VAR&gt; and &lt;VAR&gt;ut_host&lt;/VAR&gt; arguments.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-passwd" type="struct">
    <structure>
        <synopsis>
        The &lt;CODE&gt;passwd&lt;/CODE&gt; data structure is used to hold information about
         entries in the system user data base.  It has at least the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="char *pw_name">
            <synopsis>
            The user's login name.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="char *pw_passwd.">
            <synopsis>
            The encrypted password string.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="uid_t pw_uid">
            <synopsis>
            The user ID number.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="gid_t pw_gid">
            <synopsis>
            The user's default group ID number.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="char *pw_gecos">
            <synopsis>
            A string typically containing the user's real name, and possibly other
             information such as a phone number.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="char *pw_dir">
            <synopsis>
            The user's home directory, or initial working directory.  This might be
             a null pointer, in which case the interpretation is system-dependent.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-getpwuid" type="function">
    <function returntype="struct passwd *">
      <prototype>
        <parameter content="uid_t uid"/>
      </prototype>
      <headers>
        <header filename = "pwd.h"/>
      </headers>
        <synopsis>
        This function returns a pointer to a statically-allocated structure
         containing information about the user whose user ID is &lt;VAR&gt;uid&lt;/VAR&gt;.  This
         structure may be overwritten on subsequent calls to &lt;CODE&gt;getpwuid&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; A null pointer value indicates there is no user in the data base with
         user ID &lt;VAR&gt;uid&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getpwuid_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="uid_t uid"/>
        <parameter content="struct passwd *result_buf"/>
        <parameter content="char *buffer"/>
        <parameter content="size_t buflen"/>
        <parameter content="struct passwd **result"/>
      </prototype>
      <headers>
        <header filename = "pwd.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;getpwuid&lt;/CODE&gt; in that it returns
         information about the user whose user ID is &lt;VAR&gt;uid&lt;/VAR&gt;.  However, it
         fills the user supplied structure pointed to by &lt;VAR&gt;result_buf&lt;/VAR&gt; with
         the information instead of using a static buffer.  The first
         &lt;VAR&gt;buflen&lt;/VAR&gt; bytes of the additional buffer pointed to by &lt;VAR&gt;buffer&lt;/VAR&gt;
         are used to contain additional information, normally strings which are
         pointed to by the elements of the result structure.
         &lt;br&gt;&lt;br&gt; If a user with ID &lt;VAR&gt;uid&lt;/VAR&gt; is found, the pointer returned in
         &lt;VAR&gt;result&lt;/VAR&gt; points to the record which contains the wanted data (i.e.,
         &lt;VAR&gt;result&lt;/VAR&gt; contains the value &lt;VAR&gt;result_buf&lt;/VAR&gt;).  If no user is found
         or if an error occurred, the pointer returned in &lt;VAR&gt;result&lt;/VAR&gt; is a null
         pointer.  The function returns zero or an error code.  If the buffer
         &lt;VAR&gt;buffer&lt;/VAR&gt; is too small to contain all the needed information, the
         error code &lt;CODE&gt;ERANGE&lt;/CODE&gt; is returned and &lt;VAR&gt;errno&lt;/VAR&gt; is set to
         &lt;CODE&gt;ERANGE&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getpwnam" type="function">
    <function returntype="struct passwd *">
      <prototype>
        <parameter content="const char *name"/>
      </prototype>
      <headers>
        <header filename = "pwd.h"/>
      </headers>
        <synopsis>
        This function returns a pointer to a statically-allocated structure
         containing information about the user whose user name is &lt;VAR&gt;name&lt;/VAR&gt;.
         This structure may be overwritten on subsequent calls to
         &lt;CODE&gt;getpwnam&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; A null pointer return indicates there is no user named &lt;VAR&gt;name&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getpwnam_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *name"/>
        <parameter content="struct passwd *result_buf"/>
        <parameter content="char *buffer"/>
        <parameter content="size_t buflen"/>
        <parameter content="struct passwd **result"/>
      </prototype>
      <headers>
        <header filename = "pwd.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;getpwnam&lt;/CODE&gt; in that is returns
         information about the user whose user name is &lt;VAR&gt;name&lt;/VAR&gt;.  However, like
         &lt;CODE&gt;getpwuid_r&lt;/CODE&gt;, it fills the user supplied buffers in
         &lt;VAR&gt;result_buf&lt;/VAR&gt; and &lt;VAR&gt;buffer&lt;/VAR&gt; with the information instead of using
         a static buffer.
         &lt;br&gt;&lt;br&gt; The return values are the same as for &lt;CODE&gt;getpwuid_r&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fgetpwent" type="function">
    <function returntype="struct passwd *">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "pwd.h"/>
      </headers>
        <synopsis>
        This function reads the next user entry from &lt;VAR&gt;stream&lt;/VAR&gt; and returns a
         pointer to the entry.  The structure is statically allocated and is
         rewritten on subsequent calls to &lt;CODE&gt;fgetpwent&lt;/CODE&gt;.  You must copy the
         contents of the structure if you wish to save the information.
         &lt;br&gt;&lt;br&gt; The stream must correspond to a file in the same format as the standard
         password database file.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fgetpwent_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
        <parameter content="struct passwd *result_buf"/>
        <parameter content="char *buffer"/>
        <parameter content="size_t buflen"/>
        <parameter content="struct passwd **result"/>
      </prototype>
      <headers>
        <header filename = "pwd.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;fgetpwent&lt;/CODE&gt; in that it reads the next
         user entry from &lt;VAR&gt;stream&lt;/VAR&gt;.  But the result is returned in the
         structure pointed to by &lt;VAR&gt;result_buf&lt;/VAR&gt;.  The
         first &lt;VAR&gt;buflen&lt;/VAR&gt; bytes of the additional buffer pointed to by
         &lt;VAR&gt;buffer&lt;/VAR&gt; are used to contain additional information, normally
         strings which are pointed to by the elements of the result structure.
         &lt;br&gt;&lt;br&gt; The stream must correspond to a file in the same format as the standard
         password database file.
         &lt;br&gt;&lt;br&gt; If the function returns zero &lt;VAR&gt;result&lt;/VAR&gt; points to the structure with
         the wanted data (normally this is in &lt;VAR&gt;result_buf&lt;/VAR&gt;).  If errors
         occurred the return value is nonzero and &lt;VAR&gt;result&lt;/VAR&gt; contains a null
         pointer.
        </synopsis>
    </function>
  </construct>
  <construct id="function-setpwent" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "pwd.h"/>
      </headers>
        <synopsis>
        This function initializes a stream which &lt;CODE&gt;getpwent&lt;/CODE&gt; and
         &lt;CODE&gt;getpwent_r&lt;/CODE&gt; use to read the user database.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getpwent" type="function">
    <function returntype="struct passwd *">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "pwd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getpwent&lt;/CODE&gt; function reads the next entry from the stream
         initialized by &lt;CODE&gt;setpwent&lt;/CODE&gt;.  It returns a pointer to the entry.  The
         structure is statically allocated and is rewritten on subsequent calls
         to &lt;CODE&gt;getpwent&lt;/CODE&gt;.  You must copy the contents of the structure if you
         wish to save the information.
         &lt;br&gt;&lt;br&gt; A null pointer is returned when no more entries are available.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getpwent_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="struct passwd *result_buf"/>
        <parameter content="char *buffer"/>
        <parameter content="int buflen"/>
        <parameter content="struct passwd **result"/>
      </prototype>
      <headers>
        <header filename = "pwd.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;getpwent&lt;/CODE&gt; in that it returns the next
         entry from the stream initialized by &lt;CODE&gt;setpwent&lt;/CODE&gt;.  Like
         &lt;CODE&gt;fgetpwent_r&lt;/CODE&gt;, it uses the user-supplied buffers in
         &lt;VAR&gt;result_buf&lt;/VAR&gt; and &lt;VAR&gt;buffer&lt;/VAR&gt; to return the information requested.
         &lt;br&gt;&lt;br&gt; The return values are the same as for &lt;CODE&gt;fgetpwent_r&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-endpwent" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "pwd.h"/>
      </headers>
        <synopsis>
        This function closes the internal stream used by &lt;CODE&gt;getpwent&lt;/CODE&gt; or
         &lt;CODE&gt;getpwent_r&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-putpwent" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const struct passwd *p"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "pwd.h"/>
      </headers>
        <synopsis>
        This function writes the user entry &lt;CODE&gt;*&lt;VAR&gt;p&lt;/VAR&gt;&lt;/CODE&gt; to the stream
         &lt;VAR&gt;stream&lt;/VAR&gt;, in the format used for the standard user database
         file.  The return value is zero on success and nonzero on failure.
         &lt;br&gt;&lt;br&gt; This function exists for compatibility with SVID.  We recommend that you
         avoid using it, because it makes sense only on the assumption that the
         &lt;CODE&gt;struct passwd&lt;/CODE&gt; structure has no members except the standard ones;
         on a system which merges the traditional Unix data base with other
         extended information about users, adding an entry using this function
         would inevitably leave out much of the important information.
         &lt;br&gt;&lt;br&gt; The group and user ID fields are left empty if the group or user name
         starts with a - or +.
         &lt;br&gt;&lt;br&gt; The function &lt;CODE&gt;putpwent&lt;/CODE&gt; is declared in &lt;TT&gt;pwd.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-group" type="struct">
    <structure>
        <synopsis>
        The &lt;CODE&gt;group&lt;/CODE&gt; structure is used to hold information about an entry in
         the system group database.  It has at least the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="char *gr_name">
            <synopsis>
            The name of the group.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="gid_t gr_gid">
            <synopsis>
            The group ID of the group.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-getgrgid" type="function">
    <function returntype="struct group *">
      <prototype>
        <parameter content="gid_t gid"/>
      </prototype>
      <headers>
        <header filename = "grp.h"/>
      </headers>
        <synopsis>
        This function returns a pointer to a statically-allocated structure
         containing information about the group whose group ID is &lt;VAR&gt;gid&lt;/VAR&gt;.
         This structure may be overwritten by subsequent calls to
         &lt;CODE&gt;getgrgid&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; A null pointer indicates there is no group with ID &lt;VAR&gt;gid&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getgrgid_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="gid_t gid"/>
        <parameter content="struct group *result_buf"/>
        <parameter content="char *buffer"/>
        <parameter content="size_t buflen"/>
        <parameter content="struct group **result"/>
      </prototype>
      <headers>
        <header filename = "grp.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;getgrgid&lt;/CODE&gt; in that it returns
         information about the group whose group ID is &lt;VAR&gt;gid&lt;/VAR&gt;.  However, it
         fills the user supplied structure pointed to by &lt;VAR&gt;result_buf&lt;/VAR&gt; with
         the information instead of using a static buffer.  The first
         &lt;VAR&gt;buflen&lt;/VAR&gt; bytes of the additional buffer pointed to by &lt;VAR&gt;buffer&lt;/VAR&gt;
         are used to contain additional information, normally strings which are
         pointed to by the elements of the result structure.
         &lt;br&gt;&lt;br&gt; If a group with ID &lt;VAR&gt;gid&lt;/VAR&gt; is found, the pointer returned in
         &lt;VAR&gt;result&lt;/VAR&gt; points to the record which contains the wanted data (i.e.,
         &lt;VAR&gt;result&lt;/VAR&gt; contains the value &lt;VAR&gt;result_buf&lt;/VAR&gt;).  If no group is found
         or if an error occurred, the pointer returned in &lt;VAR&gt;result&lt;/VAR&gt; is a null
         pointer.  The function returns zero or an error code.  If the buffer
         &lt;VAR&gt;buffer&lt;/VAR&gt; is too small to contain all the needed information, the
         error code &lt;CODE&gt;ERANGE&lt;/CODE&gt; is returned and &lt;VAR&gt;errno&lt;/VAR&gt; is set to
         &lt;CODE&gt;ERANGE&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getgrnam" type="function">
    <function returntype="struct group *">
      <prototype>
        <parameter content="const char *name"/>
      </prototype>
      <headers>
        <header filename = "grp.h"/>
      </headers>
        <synopsis>
        This function returns a pointer to a statically-allocated structure
         containing information about the group whose group name is &lt;VAR&gt;name&lt;/VAR&gt;.
         This structure may be overwritten by subsequent calls to
         &lt;CODE&gt;getgrnam&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; A null pointer indicates there is no group named &lt;VAR&gt;name&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getgrnam_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *name"/>
        <parameter content="struct group *result_buf"/>
        <parameter content="char *buffer"/>
        <parameter content="size_t buflen"/>
        <parameter content="struct group **result"/>
      </prototype>
      <headers>
        <header filename = "grp.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;getgrnam&lt;/CODE&gt; in that is returns
         information about the group whose group name is &lt;VAR&gt;name&lt;/VAR&gt;.  Like
         &lt;CODE&gt;getgrgid_r&lt;/CODE&gt;, it uses the user supplied buffers in
         &lt;VAR&gt;result_buf&lt;/VAR&gt; and &lt;VAR&gt;buffer&lt;/VAR&gt;, not a static buffer.
         &lt;br&gt;&lt;br&gt; The return values are the same as for &lt;CODE&gt;getgrgid_r&lt;/CODE&gt;
         &lt;CODE&gt;ERANGE&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fgetgrent" type="function">
    <function returntype="struct group *">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "grp.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fgetgrent&lt;/CODE&gt; function reads the next entry from &lt;VAR&gt;stream&lt;/VAR&gt;.
         It returns a pointer to the entry.  The structure is statically
         allocated and is overwritten on subsequent calls to &lt;CODE&gt;fgetgrent&lt;/CODE&gt;.  You
         must copy the contents of the structure if you wish to save the
         information.
         &lt;br&gt;&lt;br&gt; The stream must correspond to a file in the same format as the standard
         group database file.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fgetgrent_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
        <parameter content="struct group *result_buf"/>
        <parameter content="char *buffer"/>
        <parameter content="size_t buflen"/>
        <parameter content="struct group **result"/>
      </prototype>
      <headers>
        <header filename = "grp.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;fgetgrent&lt;/CODE&gt; in that it reads the next
         user entry from &lt;VAR&gt;stream&lt;/VAR&gt;.  But the result is returned in the
         structure pointed to by &lt;VAR&gt;result_buf&lt;/VAR&gt;.  The first &lt;VAR&gt;buflen&lt;/VAR&gt; bytes
         of the additional buffer pointed to by &lt;VAR&gt;buffer&lt;/VAR&gt; are used to contain
         additional information, normally strings which are pointed to by the
         elements of the result structure.
         &lt;br&gt;&lt;br&gt; This stream must correspond to a file in the same format as the standard
         group database file.
         &lt;br&gt;&lt;br&gt; If the function returns zero &lt;VAR&gt;result&lt;/VAR&gt; points to the structure with
         the wanted data (normally this is in &lt;VAR&gt;result_buf&lt;/VAR&gt;).  If errors
         occurred the return value is non-zero and &lt;VAR&gt;result&lt;/VAR&gt; contains a null
         pointer.
        </synopsis>
    </function>
  </construct>
  <construct id="function-setgrent" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "grp.h"/>
      </headers>
        <synopsis>
        This function initializes a stream for reading from the group data base.
         You use this stream by calling &lt;CODE&gt;getgrent&lt;/CODE&gt; or &lt;CODE&gt;getgrent_r&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getgrent" type="function">
    <function returntype="struct group *">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "grp.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getgrent&lt;/CODE&gt; function reads the next entry from the stream
         initialized by &lt;CODE&gt;setgrent&lt;/CODE&gt;.  It returns a pointer to the entry.  The
         structure is statically allocated and is overwritten on subsequent calls
         to &lt;CODE&gt;getgrent&lt;/CODE&gt;.  You must copy the contents of the structure if you
         wish to save the information.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getgrent_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="struct group *result_buf"/>
        <parameter content="char *buffer"/>
        <parameter content="size_t buflen"/>
        <parameter content="struct group **result"/>
      </prototype>
      <headers>
        <header filename = "grp.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;getgrent&lt;/CODE&gt; in that it returns the next
         entry from the stream initialized by &lt;CODE&gt;setgrent&lt;/CODE&gt;.  Like
         &lt;CODE&gt;fgetgrent_r&lt;/CODE&gt;, it places the result in user-supplied buffers
         pointed to &lt;VAR&gt;result_buf&lt;/VAR&gt; and &lt;VAR&gt;buffer&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If the function returns zero &lt;VAR&gt;result&lt;/VAR&gt; contains a pointer to the data
         (normally equal to &lt;VAR&gt;result_buf&lt;/VAR&gt;).  If errors occurred the return
         value is non-zero and &lt;VAR&gt;result&lt;/VAR&gt; contains a null pointer.
        </synopsis>
    </function>
  </construct>
  <construct id="function-endgrent" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "grp.h"/>
      </headers>
        <synopsis>
        This function closes the internal stream used by &lt;CODE&gt;getgrent&lt;/CODE&gt; or
         &lt;CODE&gt;getgrent_r&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-setnetgrent" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *netgroup"/>
      </prototype>
      <headers>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        A call to this function initializes the internal state of the library to
         allow following calls of the &lt;CODE&gt;getnetgrent&lt;/CODE&gt; to iterate over all entries
         in the netgroup with name &lt;VAR&gt;netgroup&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; When the call is successful (i.e., when a netgroup with this name exists)
         the return value is &lt;CODE&gt;1&lt;/CODE&gt;.  When the return value is &lt;CODE&gt;0&lt;/CODE&gt; no
         netgroup of this name is known or some other error occurred.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getnetgrent" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="char **hostp"/>
        <parameter content="char **userp"/>
        <parameter content="char **domainp"/>
      </prototype>
      <headers>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        This function returns the next unprocessed entry of the currently
         selected netgroup.  The string pointers, in which addresses are passed in
         the arguments &lt;VAR&gt;hostp&lt;/VAR&gt;, &lt;VAR&gt;userp&lt;/VAR&gt;, and &lt;VAR&gt;domainp&lt;/VAR&gt;, will contain
         after a successful call pointers to appropriate strings.  If the string
         in the next entry is empty the pointer has the value &lt;CODE&gt;NULL&lt;/CODE&gt;.
         The returned string pointers are only valid if none of the netgroup
         related functions are called.
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;1&lt;/CODE&gt; if the next entry was successfully read.  A
         value of &lt;CODE&gt;0&lt;/CODE&gt; means no further entries exist or internal errors occurred.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getnetgrent_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="char **hostp"/>
        <parameter content="char **userp"/>
        <parameter content="char **domainp"/>
        <parameter content="char *buffer"/>
        <parameter content="int buflen"/>
      </prototype>
      <headers>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;getnetgrent&lt;/CODE&gt; with only one exception:
         the strings the three string pointers &lt;VAR&gt;hostp&lt;/VAR&gt;, &lt;VAR&gt;userp&lt;/VAR&gt;, and
         &lt;VAR&gt;domainp&lt;/VAR&gt; point to, are placed in the buffer of &lt;VAR&gt;buflen&lt;/VAR&gt; bytes
         starting at &lt;VAR&gt;buffer&lt;/VAR&gt;.  This means the returned values are valid
         even after other netgroup related functions are called.
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;1&lt;/CODE&gt; if the next entry was successfully read and
         the buffer contains enough room to place the strings in it.  &lt;CODE&gt;0&lt;/CODE&gt; is
         returned in case no more entries are found, the buffer is too small, or
         internal errors occurred.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.  The original implementation in the
         SunOS libc does not provide this function.
        </synopsis>
    </function>
  </construct>
  <construct id="function-endnetgrent" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        This function frees all buffers which were allocated to process the last
         selected netgroup.  As a result all string pointers returned by calls
         to &lt;CODE&gt;getnetgrent&lt;/CODE&gt; are invalid afterwards.
        </synopsis>
    </function>
  </construct>
  <construct id="function-innetgr" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *netgroup"/>
        <parameter content="const char *host"/>
        <parameter content="const char *user"/>
        <parameter content="const char *domain"/>
      </prototype>
      <headers>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        This function tests whether the triple specified by the parameters
         &lt;VAR&gt;hostp&lt;/VAR&gt;, &lt;VAR&gt;userp&lt;/VAR&gt;, and &lt;VAR&gt;domainp&lt;/VAR&gt; is part of the netgroup
         &lt;VAR&gt;netgroup&lt;/VAR&gt;.  Using this function has the advantage that
         &lt;br&gt;&lt;br&gt; &lt;OL&gt;
         &lt;LI&gt;
         no other netgroup function can use the global netgroup state since
         internal locking is used and
         &lt;LI&gt;
         the function is implemented more efficiently than successive calls
         to the other &lt;CODE&gt;set&lt;/CODE&gt;/&lt;CODE&gt;get&lt;/CODE&gt;/&lt;CODE&gt;endnetgrent&lt;/CODE&gt; functions.
         &lt;/OL&gt;
         &lt;br&gt;&lt;br&gt; Any of the pointers &lt;VAR&gt;hostp&lt;/VAR&gt;, &lt;VAR&gt;userp&lt;/VAR&gt;, and &lt;VAR&gt;domainp&lt;/VAR&gt; can be
         &lt;CODE&gt;NULL&lt;/CODE&gt; which means any value is accepted in this position.  This is
         also true for the name &lt;CODE&gt;-&lt;/CODE&gt; which should not match any other string
         otherwise.
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;1&lt;/CODE&gt; if an entry matching the given triple is
         found in the netgroup.  The return value is &lt;CODE&gt;0&lt;/CODE&gt; if the netgroup
         itself is not found, the netgroup does not contain the triple or
         internal errors occurred.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-sockaddr" type="struct">
    <structure>
        <synopsis>
        The &lt;CODE&gt;struct sockaddr&lt;/CODE&gt; type itself has the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="short int sa_family">
            <synopsis>
            This is the code for the address format of this address.  It
             identifies the format of the data which follows.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-bind" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int socket"/>
        <parameter content="struct sockaddr *addr"/>
        <parameter content="socklen_t length"/>
      </prototype>
      <headers>
        <header filename = "sys/socket.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;bind&lt;/CODE&gt; function assigns an address to the socket
         &lt;VAR&gt;socket&lt;/VAR&gt;.  The &lt;VAR&gt;addr&lt;/VAR&gt; and &lt;VAR&gt;length&lt;/VAR&gt; arguments specify the
         address; the detailed format of the address depends on the namespace.
         The first part of the address is always the format designator, which
         specifies a namespace, and says that the address is in the format of
         that namespace.
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; on success and &lt;CODE&gt;-1&lt;/CODE&gt; on failure.  The
         following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;socket&lt;/VAR&gt; argument is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOTSOCK
         The descriptor &lt;VAR&gt;socket&lt;/VAR&gt; is not a socket.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EADDRNOTAVAIL
         The specified address is not available on this machine.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EADDRINUSE
         Some other socket is already using the specified address.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         The socket &lt;VAR&gt;socket&lt;/VAR&gt; already has an address.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EACCES
         You do not have permission to access the requested address.  (In the
         Internet domain, only the super-user is allowed to specify a port number
         in the range 0 through &lt;CODE&gt;IPPORT_RESERVED&lt;/CODE&gt; minus one; see
         Ports.)

         &lt;br&gt;&lt;br&gt; Additional conditions may be possible depending on the particular namespace
         of the socket.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getsockname" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int socket"/>
        <parameter content="struct sockaddr *addr"/>
        <parameter content="socklen_t *length-ptr"/>
      </prototype>
      <headers>
        <header filename = "sys/socket.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getsockname&lt;/CODE&gt; function returns information about the
         address of the socket &lt;VAR&gt;socket&lt;/VAR&gt; in the locations specified by the
         &lt;VAR&gt;addr&lt;/VAR&gt; and &lt;VAR&gt;length-ptr&lt;/VAR&gt; arguments.  Note that the
         &lt;VAR&gt;length-ptr&lt;/VAR&gt; is a pointer; you should initialize it to be the
         allocation size of &lt;VAR&gt;addr&lt;/VAR&gt;, and on return it contains the actual
         size of the address data.
         &lt;br&gt;&lt;br&gt; The format of the address data depends on the socket namespace.  The
         length of the information is usually fixed for a given namespace, so
         normally you can know exactly how much space is needed and can provide
         that much.  The usual practice is to allocate a place for the value
         using the proper data type for the socket's namespace, then cast its
         address to &lt;CODE&gt;struct sockaddr *&lt;/CODE&gt; to pass it to &lt;CODE&gt;getsockname&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; on success and &lt;CODE&gt;-1&lt;/CODE&gt; on error.  The
         following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;socket&lt;/VAR&gt; argument is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOTSOCK
         The descriptor &lt;VAR&gt;socket&lt;/VAR&gt; is not a socket.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOBUFS
         There are not enough internal buffers available for the operation.

        </synopsis>
    </function>
  </construct>
  <construct id="function-if_nametoindex" type="function">
    <function returntype="unsigned int">
      <prototype>
        <parameter content="const char *ifname"/>
      </prototype>
      <headers>
        <header filename = "net/if.h"/>
      </headers>
        <synopsis>
        This function yields the interface index corresponding to a particular
         name.  If no interface exists with the name given, it returns 0.
        </synopsis>
    </function>
  </construct>
  <construct id="function-if_indextoname" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="unsigned int ifindex"/>
        <parameter content="char *ifname"/>
      </prototype>
      <headers>
        <header filename = "net/if.h"/>
      </headers>
        <synopsis>
        This function maps an interface index to its corresponding name.  The
         returned name is placed in the buffer pointed to by &lt;CODE&gt;ifname&lt;/CODE&gt;, which
         must be at least &lt;CODE&gt;IFNAMSIZ&lt;/CODE&gt; bytes in length.  If the index was
         invalid, the function's return value is a null pointer, otherwise it is
         &lt;CODE&gt;ifname&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-if_nameindex" type="struct">
    <structure>
        <synopsis>
        This data type is used to hold the information about a single
         interface.  It has the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="unsigned int if_index;">
            <synopsis>
            This is the interface index.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-if_nameindex" type="function">
    <function returntype="struct if_nameindex *">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "net/if.h"/>
      </headers>
        <synopsis>
        This function returns an array of &lt;CODE&gt;if_nameindex&lt;/CODE&gt; structures, one
         for every interface that is present.  The end of the list is indicated
         by a structure with an interface of 0 and a null name pointer.  If an
         error occurs, this function returns a null pointer.
         &lt;br&gt;&lt;br&gt; The returned structure must be freed with &lt;CODE&gt;if_freenameindex&lt;/CODE&gt; after
         use.
        </synopsis>
    </function>
  </construct>
  <construct id="function-if_freenameindex" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="struct if_nameindex *ptr"/>
      </prototype>
      <headers>
        <header filename = "net/if.h"/>
      </headers>
        <synopsis>
        This function frees the structure returned by an earlier call to
         &lt;CODE&gt;if_nameindex&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-sockaddr_un" type="struct">
    <structure>
        <synopsis>
        This structure is used to specify local namespace socket addresses.  It has
         the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="short int sun_family">
            <synopsis>
            This identifies the address family or format of the socket address.
             You should store the value &lt;CODE&gt;AF_LOCAL&lt;/CODE&gt; to designate the local
             namespace.  .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="struct-sockaddr_in" type="struct">
    <structure>
        <synopsis>
        This is the data type used to represent socket addresses in the
         Internet namespace.  It has the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="sa_family_t sin_family">
            <synopsis>
            This identifies the address family or format of the socket address.
             You should store the value &lt;CODE&gt;AF_INET&lt;/CODE&gt; in this member.
             .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="struct in_addr sin_addr">
            <synopsis>
            This is the Internet address of the host machine.  , and Host Names, for how to get a value to store
             here.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="struct-sockaddr_in6" type="struct">
    <structure>
        <synopsis>
        This is the data type used to represent socket addresses in the IPv6
         namespace.  It has the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="sa_family_t sin6_family">
            <synopsis>
            This identifies the address family or format of the socket address.
             You should store the value of &lt;CODE&gt;AF_INET6&lt;/CODE&gt; in this member.
             .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="struct in6_addr sin6_addr">
            <synopsis>
            This is the IPv6 address of the host machine.  , and Host Names, for how to get a value to store
             here.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="uint32_t sin6_flowinfo">
            <synopsis>
            This is a currently unimplemented field.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="struct-in_addr" type="struct">
    <structure>
    </structure>
  </construct>
  <construct id="struct-in6_addr" type="struct">
    <structure>
    </structure>
  </construct>
  <construct id="function-inet_aton" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *name"/>
        <parameter content="struct in_addr *addr"/>
      </prototype>
      <headers>
        <header filename = "sys/socket.h"/>
        <header filename = "netinet/in.h"/>
        <header filename = "arpa/inet.h"/>
      </headers>
        <synopsis>
        This function converts the IPv4 Internet host address &lt;VAR&gt;name&lt;/VAR&gt;
         from the standard numbers-and-dots notation into binary data and stores
         it in the &lt;CODE&gt;struct in_addr&lt;/CODE&gt; that &lt;VAR&gt;addr&lt;/VAR&gt; points to.
         &lt;CODE&gt;inet_aton&lt;/CODE&gt; returns nonzero if the address is valid, zero if not.
        </synopsis>
    </function>
  </construct>
  <construct id="function-inet_addr" type="function">
    <function returntype="uint32_t">
      <prototype>
        <parameter content="const char *name"/>
      </prototype>
      <headers>
        <header filename = "arpa/inet.h"/>
      </headers>
        <synopsis>
        This function converts the IPv4 Internet host address &lt;VAR&gt;name&lt;/VAR&gt; from the
         standard numbers-and-dots notation into binary data.  If the input is
         not valid, &lt;CODE&gt;inet_addr&lt;/CODE&gt; returns &lt;CODE&gt;INADDR_NONE&lt;/CODE&gt;.  This is an
         obsolete interface to &lt;CODE&gt;inet_aton&lt;/CODE&gt;, described immediately above. It
         is obsolete because &lt;CODE&gt;INADDR_NONE&lt;/CODE&gt; is a valid address
         (255.255.255.255), and &lt;CODE&gt;inet_aton&lt;/CODE&gt; provides a cleaner way to
         indicate error return.
        </synopsis>
    </function>
  </construct>
  <construct id="function-inet_network" type="function">
    <function returntype="uint32_t">
      <prototype>
        <parameter content="const char *name"/>
      </prototype>
      <headers>
        <header filename = "arpa/inet.h"/>
      </headers>
        <synopsis>
        This function extracts the network number from the address &lt;VAR&gt;name&lt;/VAR&gt;,
         given in the standard numbers-and-dots notation. The returned address is
         in host order. If the input is not valid, &lt;CODE&gt;inet_network&lt;/CODE&gt; returns
         &lt;CODE&gt;-1&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The function works only with traditional IPv4 class A, B and C network
         types.  It doesn't work with classless addresses and shouldn't be used
         anymore.
        </synopsis>
    </function>
  </construct>
  <construct id="function-inet_ntoa" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="struct in_addr addr"/>
      </prototype>
      <headers>
        <header filename = "arpa/inet.h"/>
      </headers>
        <synopsis>
        This function converts the IPv4 Internet host address &lt;VAR&gt;addr&lt;/VAR&gt; to a
         string in the standard numbers-and-dots notation.  The return value is
         a pointer into a statically-allocated buffer.  Subsequent calls will
         overwrite the same buffer, so you should copy the string if you need
         to save it.
         &lt;br&gt;&lt;br&gt; In multi-threaded programs each thread has an own statically-allocated
         buffer.  But still subsequent calls of &lt;CODE&gt;inet_ntoa&lt;/CODE&gt; in the same
         thread will overwrite the result of the last call.
         &lt;br&gt;&lt;br&gt; Instead of &lt;CODE&gt;inet_ntoa&lt;/CODE&gt; the newer function &lt;CODE&gt;inet_ntop&lt;/CODE&gt; which is
         described below should be used since it handles both IPv4 and IPv6
         addresses.
        </synopsis>
    </function>
  </construct>
  <construct id="function-inet_makeaddr" type="function">
    <function returntype="struct in_addr">
      <prototype>
        <parameter content="uint32_t net"/>
        <parameter content="uint32_t local"/>
      </prototype>
      <headers>
        <header filename = "arpa/inet.h"/>
      </headers>
        <synopsis>
        This function makes an IPv4 Internet host address by combining the network
         number &lt;VAR&gt;net&lt;/VAR&gt; with the local-address-within-network number
         &lt;VAR&gt;local&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-inet_lnaof" type="function">
    <function returntype="uint32_t">
      <prototype>
        <parameter content="struct in_addr addr"/>
      </prototype>
      <headers>
        <header filename = "arpa/inet.h"/>
      </headers>
        <synopsis>
        This function returns the local-address-within-network part of the
         Internet host address &lt;VAR&gt;addr&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The function works only with traditional IPv4 class A, B and C network
         types.  It doesn't work with classless addresses and shouldn't be used
         anymore.
        </synopsis>
    </function>
  </construct>
  <construct id="function-inet_netof" type="function">
    <function returntype="uint32_t">
      <prototype>
        <parameter content="struct in_addr addr"/>
      </prototype>
      <headers>
        <header filename = "arpa/inet.h"/>
      </headers>
        <synopsis>
        This function returns the network number part of the Internet host
         address &lt;VAR&gt;addr&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The function works only with traditional IPv4 class A, B and C network
         types.  It doesn't work with classless addresses and shouldn't be used
         anymore.
        </synopsis>
    </function>
  </construct>
  <construct id="function-inet_pton" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int af"/>
        <parameter content="const char *cp"/>
        <parameter content="void *buf"/>
      </prototype>
      <headers>
        <header filename = "arpa/inet.h"/>
      </headers>
        <synopsis>
        This function converts an Internet address (either IPv4 or IPv6) from
         presentation (textual) to network (binary) format.  &lt;VAR&gt;af&lt;/VAR&gt; should be
         either &lt;CODE&gt;AF_INET&lt;/CODE&gt; or &lt;CODE&gt;AF_INET6&lt;/CODE&gt;, as appropriate for the type of
         address being converted.  &lt;VAR&gt;cp&lt;/VAR&gt; is a pointer to the input string, and
         &lt;VAR&gt;buf&lt;/VAR&gt; is a pointer to a buffer for the result.  It is the caller's
         responsibility to make sure the buffer is large enough.
        </synopsis>
    </function>
  </construct>
  <construct id="function-inet_ntop" type="function">
    <function returntype="const char *">
      <prototype>
        <parameter content="int af"/>
        <parameter content="const void *cp"/>
        <parameter content="char *buf"/>
        <parameter content="size_t len"/>
      </prototype>
      <headers>
        <header filename = "arpa/inet.h"/>
      </headers>
        <synopsis>
        This function converts an Internet address (either IPv4 or IPv6) from
         network (binary) to presentation (textual) form.  &lt;VAR&gt;af&lt;/VAR&gt; should be
         either &lt;CODE&gt;AF_INET&lt;/CODE&gt; or &lt;CODE&gt;AF_INET6&lt;/CODE&gt;, as appropriate.  &lt;VAR&gt;cp&lt;/VAR&gt; is a
         pointer to the address to be converted.  &lt;VAR&gt;buf&lt;/VAR&gt; should be a pointer
         to a buffer to hold the result, and &lt;VAR&gt;len&lt;/VAR&gt; is the length of this
         buffer.  The return value from the function will be this buffer address.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-hostent" type="struct">
    <structure>
        <synopsis>
        This data type is used to represent an entry in the hosts database.  It
         has the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="char *h_name">
            <synopsis>
            This is the ``official'' name of the host.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="char **h_aliases">
            <synopsis>
            These are alternative names for the host, represented as a null-terminated
             vector of strings.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int h_addrtype">
            <synopsis>
            This is the host address type; in practice, its value is always either
             &lt;CODE&gt;AF_INET&lt;/CODE&gt; or &lt;CODE&gt;AF_INET6&lt;/CODE&gt;, with the latter being used for IPv6
             hosts.  In principle other kinds of addresses could be represented in
             the database as well as Internet addresses; if this were done, you
             might find a value in this field other than &lt;CODE&gt;AF_INET&lt;/CODE&gt; or
             &lt;CODE&gt;AF_INET6&lt;/CODE&gt;.  .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int h_length">
            <synopsis>
            This is the length, in bytes, of each address.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="char **h_addr_list">
            <synopsis>
            This is the vector of addresses for the host.  (Recall that the host
             might be connected to multiple networks and have different addresses on
             each one.)  The vector is terminated by a null pointer.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-gethostbyname" type="function">
    <function returntype="struct hostent *">
      <prototype>
        <parameter content="const char *name"/>
      </prototype>
      <headers>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;gethostbyname&lt;/CODE&gt; function returns information about the host
         named &lt;VAR&gt;name&lt;/VAR&gt;.  If the lookup fails, it returns a null pointer.
        </synopsis>
    </function>
  </construct>
  <construct id="function-gethostbyname2" type="function">
    <function returntype="struct hostent *">
      <prototype>
        <parameter content="const char *name"/>
        <parameter content="int af"/>
      </prototype>
      <headers>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;gethostbyname2&lt;/CODE&gt; function is like &lt;CODE&gt;gethostbyname&lt;/CODE&gt;, but
         allows the caller to specify the desired address family (e.g.:
         &lt;CODE&gt;AF_INET&lt;/CODE&gt; or &lt;CODE&gt;AF_INET6&lt;/CODE&gt;) of the result.
        </synopsis>
    </function>
  </construct>
  <construct id="function-gethostbyaddr" type="function">
    <function returntype="struct hostent *">
      <prototype>
        <parameter content="const char *addr"/>
        <parameter content="size_t length"/>
        <parameter content="int format"/>
      </prototype>
      <headers>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;gethostbyaddr&lt;/CODE&gt; function returns information about the host
         with Internet address &lt;VAR&gt;addr&lt;/VAR&gt;.  The parameter &lt;VAR&gt;addr&lt;/VAR&gt; is not
         really a pointer to char - it can be a pointer to an IPv4 or an IPv6
         address. The &lt;VAR&gt;length&lt;/VAR&gt; argument is the size (in bytes) of the address
         at &lt;VAR&gt;addr&lt;/VAR&gt;.  &lt;VAR&gt;format&lt;/VAR&gt; specifies the address format; for an IPv4
         Internet address, specify a value of &lt;CODE&gt;AF_INET&lt;/CODE&gt;; for an IPv6
         Internet address, use &lt;CODE&gt;AF_INET6&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; If the lookup fails, &lt;CODE&gt;gethostbyaddr&lt;/CODE&gt; returns a null pointer.
        </synopsis>
    </function>
  </construct>
  <construct id="function-gethostbyname_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *restrict name"/>
        <parameter content="struct hostent *restrict result_buf"/>
        <parameter content="char *restrict buf"/>
        <parameter content="size_t buflen"/>
        <parameter content="struct hostent **restrict result"/>
        <parameter content="int *restrict h_errnop"/>
      </prototype>
      <headers>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;gethostbyname_r&lt;/CODE&gt; function returns information about the host
         named &lt;VAR&gt;name&lt;/VAR&gt;.  The caller must pass a pointer to an object of type
         &lt;CODE&gt;struct hostent&lt;/CODE&gt; in the &lt;VAR&gt;result_buf&lt;/VAR&gt; parameter.  In addition
         the function may need extra buffer space and the caller must pass an
         pointer and the size of the buffer in the &lt;VAR&gt;buf&lt;/VAR&gt; and &lt;VAR&gt;buflen&lt;/VAR&gt;
         parameters.
         &lt;br&gt;&lt;br&gt; A pointer to the buffer, in which the result is stored, is available in
         &lt;CODE&gt;*&lt;VAR&gt;result&lt;/VAR&gt;&lt;/CODE&gt; after the function call successfully returned.  If
         an error occurs or if no entry is found, the pointer &lt;CODE&gt;*&lt;VAR&gt;result&lt;/VAR&gt;&lt;/CODE&gt;
         is a null pointer.  Success is signalled by a zero return value.  If the
         function failed the return value is an error number.  In addition to the
         errors defined for &lt;CODE&gt;gethostbyname&lt;/CODE&gt; it can also be &lt;CODE&gt;ERANGE&lt;/CODE&gt;.
         In this case the call should be repeated with a larger buffer.
         Additional error information is not stored in the global variable
         &lt;CODE&gt;h_errno&lt;/CODE&gt; but instead in the object pointed to by &lt;VAR&gt;h_errnop&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; Here's a small example:
         &lt;pre&gt;&lt;br&gt;
         struct hostent *&lt;br&gt;
         gethostname (char *host)&lt;br&gt;
         {&lt;br&gt;
           struct hostent hostbuf, *hp;&lt;br&gt;
           size_t hstbuflen;&lt;br&gt;
           char *tmphstbuf;&lt;br&gt;
           int res;&lt;br&gt;
           int herr;&lt;br&gt;
         &lt;br&gt;&lt;br&gt;   hstbuflen = 1024;&lt;br&gt;
           /* Allocate buffer, remember to free it to avoid memory leakage.  */&lt;br&gt;
           tmphstbuf = malloc (hstbuflen);&lt;br&gt;
         &lt;br&gt;&lt;br&gt;   while ((res = gethostbyname_r (host, &amp;hostbuf, tmphstbuf, hstbuflen,&lt;br&gt;
                                          &amp;hp, &amp;herr)) == ERANGE)&lt;br&gt;
             {&lt;br&gt;
               /* Enlarge the buffer.  */&lt;br&gt;
               hstbuflen *= 2;&lt;br&gt;
               tmphstbuf = realloc (tmphstbuf, hstbuflen);&lt;br&gt;
             }&lt;br&gt;
           /*  Check for errors.  */&lt;br&gt;
           if (res || hp == NULL)&lt;br&gt;
             return NULL;&lt;br&gt;
           return hp;&lt;br&gt;
         }&lt;br&gt;
         &lt;/pre&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-gethostbyname2_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *name"/>
        <parameter content="int af"/>
        <parameter content="struct hostent *restrict result_buf"/>
        <parameter content="char *restrict buf"/>
        <parameter content="size_t buflen"/>
        <parameter content="struct hostent **restrict result"/>
        <parameter content="int *restrict h_errnop"/>
      </prototype>
      <headers>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;gethostbyname2_r&lt;/CODE&gt; function is like &lt;CODE&gt;gethostbyname_r&lt;/CODE&gt;, but
         allows the caller to specify the desired address family (e.g.:
         &lt;CODE&gt;AF_INET&lt;/CODE&gt; or &lt;CODE&gt;AF_INET6&lt;/CODE&gt;) for the result.
        </synopsis>
    </function>
  </construct>
  <construct id="function-gethostbyaddr_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *addr"/>
        <parameter content="size_t length"/>
        <parameter content="int format"/>
        <parameter content="struct hostent *restrict result_buf"/>
        <parameter content="char *restrict buf"/>
        <parameter content="size_t buflen"/>
        <parameter content="struct hostent **restrict result"/>
        <parameter content="int *restrict h_errnop"/>
      </prototype>
      <headers>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;gethostbyaddr_r&lt;/CODE&gt; function returns information about the host
         with Internet address &lt;VAR&gt;addr&lt;/VAR&gt;.  The parameter &lt;VAR&gt;addr&lt;/VAR&gt; is not
         really a pointer to char - it can be a pointer to an IPv4 or an IPv6
         address. The &lt;VAR&gt;length&lt;/VAR&gt; argument is the size (in bytes) of the address
         at &lt;VAR&gt;addr&lt;/VAR&gt;.  &lt;VAR&gt;format&lt;/VAR&gt; specifies the address format; for an IPv4
         Internet address, specify a value of &lt;CODE&gt;AF_INET&lt;/CODE&gt;; for an IPv6
         Internet address, use &lt;CODE&gt;AF_INET6&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; Similar to the &lt;CODE&gt;gethostbyname_r&lt;/CODE&gt; function, the caller must provide
         buffers for the result and memory used internally.  In case of success
         the function returns zero.  Otherwise the value is an error number where
         &lt;CODE&gt;ERANGE&lt;/CODE&gt; has the special meaning that the caller-provided buffer is
         too small.
        </synopsis>
    </function>
  </construct>
  <construct id="function-sethostent" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="int stayopen"/>
      </prototype>
      <headers>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        This function opens the hosts database to begin scanning it.  You can
         then call &lt;CODE&gt;gethostent&lt;/CODE&gt; to read the entries.
         &lt;br&gt;&lt;br&gt; If the &lt;VAR&gt;stayopen&lt;/VAR&gt; argument is nonzero, this sets a flag so that
         subsequent calls to &lt;CODE&gt;gethostbyname&lt;/CODE&gt; or &lt;CODE&gt;gethostbyaddr&lt;/CODE&gt; will
         not close the database (as they usually would).  This makes for more
         efficiency if you call those functions several times, by avoiding
         reopening the database for each call.
        </synopsis>
    </function>
  </construct>
  <construct id="function-gethostent" type="function">
    <function returntype="struct hostent *">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        This function returns the next entry in the hosts database.  It
         returns a null pointer if there are no more entries.
        </synopsis>
    </function>
  </construct>
  <construct id="function-endhostent" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        This function closes the hosts database.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-servent" type="struct">
    <structure>
        <synopsis>
        This data type holds information about entries from the services database.
         It has the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="char *s_name">
            <synopsis>
            This is the ``official'' name of the service.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="char **s_aliases">
            <synopsis>
            These are alternate names for the service, represented as an array of
             strings.  A null pointer terminates the array.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int s_port">
            <synopsis>
            This is the port number for the service.  Port numbers are given in
             network byte order; see Byte Order.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-getservbyname" type="function">
    <function returntype="struct servent *">
      <prototype>
        <parameter content="const char *name"/>
        <parameter content="const char *proto"/>
      </prototype>
      <headers>
        <header filename = "netinet/in.h"/>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getservbyname&lt;/CODE&gt; function returns information about the
         service named &lt;VAR&gt;name&lt;/VAR&gt; using protocol &lt;VAR&gt;proto&lt;/VAR&gt;.  If it can't find
         such a service, it returns a null pointer.
         &lt;br&gt;&lt;br&gt; This function is useful for servers as well as for clients; servers
         use it to determine which port they should listen on .
        </synopsis>
    </function>
  </construct>
  <construct id="function-getservbyport" type="function">
    <function returntype="struct servent *">
      <prototype>
        <parameter content="int port"/>
        <parameter content="const char *proto"/>
      </prototype>
      <headers>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getservbyport&lt;/CODE&gt; function returns information about the
         service at port &lt;VAR&gt;port&lt;/VAR&gt; using protocol &lt;VAR&gt;proto&lt;/VAR&gt;.  If it can't
         find such a service, it returns a null pointer.
        </synopsis>
    </function>
  </construct>
  <construct id="function-setservent" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="int stayopen"/>
      </prototype>
      <headers>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        This function opens the services database to begin scanning it.
         &lt;br&gt;&lt;br&gt; If the &lt;VAR&gt;stayopen&lt;/VAR&gt; argument is nonzero, this sets a flag so that
         subsequent calls to &lt;CODE&gt;getservbyname&lt;/CODE&gt; or &lt;CODE&gt;getservbyport&lt;/CODE&gt; will
         not close the database (as they usually would).  This makes for more
         efficiency if you call those functions several times, by avoiding
         reopening the database for each call.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getservent" type="function">
    <function returntype="struct servent *">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        This function returns the next entry in the services database.  If
         there are no more entries, it returns a null pointer.
        </synopsis>
    </function>
  </construct>
  <construct id="function-endservent" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        This function closes the services database.
        </synopsis>
    </function>
  </construct>
  <construct id="function-htons" type="function">
    <function returntype="uint16_t">
      <prototype>
        <parameter content="uint16_t hostshort"/>
      </prototype>
      <headers>
        <header filename = "netinet/in.h"/>
      </headers>
        <synopsis>
        This function converts the &lt;CODE&gt;uint16_t&lt;/CODE&gt; integer &lt;VAR&gt;hostshort&lt;/VAR&gt; from
         host byte order to network byte order.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ntohs" type="function">
    <function returntype="uint16_t">
      <prototype>
        <parameter content="uint16_t netshort"/>
      </prototype>
      <headers>
        <header filename = "netinet/in.h"/>
      </headers>
        <synopsis>
        This function converts the &lt;CODE&gt;uint16_t&lt;/CODE&gt; integer &lt;VAR&gt;netshort&lt;/VAR&gt; from
         network byte order to host byte order.
        </synopsis>
    </function>
  </construct>
  <construct id="function-htonl" type="function">
    <function returntype="uint32_t">
      <prototype>
        <parameter content="uint32_t hostlong"/>
      </prototype>
      <headers>
        <header filename = "netinet/in.h"/>
      </headers>
        <synopsis>
        This function converts the &lt;CODE&gt;uint32_t&lt;/CODE&gt; integer &lt;VAR&gt;hostlong&lt;/VAR&gt; from
         host byte order to network byte order.
         &lt;br&gt;&lt;br&gt; This is used for IPv4 Internet addresses.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ntohl" type="function">
    <function returntype="uint32_t">
      <prototype>
        <parameter content="uint32_t netlong"/>
      </prototype>
      <headers>
        <header filename = "netinet/in.h"/>
      </headers>
        <synopsis>
        This function converts the &lt;CODE&gt;uint32_t&lt;/CODE&gt; integer &lt;VAR&gt;netlong&lt;/VAR&gt; from
         network byte order to host byte order.
         &lt;br&gt;&lt;br&gt; This is used for IPv4 Internet addresses.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-protoent" type="struct">
    <structure>
        <synopsis>
        This data type is used to represent entries in the network protocols
         database.  It has the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="char *p_name">
            <synopsis>
            This is the official name of the protocol.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="char **p_aliases">
            <synopsis>
            These are alternate names for the protocol, specified as an array of
             strings.  The last element of the array is a null pointer.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-getprotobyname" type="function">
    <function returntype="struct protoent *">
      <prototype>
        <parameter content="const char *name"/>
      </prototype>
      <headers>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getprotobyname&lt;/CODE&gt; function returns information about the
         network protocol named &lt;VAR&gt;name&lt;/VAR&gt;.  If there is no such protocol, it
         returns a null pointer.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getprotobynumber" type="function">
    <function returntype="struct protoent *">
      <prototype>
        <parameter content="int protocol"/>
      </prototype>
      <headers>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getprotobynumber&lt;/CODE&gt; function returns information about the
         network protocol with number &lt;VAR&gt;protocol&lt;/VAR&gt;.  If there is no such
         protocol, it returns a null pointer.
        </synopsis>
    </function>
  </construct>
  <construct id="function-setprotoent" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="int stayopen"/>
      </prototype>
      <headers>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        This function opens the protocols database to begin scanning it.
         &lt;br&gt;&lt;br&gt; If the &lt;VAR&gt;stayopen&lt;/VAR&gt; argument is nonzero, this sets a flag so that
         subsequent calls to &lt;CODE&gt;getprotobyname&lt;/CODE&gt; or &lt;CODE&gt;getprotobynumber&lt;/CODE&gt; will
         not close the database (as they usually would).  This makes for more
         efficiency if you call those functions several times, by avoiding
         reopening the database for each call.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getprotoent" type="function">
    <function returntype="struct protoent *">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        This function returns the next entry in the protocols database.  It
         returns a null pointer if there are no more entries.
        </synopsis>
    </function>
  </construct>
  <construct id="function-endprotoent" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        This function closes the protocols database.
        </synopsis>
    </function>
  </construct>
  <construct id="function-socket" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int namespace"/>
        <parameter content="int style"/>
        <parameter content="int protocol"/>
      </prototype>
      <headers>
        <header filename = "sys/socket.h"/>
      </headers>
        <synopsis>
        This function creates a socket and specifies communication style
         &lt;VAR&gt;style&lt;/VAR&gt;, which should be one of the socket styles listed in
         Communication Styles.  The &lt;VAR&gt;namespace&lt;/VAR&gt; argument specifies
         the namespace; it must be &lt;CODE&gt;PF_LOCAL&lt;/CODE&gt;  or
         &lt;CODE&gt;PF_INET&lt;/CODE&gt; .  &lt;VAR&gt;protocol&lt;/VAR&gt;
         designates the specific protocol ; zero is
         usually right for &lt;VAR&gt;protocol&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The return value from &lt;CODE&gt;socket&lt;/CODE&gt; is the file descriptor for the new
         socket, or &lt;CODE&gt;-1&lt;/CODE&gt; in case of error.  The following &lt;CODE&gt;errno&lt;/CODE&gt; error
         conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EPROTONOSUPPORT&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;protocol&lt;/VAR&gt; or &lt;VAR&gt;style&lt;/VAR&gt; is not supported by the
         &lt;VAR&gt;namespace&lt;/VAR&gt; specified.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EMFILE
         The process already has too many file descriptors open.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENFILE
         The system already has too many file descriptors open.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EACCES
         The process does not have the privilege to create a socket of the specified
         &lt;VAR&gt;style&lt;/VAR&gt; or &lt;VAR&gt;protocol&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOBUFS
         The system ran out of internal buffer space.

         &lt;br&gt;&lt;br&gt; The file descriptor returned by the &lt;CODE&gt;socket&lt;/CODE&gt; function supports both
         read and write operations.  However, like pipes, sockets do not support file
         positioning operations.
        </synopsis>
    </function>
  </construct>
  <construct id="function-shutdown" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int socket"/>
        <parameter content="int how"/>
      </prototype>
      <headers>
        <header filename = "sys/socket.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;shutdown&lt;/CODE&gt; function shuts down the connection of socket
         &lt;VAR&gt;socket&lt;/VAR&gt;.  The argument &lt;VAR&gt;how&lt;/VAR&gt; specifies what action to
         perform:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;0&lt;/CODE&gt;
&lt;DD&gt;
         Stop receiving data for this socket.  If further data arrives,
         reject it.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;1&lt;/CODE&gt;
&lt;DD&gt;
         Stop trying to transmit data from this socket.  Discard any data
         waiting to be sent.  Stop looking for acknowledgement of data already
         sent; don't retransmit it if it is lost.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; 2
         Stop both reception and transmission.

         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; on success and &lt;CODE&gt;-1&lt;/CODE&gt; on failure.  The
         following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;LI&gt; EBADF
         &lt;VAR&gt;socket&lt;/VAR&gt; is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOTSOCK
         &lt;VAR&gt;socket&lt;/VAR&gt; is not a socket.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOTCONN
         &lt;VAR&gt;socket&lt;/VAR&gt; is not connected.

        </synopsis>
    </function>
  </construct>
  <construct id="function-socketpair" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int namespace"/>
        <parameter content="int style"/>
        <parameter content="int protocol"/>
        <parameter content="int filedes[2]"/>
      </prototype>
      <headers>
        <header filename = "sys/socket.h"/>
      </headers>
        <synopsis>
        This function creates a socket pair, returning the file descriptors in
         &lt;CODE&gt;&lt;VAR&gt;filedes&lt;/VAR&gt;[0]&lt;/CODE&gt; and &lt;CODE&gt;&lt;VAR&gt;filedes&lt;/VAR&gt;[1]&lt;/CODE&gt;.  The socket pair
         is a full-duplex communications channel, so that both reading and writing
         may be performed at either end.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;namespace&lt;/VAR&gt;, &lt;VAR&gt;style&lt;/VAR&gt; and &lt;VAR&gt;protocol&lt;/VAR&gt; arguments are
         interpreted as for the &lt;CODE&gt;socket&lt;/CODE&gt; function.  &lt;VAR&gt;style&lt;/VAR&gt; should be
         one of the communication styles listed in Communication Styles.
         The &lt;VAR&gt;namespace&lt;/VAR&gt; argument specifies the namespace, which must be
         &lt;CODE&gt;AF_LOCAL&lt;/CODE&gt; ; &lt;VAR&gt;protocol&lt;/VAR&gt; specifies the
         communications protocol, but zero is the only meaningful value.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;style&lt;/VAR&gt; specifies a connectionless communication style, then
         the two sockets you get are not &lt;EM&gt;connected&lt;/EM&gt;, strictly speaking,
         but each of them knows the other as the default destination address,
         so they can send packets to each other.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;socketpair&lt;/CODE&gt; function returns &lt;CODE&gt;0&lt;/CODE&gt; on success and &lt;CODE&gt;-1&lt;/CODE&gt;
         on failure.  The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined
         for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EMFILE&lt;/CODE&gt;
&lt;DD&gt;
         The process has too many file descriptors open.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EAFNOSUPPORT
         The specified namespace is not supported.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EPROTONOSUPPORT
         The specified protocol is not supported.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EOPNOTSUPP
         The specified protocol does not support the creation of socket pairs.

        </synopsis>
    </function>
  </construct>
  <construct id="function-connect" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int socket"/>
        <parameter content="struct sockaddr *addr"/>
        <parameter content="socklen_t length"/>
      </prototype>
      <headers>
        <header filename = "sys/socket.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;connect&lt;/CODE&gt; function initiates a connection from the socket
         with file descriptor &lt;VAR&gt;socket&lt;/VAR&gt; to the socket whose address is
         specified by the &lt;VAR&gt;addr&lt;/VAR&gt; and &lt;VAR&gt;length&lt;/VAR&gt; arguments.  (This socket
         is typically on another machine, and it must be already set up as a
         server.)  , for information about how these
         arguments are interpreted.
         &lt;br&gt;&lt;br&gt; Normally, &lt;CODE&gt;connect&lt;/CODE&gt; waits until the server responds to the request
         before it returns.  You can set nonblocking mode on the socket
         &lt;VAR&gt;socket&lt;/VAR&gt; to make &lt;CODE&gt;connect&lt;/CODE&gt; return immediately without waiting
         for the response.  , for information about
         nonblocking mode.
         &lt;br&gt;&lt;br&gt; The normal return value from &lt;CODE&gt;connect&lt;/CODE&gt; is &lt;CODE&gt;0&lt;/CODE&gt;.  If an error
         occurs, &lt;CODE&gt;connect&lt;/CODE&gt; returns &lt;CODE&gt;-1&lt;/CODE&gt;.  The following &lt;CODE&gt;errno&lt;/CODE&gt;
         error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The socket &lt;VAR&gt;socket&lt;/VAR&gt; is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOTSOCK
         File descriptor &lt;VAR&gt;socket&lt;/VAR&gt; is not a socket.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EADDRNOTAVAIL
         The specified address is not available on the remote machine.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EAFNOSUPPORT
         The namespace of the &lt;VAR&gt;addr&lt;/VAR&gt; is not supported by this socket.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EISCONN
         The socket &lt;VAR&gt;socket&lt;/VAR&gt; is already connected.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ETIMEDOUT
         The attempt to establish the connection timed out.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ECONNREFUSED
         The server has actively refused to establish the connection.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENETUNREACH
         The network of the given &lt;VAR&gt;addr&lt;/VAR&gt; isn't reachable from this host.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EADDRINUSE
         The socket address of the given &lt;VAR&gt;addr&lt;/VAR&gt; is already in use.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINPROGRESS
         The socket &lt;VAR&gt;socket&lt;/VAR&gt; is non-blocking and the connection could not be
         established immediately.  You can determine when the connection is
         completely established with &lt;CODE&gt;select&lt;/CODE&gt;; .
         Another &lt;CODE&gt;connect&lt;/CODE&gt; call on the same socket, before the connection is
         completely established, will fail with &lt;CODE&gt;EALREADY&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EALREADY
         The socket &lt;VAR&gt;socket&lt;/VAR&gt; is non-blocking and already has a pending
         connection in progress (see &lt;CODE&gt;EINPROGRESS&lt;/CODE&gt; above).

         &lt;br&gt;&lt;br&gt; This function is defined as a cancellation point in multi-threaded
         programs, so one has to be prepared for this and make sure that
         allocated resources (like memory, files descriptors, semaphores or
         whatever) are freed even if the thread is canceled.
        </synopsis>
    </function>
  </construct>
  <construct id="function-listen" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int socket"/>
        <parameter content="int n"/>
      </prototype>
      <headers>
        <header filename = "sys/socket.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;listen&lt;/CODE&gt; function enables the socket &lt;VAR&gt;socket&lt;/VAR&gt; to accept
         connections, thus making it a server socket.
         &lt;br&gt;&lt;br&gt; The argument &lt;VAR&gt;n&lt;/VAR&gt; specifies the length of the queue for pending
         connections.  When the queue fills, new clients attempting to connect
         fail with &lt;CODE&gt;ECONNREFUSED&lt;/CODE&gt; until the server calls &lt;CODE&gt;accept&lt;/CODE&gt; to
         accept a connection from the queue.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;listen&lt;/CODE&gt; function returns &lt;CODE&gt;0&lt;/CODE&gt; on success and &lt;CODE&gt;-1&lt;/CODE&gt;
         on failure.  The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined
         for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The argument &lt;VAR&gt;socket&lt;/VAR&gt; is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOTSOCK
         The argument &lt;VAR&gt;socket&lt;/VAR&gt; is not a socket.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EOPNOTSUPP
         The socket &lt;VAR&gt;socket&lt;/VAR&gt; does not support this operation.

        </synopsis>
    </function>
  </construct>
  <construct id="function-accept" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int socket"/>
        <parameter content="struct sockaddr *addr"/>
        <parameter content="socklen_t *length_ptr"/>
      </prototype>
      <headers>
        <header filename = "sys/socket.h"/>
      </headers>
        <synopsis>
        This function is used to accept a connection request on the server
         socket &lt;VAR&gt;socket&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;accept&lt;/CODE&gt; function waits if there are no connections pending,
         unless the socket &lt;VAR&gt;socket&lt;/VAR&gt; has nonblocking mode set.  (You can use
         &lt;CODE&gt;select&lt;/CODE&gt; to wait for a pending connection, with a nonblocking
         socket.)  , for information about nonblocking
         mode.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;addr&lt;/VAR&gt; and &lt;VAR&gt;length-ptr&lt;/VAR&gt; arguments are used to return
         information about the name of the client socket that initiated the
         connection.  , for information about the format
         of the information.
         &lt;br&gt;&lt;br&gt; Accepting a connection does not make &lt;VAR&gt;socket&lt;/VAR&gt; part of the
         connection.  Instead, it creates a new socket which becomes
         connected.  The normal return value of &lt;CODE&gt;accept&lt;/CODE&gt; is the file
         descriptor for the new socket.
         &lt;br&gt;&lt;br&gt; After &lt;CODE&gt;accept&lt;/CODE&gt;, the original socket &lt;VAR&gt;socket&lt;/VAR&gt; remains open and
         unconnected, and continues listening until you close it.  You can
         accept further connections with &lt;VAR&gt;socket&lt;/VAR&gt; by calling &lt;CODE&gt;accept&lt;/CODE&gt;
         again.
         &lt;br&gt;&lt;br&gt; If an error occurs, &lt;CODE&gt;accept&lt;/CODE&gt; returns &lt;CODE&gt;-1&lt;/CODE&gt;.  The following
         &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;socket&lt;/VAR&gt; argument is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOTSOCK
         The descriptor &lt;VAR&gt;socket&lt;/VAR&gt; argument is not a socket.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EOPNOTSUPP
         The descriptor &lt;VAR&gt;socket&lt;/VAR&gt; does not support this operation.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EWOULDBLOCK
         &lt;VAR&gt;socket&lt;/VAR&gt; has nonblocking mode set, and there are no pending
         connections immediately available.

         &lt;br&gt;&lt;br&gt; This function is defined as a cancellation point in multi-threaded
         programs, so one has to be prepared for this and make sure that
         allocated resources (like memory, files descriptors, semaphores or
         whatever) are freed even if the thread is canceled.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getpeername" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int socket"/>
        <parameter content="struct sockaddr *addr"/>
        <parameter content="socklen_t *length-ptr"/>
      </prototype>
      <headers>
        <header filename = "sys/socket.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getpeername&lt;/CODE&gt; function returns the address of the socket that
         &lt;VAR&gt;socket&lt;/VAR&gt; is connected to; it stores the address in the memory space
         specified by &lt;VAR&gt;addr&lt;/VAR&gt; and &lt;VAR&gt;length-ptr&lt;/VAR&gt;.  It stores the length of
         the address in &lt;CODE&gt;*&lt;VAR&gt;length-ptr&lt;/VAR&gt;&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; , for information about the format of the
         address.  In some operating systems, &lt;CODE&gt;getpeername&lt;/CODE&gt; works only for
         sockets in the Internet domain.
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; on success and &lt;CODE&gt;-1&lt;/CODE&gt; on error.  The
         following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The argument &lt;VAR&gt;socket&lt;/VAR&gt; is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOTSOCK
         The descriptor &lt;VAR&gt;socket&lt;/VAR&gt; is not a socket.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOTCONN
         The socket &lt;VAR&gt;socket&lt;/VAR&gt; is not connected.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOBUFS
         There are not enough internal buffers available.

        </synopsis>
    </function>
  </construct>
  <construct id="function-send" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int socket"/>
        <parameter content="void *buffer"/>
        <parameter content="size_t size"/>
        <parameter content="int flags"/>
      </prototype>
      <headers>
        <header filename = "sys/socket.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;send&lt;/CODE&gt; function is like &lt;CODE&gt;write&lt;/CODE&gt;, but with the additional
         flags &lt;VAR&gt;flags&lt;/VAR&gt;.  The possible values of &lt;VAR&gt;flags&lt;/VAR&gt; are described
         in Socket Data Options.
         &lt;br&gt;&lt;br&gt; This function returns the number of bytes transmitted, or &lt;CODE&gt;-1&lt;/CODE&gt; on
         failure.  If the socket is nonblocking, then &lt;CODE&gt;send&lt;/CODE&gt; (like
         &lt;CODE&gt;write&lt;/CODE&gt;) can return after sending just part of the data.
         , for information about nonblocking mode.
         &lt;br&gt;&lt;br&gt; Note, however, that a successful return value merely indicates that
         the message has been sent without error, not necessarily that it has
         been received without error.
         &lt;br&gt;&lt;br&gt; The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;socket&lt;/VAR&gt; argument is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINTR
         The operation was interrupted by a signal before any data was sent.
         .
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOTSOCK
         The descriptor &lt;VAR&gt;socket&lt;/VAR&gt; is not a socket.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EMSGSIZE
         The socket type requires that the message be sent atomically, but the
         message is too large for this to be possible.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EWOULDBLOCK
         Nonblocking mode has been set on the socket, and the write operation
         would block.  (Normally &lt;CODE&gt;send&lt;/CODE&gt; blocks until the operation can be
         completed.)
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOBUFS
         There is not enough internal buffer space available.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOTCONN
         You never connected this socket.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EPIPE
         This socket was connected but the connection is now broken.  In this
         case, &lt;CODE&gt;send&lt;/CODE&gt; generates a &lt;CODE&gt;SIGPIPE&lt;/CODE&gt; signal first; if that
         signal is ignored or blocked, or if its handler returns, then
         &lt;CODE&gt;send&lt;/CODE&gt; fails with &lt;CODE&gt;EPIPE&lt;/CODE&gt;.

         &lt;br&gt;&lt;br&gt; This function is defined as a cancellation point in multi-threaded
         programs, so one has to be prepared for this and make sure that
         allocated resources (like memory, files descriptors, semaphores or
         whatever) are freed even if the thread is canceled.
        </synopsis>
    </function>
  </construct>
  <construct id="function-recv" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int socket"/>
        <parameter content="void *buffer"/>
        <parameter content="size_t size"/>
        <parameter content="int flags"/>
      </prototype>
      <headers>
        <header filename = "sys/socket.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;recv&lt;/CODE&gt; function is like &lt;CODE&gt;read&lt;/CODE&gt;, but with the additional
         flags &lt;VAR&gt;flags&lt;/VAR&gt;.  The possible values of &lt;VAR&gt;flags&lt;/VAR&gt; are described
         in Socket Data Options.
         &lt;br&gt;&lt;br&gt; If nonblocking mode is set for &lt;VAR&gt;socket&lt;/VAR&gt;, and no data are available to
         be read, &lt;CODE&gt;recv&lt;/CODE&gt; fails immediately rather than waiting.  , for information about nonblocking mode.
         &lt;br&gt;&lt;br&gt; This function returns the number of bytes received, or &lt;CODE&gt;-1&lt;/CODE&gt; on failure.
         The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;socket&lt;/VAR&gt; argument is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOTSOCK
         The descriptor &lt;VAR&gt;socket&lt;/VAR&gt; is not a socket.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EWOULDBLOCK
         Nonblocking mode has been set on the socket, and the read operation
         would block.  (Normally, &lt;CODE&gt;recv&lt;/CODE&gt; blocks until there is input
         available to be read.)
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINTR
         The operation was interrupted by a signal before any data was read.
         .
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOTCONN
         You never connected this socket.

         &lt;br&gt;&lt;br&gt; This function is defined as a cancellation point in multi-threaded
         programs, so one has to be prepared for this and make sure that
         allocated resources (like memory, files descriptors, semaphores or
         whatever) are freed even if the thread is canceled.
        </synopsis>
    </function>
  </construct>
  <construct id="function-sendto" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int socket"/>
        <parameter content="void *buffer. size_t size"/>
        <parameter content="int flags"/>
        <parameter content="struct sockaddr *addr"/>
        <parameter content="socklen_t length"/>
      </prototype>
      <headers>
        <header filename = "sys/socket.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;sendto&lt;/CODE&gt; function transmits the data in the &lt;VAR&gt;buffer&lt;/VAR&gt;
         through the socket &lt;VAR&gt;socket&lt;/VAR&gt; to the destination address specified
         by the &lt;VAR&gt;addr&lt;/VAR&gt; and &lt;VAR&gt;length&lt;/VAR&gt; arguments.  The &lt;VAR&gt;size&lt;/VAR&gt; argument
         specifies the number of bytes to be transmitted.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;flags&lt;/VAR&gt; are interpreted the same way as for &lt;CODE&gt;send&lt;/CODE&gt;; see
         Socket Data Options.
         &lt;br&gt;&lt;br&gt; The return value and error conditions are also the same as for
         &lt;CODE&gt;send&lt;/CODE&gt;, but you cannot rely on the system to detect errors and
         report them; the most common error is that the packet is lost or there
         is no-one at the specified address to receive it, and the operating
         system on your machine usually does not know this.
         &lt;br&gt;&lt;br&gt; It is also possible for one call to &lt;CODE&gt;sendto&lt;/CODE&gt; to report an error
         owing to a problem related to a previous call.
         &lt;br&gt;&lt;br&gt; This function is defined as a cancellation point in multi-threaded
         programs, so one has to be prepared for this and make sure that
         allocated resources (like memory, files descriptors, semaphores or
         whatever) are freed even if the thread is canceled.
        </synopsis>
    </function>
  </construct>
  <construct id="function-recvfrom" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int socket"/>
        <parameter content="void *buffer"/>
        <parameter content="size_t size"/>
        <parameter content="int flags"/>
        <parameter content="struct sockaddr *addr"/>
        <parameter content="socklen_t *length-ptr"/>
      </prototype>
      <headers>
        <header filename = "sys/socket.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;recvfrom&lt;/CODE&gt; function reads one packet from the socket
         &lt;VAR&gt;socket&lt;/VAR&gt; into the buffer &lt;VAR&gt;buffer&lt;/VAR&gt;.  The &lt;VAR&gt;size&lt;/VAR&gt; argument
         specifies the maximum number of bytes to be read.
         &lt;br&gt;&lt;br&gt; If the packet is longer than &lt;VAR&gt;size&lt;/VAR&gt; bytes, then you get the first
         &lt;VAR&gt;size&lt;/VAR&gt; bytes of the packet and the rest of the packet is lost.
         There's no way to read the rest of the packet.  Thus, when you use a
         packet protocol, you must always know how long a packet to expect.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;addr&lt;/VAR&gt; and &lt;VAR&gt;length-ptr&lt;/VAR&gt; arguments are used to return the
         address where the packet came from.  .  For a
         socket in the local domain the address information won't be meaningful,
         since you can't read the address of such a socket. You can specify a null pointer as the &lt;VAR&gt;addr&lt;/VAR&gt; argument
         if you are not interested in this information.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;flags&lt;/VAR&gt; are interpreted the same way as for &lt;CODE&gt;recv&lt;/CODE&gt;
         .  The return value and error conditions
         are also the same as for &lt;CODE&gt;recv&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This function is defined as a cancellation point in multi-threaded
         programs, so one has to be prepared for this and make sure that
         allocated resources (like memory, files descriptors, semaphores or
         whatever) are freed even if the thread is canceled.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-msghdr" type="struct">
    <structure>
    </structure>
  </construct>
  <construct id="function-sendmsg" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int socket"/>
        <parameter content="const struct msghdr *message"/>
        <parameter content="int flags"/>
      </prototype>
      <headers>
        <header filename = "sys/socket.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; This function is defined as a cancellation point in multi-threaded
         programs, so one has to be prepared for this and make sure that
         allocated resources (like memory, files descriptors, semaphores or
         whatever) are freed even if the thread is cancel.
        </synopsis>
    </function>
  </construct>
  <construct id="function-recvmsg" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int socket"/>
        <parameter content="struct msghdr *message"/>
        <parameter content="int flags"/>
      </prototype>
      <headers>
        <header filename = "sys/socket.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; This function is defined as a cancellation point in multi-threaded
         programs, so one has to be prepared for this and make sure that
         allocated resources (like memory, files descriptors, semaphores or
         whatever) are freed even if the thread is canceled.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getsockopt" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int socket"/>
        <parameter content="int level"/>
        <parameter content="int optname"/>
        <parameter content="void *optval"/>
        <parameter content="socklen_t *optlen-ptr"/>
      </prototype>
      <headers>
        <header filename = "sys/socket.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getsockopt&lt;/CODE&gt; function gets information about the value of
         option &lt;VAR&gt;optname&lt;/VAR&gt; at level &lt;VAR&gt;level&lt;/VAR&gt; for socket &lt;VAR&gt;socket&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The option value is stored in a buffer that &lt;VAR&gt;optval&lt;/VAR&gt; points to.
         Before the call, you should supply in &lt;CODE&gt;*&lt;VAR&gt;optlen-ptr&lt;/VAR&gt;&lt;/CODE&gt; the
         size of this buffer; on return, it contains the number of bytes of
         information actually stored in the buffer.
         &lt;br&gt;&lt;br&gt; Most options interpret the &lt;VAR&gt;optval&lt;/VAR&gt; buffer as a single &lt;CODE&gt;int&lt;/CODE&gt;
         value.
         &lt;br&gt;&lt;br&gt; The actual return value of &lt;CODE&gt;getsockopt&lt;/CODE&gt; is &lt;CODE&gt;0&lt;/CODE&gt; on success
         and &lt;CODE&gt;-1&lt;/CODE&gt; on failure.  The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions
         are defined:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;socket&lt;/VAR&gt; argument is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOTSOCK
         The descriptor &lt;VAR&gt;socket&lt;/VAR&gt; is not a socket.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOPROTOOPT
         The &lt;VAR&gt;optname&lt;/VAR&gt; doesn't make sense for the given &lt;VAR&gt;level&lt;/VAR&gt;.

        </synopsis>
    </function>
  </construct>
  <construct id="function-setsockopt" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int socket"/>
        <parameter content="int level"/>
        <parameter content="int optname"/>
        <parameter content="void *optval"/>
        <parameter content="socklen_t optlen"/>
      </prototype>
      <headers>
        <header filename = "sys/socket.h"/>
      </headers>
        <synopsis>
        This function is used to set the socket option &lt;VAR&gt;optname&lt;/VAR&gt; at level
         &lt;VAR&gt;level&lt;/VAR&gt; for socket &lt;VAR&gt;socket&lt;/VAR&gt;.  The value of the option is passed
         in the buffer &lt;VAR&gt;optval&lt;/VAR&gt; of size &lt;VAR&gt;optlen&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt;

         The return value and error codes for &lt;CODE&gt;setsockopt&lt;/CODE&gt; are the same as
         for &lt;CODE&gt;getsockopt&lt;/CODE&gt;.

         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="struct-linger" type="struct">
    <structure>
        <synopsis>
        This structure type has the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="int l_onoff">
            <synopsis>
            This field is interpreted as a boolean.  If nonzero, &lt;CODE&gt;close&lt;/CODE&gt;
             blocks until the data are transmitted or the timeout period has expired.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="struct-netent" type="struct">
    <structure>
        <synopsis>
        This data type is used to represent information about entries in the
         networks database.  It has the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="char *n_name">
            <synopsis>
            This is the ``official'' name of the network.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="char **n_aliases">
            <synopsis>
            These are alternative names for the network, represented as a vector
             of strings.  A null pointer terminates the array.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int n_addrtype">
            <synopsis>
            This is the type of the network number; this is always equal to
             &lt;CODE&gt;AF_INET&lt;/CODE&gt; for Internet networks.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-getnetbyname" type="function">
    <function returntype="struct netent *">
      <prototype>
        <parameter content="const char *name"/>
      </prototype>
      <headers>
        <header filename = "sys/socket.h"/>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getnetbyname&lt;/CODE&gt; function returns information about the network
         named &lt;VAR&gt;name&lt;/VAR&gt;.  It returns a null pointer if there is no such
         network.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getnetbyaddr" type="function">
    <function returntype="struct netent *">
      <prototype>
        <parameter content="unsigned long int net"/>
        <parameter content="int type"/>
      </prototype>
      <headers>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getnetbyaddr&lt;/CODE&gt; function returns information about the network
         of type &lt;VAR&gt;type&lt;/VAR&gt; with number &lt;VAR&gt;net&lt;/VAR&gt;.  You should specify a value of
         &lt;CODE&gt;AF_INET&lt;/CODE&gt; for the &lt;VAR&gt;type&lt;/VAR&gt; argument for Internet networks.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;getnetbyaddr&lt;/CODE&gt; returns a null pointer if there is no such
         network.
        </synopsis>
    </function>
  </construct>
  <construct id="function-setnetent" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="int stayopen"/>
      </prototype>
      <headers>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        This function opens and rewinds the networks database.
         &lt;br&gt;&lt;br&gt; If the &lt;VAR&gt;stayopen&lt;/VAR&gt; argument is nonzero, this sets a flag so that
         subsequent calls to &lt;CODE&gt;getnetbyname&lt;/CODE&gt; or &lt;CODE&gt;getnetbyaddr&lt;/CODE&gt; will
         not close the database (as they usually would).  This makes for more
         efficiency if you call those functions several times, by avoiding
         reopening the database for each call.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getnetent" type="function">
    <function returntype="struct netent *">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        This function returns the next entry in the networks database.  It
         returns a null pointer if there are no more entries.
        </synopsis>
    </function>
  </construct>
  <construct id="function-endnetent" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "netdb.h"/>
      </headers>
        <synopsis>
        This function closes the networks database.
        </synopsis>
    </function>
  </construct>
  <construct id="function-difftime" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="time_t time1"/>
        <parameter content="time_t time0"/>
      </prototype>
      <headers>
        <header filename = "time.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;difftime&lt;/CODE&gt; function returns the number of seconds of elapsed
         time between calendar time &lt;VAR&gt;time1&lt;/VAR&gt; and calendar time &lt;VAR&gt;time0&lt;/VAR&gt;, as
         a value of type &lt;CODE&gt;double&lt;/CODE&gt;.  The difference ignores leap seconds
         unless leap second support is enabled.
         &lt;br&gt;&lt;br&gt; In the GNU system, you can simply subtract &lt;CODE&gt;time_t&lt;/CODE&gt; values.  But on
         other systems, the &lt;CODE&gt;time_t&lt;/CODE&gt; data type might use some other encoding
         where subtraction doesn't work directly.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-timeval" type="struct">
    <structure>
        <synopsis>

         The &lt;CODE&gt;struct timeval&lt;/CODE&gt; structure represents an elapsed time.  It is
         declared in &lt;TT&gt;sys/time.h&lt;/TT&gt; and has the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="long int tv_sec">
            <synopsis>
            This represents the number of whole seconds of elapsed time.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="struct-timespec" type="struct">
    <structure>
        <synopsis>

         The &lt;CODE&gt;struct timespec&lt;/CODE&gt; structure represents an elapsed time.  It is
         declared in &lt;TT&gt;time.h&lt;/TT&gt; and has the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="long int tv_sec">
            <synopsis>
            This represents the number of whole seconds of elapsed time.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="dtype-clock_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="function-clock" type="function">
    <function returntype="clock_t">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "sys/time.h"/>
        <header filename = "time.h"/>
      </headers>
        <synopsis>
        This function returns the calling process' current CPU time.  If the CPU
         time is not available or cannot be represented, &lt;CODE&gt;clock&lt;/CODE&gt; returns the
         value &lt;CODE&gt;(clock_t)(-1)&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-tms" type="struct">
    <structure>
        <synopsis>
        The &lt;CODE&gt;tms&lt;/CODE&gt; structure is used to return information about process
         times.  It contains at least the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="clock_t tms_utime">
            <synopsis>
            This is the total processor time the calling process has used in
             executing the instructions of its program.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="clock_t tms_stime">
            <synopsis>
            This is the processor time the system has used on behalf of the calling
             process.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="clock_t tms_cutime">
            <synopsis>
            This is the sum of the &lt;CODE&gt;tms_utime&lt;/CODE&gt; values and the &lt;CODE&gt;tms_cutime&lt;/CODE&gt;
             values of all terminated child processes of the calling process, whose
             status has been reported to the parent process by &lt;CODE&gt;wait&lt;/CODE&gt; or
             &lt;CODE&gt;waitpid&lt;/CODE&gt;; see Process Completion.  In other words, it
             represents the total processor time used in executing the instructions
             of all the terminated child processes of the calling process, excluding
             child processes which have not yet been reported by &lt;CODE&gt;wait&lt;/CODE&gt; or
             &lt;CODE&gt;waitpid&lt;/CODE&gt;.
              process
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-times" type="function">
    <function returntype="clock_t">
      <prototype>
        <parameter content="struct tms *buffer"/>
      </prototype>
      <headers>
        <header filename = "sys/times.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;times&lt;/CODE&gt; function stores the processor time information for
         the calling process in &lt;VAR&gt;buffer&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The return value is the calling process' CPU time (the same value you
         get from &lt;CODE&gt;clock()&lt;/CODE&gt;.  &lt;CODE&gt;times&lt;/CODE&gt; returns &lt;CODE&gt;(clock_t)(-1)&lt;/CODE&gt; to
         indicate failure.
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-time_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="function-time" type="function">
    <function returntype="time_t">
      <prototype>
        <parameter content="time_t *result"/>
      </prototype>
      <headers>
        <header filename = "time.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;time&lt;/CODE&gt; function returns the current calendar time as a value of
         type &lt;CODE&gt;time_t&lt;/CODE&gt;.  If the argument &lt;VAR&gt;result&lt;/VAR&gt; is not a null pointer,
         the calendar time value is also stored in &lt;CODE&gt;*&lt;VAR&gt;result&lt;/VAR&gt;&lt;/CODE&gt;.  If the
         current calendar time is not available, the value
         &lt;CODE&gt;(time_t)(-1)&lt;/CODE&gt; is returned.
        </synopsis>
    </function>
  </construct>
  <construct id="function-stime" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="time_t *newtime"/>
      </prototype>
      <headers>
        <header filename = "time.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;stime&lt;/CODE&gt; sets the system clock, i.e., it tells the system that the
         current calendar time is &lt;VAR&gt;newtime&lt;/VAR&gt;, where &lt;CODE&gt;newtime&lt;/CODE&gt; is
         interpreted as described in the above definition of &lt;CODE&gt;time_t&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;settimeofday&lt;/CODE&gt; is a newer function which sets the system clock to
         better than one second precision.  &lt;CODE&gt;settimeofday&lt;/CODE&gt; is generally a
         better choice than &lt;CODE&gt;stime&lt;/CODE&gt;.  .
         &lt;br&gt;&lt;br&gt; Only the superuser can set the system clock.
         &lt;br&gt;&lt;br&gt; If the function succeeds, the return value is zero.  Otherwise, it is
         &lt;CODE&gt;-1&lt;/CODE&gt; and &lt;CODE&gt;errno&lt;/CODE&gt; is set accordingly:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EPERM&lt;/CODE&gt;
&lt;DD&gt;
         The process is not superuser.

        </synopsis>
    </function>
  </construct>
  <construct id="struct-timezone" type="struct">
    <structure>
        <synopsis>
        The &lt;CODE&gt;struct timezone&lt;/CODE&gt; structure is used to hold minimal information
         about the local time zone.  It has the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="int tz_minuteswest">
            <synopsis>
            This is the number of minutes west of UTC.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-gettimeofday" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="struct timeval *tp"/>
        <parameter content="struct timezone *tzp"/>
      </prototype>
      <headers>
        <header filename = "sys/time.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;gettimeofday&lt;/CODE&gt; function returns the current calendar time as
         the elapsed time since the epoch in the &lt;CODE&gt;struct timeval&lt;/CODE&gt; structure
         indicated by &lt;VAR&gt;tp&lt;/VAR&gt;.  ( for a description of
         &lt;CODE&gt;struct timeval&lt;/CODE&gt;).  Information about the time zone is returned in
         the structure pointed at &lt;VAR&gt;tzp&lt;/VAR&gt;.  If the &lt;VAR&gt;tzp&lt;/VAR&gt; argument is a null
         pointer, time zone information is ignored.
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; on success and &lt;CODE&gt;-1&lt;/CODE&gt; on failure.  The
         following &lt;CODE&gt;errno&lt;/CODE&gt; error condition is defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;ENOSYS&lt;/CODE&gt;
&lt;DD&gt;
         The operating system does not support getting time zone information, and
         &lt;VAR&gt;tzp&lt;/VAR&gt; is not a null pointer.  The GNU operating system does not
         support using &lt;CODE&gt;struct timezone&lt;/CODE&gt; to represent time zone
         information; that is an obsolete feature of 4.3 BSD.
         Instead, use the facilities described in Time Zone Functions.

        </synopsis>
    </function>
  </construct>
  <construct id="function-settimeofday" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const struct timeval *tp"/>
        <parameter content="const struct timezone *tzp"/>
      </prototype>
      <headers>
        <header filename = "sys/time.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;settimeofday&lt;/CODE&gt; function sets the current calendar time in the
         system clock according to the arguments.  As for &lt;CODE&gt;gettimeofday&lt;/CODE&gt;,
         the calendar time is represented as the elapsed time since the epoch.
         As for &lt;CODE&gt;gettimeofday&lt;/CODE&gt;, time zone information is ignored if
         &lt;VAR&gt;tzp&lt;/VAR&gt; is a null pointer.
         &lt;br&gt;&lt;br&gt; You must be a privileged user in order to use &lt;CODE&gt;settimeofday&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; Some kernels automatically set the system clock from some source such as
         a hardware clock when they start up.  Others, including Linux, place the
         system clock in an ``invalid'' state (in which attempts to read the clock
         fail).  A call of &lt;CODE&gt;stime&lt;/CODE&gt; removes the system clock from an invalid
         state, and system startup scripts typically run a program that calls
         &lt;CODE&gt;stime&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;settimeofday&lt;/CODE&gt; causes a sudden jump forwards or backwards, which
         can cause a variety of problems in a system.  Use &lt;CODE&gt;adjtime&lt;/CODE&gt; (below)
         to make a smooth transition from one time to another by temporarily
         speeding up or slowing down the clock.
         &lt;br&gt;&lt;br&gt; With a Linux kernel, &lt;CODE&gt;adjtimex&lt;/CODE&gt; does the same thing and can also
         make permanent changes to the speed of the system clock so it doesn't
         need to be corrected as often.
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; on success and &lt;CODE&gt;-1&lt;/CODE&gt; on failure.  The
         following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EPERM&lt;/CODE&gt;
&lt;DD&gt;
         This process cannot set the clock because it is not privileged.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOSYS
         The operating system does not support setting time zone information, and
         &lt;VAR&gt;tzp&lt;/VAR&gt; is not a null pointer.

        </synopsis>
    </function>
  </construct>
  <construct id="function-adjtime" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const struct timeval *delta"/>
        <parameter content="struct timeval *olddelta"/>
      </prototype>
      <headers>
        <header filename = "sys/time.h"/>
      </headers>
        <synopsis>
        This function speeds up or slows down the system clock in order to make
         a gradual adjustment.  This ensures that the calendar time reported by
         the system clock is always monotonically increasing, which might not
         happen if you simply set the clock.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;delta&lt;/VAR&gt; argument specifies a relative adjustment to be made to
         the clock time.  If negative, the system clock is slowed down for a
         while until it has lost this much elapsed time.  If positive, the system
         clock is speeded up for a while.
         &lt;br&gt;&lt;br&gt; If the &lt;VAR&gt;olddelta&lt;/VAR&gt; argument is not a null pointer, the &lt;CODE&gt;adjtime&lt;/CODE&gt;
         function returns information about any previous time adjustment that
         has not yet completed.
         &lt;br&gt;&lt;br&gt; This function is typically used to synchronize the clocks of computers
         in a local network.  You must be a privileged user to use it.
         &lt;br&gt;&lt;br&gt; With a Linux kernel, you can use the &lt;CODE&gt;adjtimex&lt;/CODE&gt; function to
         permanently change the clock speed.
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; on success and &lt;CODE&gt;-1&lt;/CODE&gt; on failure.  The
         following &lt;CODE&gt;errno&lt;/CODE&gt; error condition is defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EPERM&lt;/CODE&gt;
&lt;DD&gt;
         You do not have privilege to set the time.

        </synopsis>
    </function>
  </construct>
  <construct id="function-adjtimex" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="struct timex *timex"/>
      </prototype>
      <headers>
        <header filename = "sys/timex.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; &lt;CODE&gt;adjtimex&lt;/CODE&gt; is functionally identical to &lt;CODE&gt;ntp_adjtime&lt;/CODE&gt;.
         .
         &lt;br&gt;&lt;br&gt; This function is present only with a Linux kernel.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="struct-tm" type="struct">
    <structure>
        <synopsis>
        This is the data type used to represent a broken-down time.  The structure
         contains at least the following members, which can appear in any order.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="int tm_sec">
            <synopsis>
            This is the number of full seconds since the top of the minute (normally
             in the range &lt;CODE&gt;0&lt;/CODE&gt; through &lt;CODE&gt;59&lt;/CODE&gt;, but the actual upper limit is
             &lt;CODE&gt;60&lt;/CODE&gt;, to allow for leap seconds if leap second support is
             available).
              second
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int tm_min">
            <synopsis>
            This is the number of full minutes since the top of the hour (in the
             range &lt;CODE&gt;0&lt;/CODE&gt; through &lt;CODE&gt;59&lt;/CODE&gt;).
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int tm_hour">
            <synopsis>
            This is the number of full hours past midnight (in the range &lt;CODE&gt;0&lt;/CODE&gt; through
             &lt;CODE&gt;23&lt;/CODE&gt;).
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int tm_mday">
            <synopsis>
            This is the ordinal day of the month (in the range &lt;CODE&gt;1&lt;/CODE&gt; through &lt;CODE&gt;31&lt;/CODE&gt;).
             Watch out for this one!  As the only ordinal number in the structure, it is
             inconsistent with the rest of the structure.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int tm_mon">
            <synopsis>
            This is the number of full calendar months since the beginning of the
             year (in the range &lt;CODE&gt;0&lt;/CODE&gt; through &lt;CODE&gt;11&lt;/CODE&gt;).  Watch out for this one!
             People usually use ordinal numbers for month-of-year (where January = 1).
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int tm_year">
            <synopsis>
            This is the number of full calendar years since 1900.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int tm_wday">
            <synopsis>
            This is the number of full days since Sunday (in the range &lt;CODE&gt;0&lt;/CODE&gt; through
             &lt;CODE&gt;6&lt;/CODE&gt;).
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int tm_yday">
            <synopsis>
            This is the number of full days since the beginning of the year (in the
             range &lt;CODE&gt;0&lt;/CODE&gt; through &lt;CODE&gt;365&lt;/CODE&gt;).
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int tm_isdst">
            <synopsis>
             Saving Time
              time
             This is a flag that indicates whether Daylight Saving Time is (or was, or
             will be) in effect at the time described.  The value is positive if
             Daylight Saving Time is in effect, zero if it is not, and negative if the
             information is not available.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int tm_gmtoff">
            <synopsis>
            This field describes the time zone that was used to compute this
             broken-down time value, including any adjustment for daylight saving; it
             is the number of seconds that you must add to UTC to get local time.
             You can also think of this as the number of seconds east of UTC.  For
             example, for U.S. Eastern Standard Time, the value is &lt;CODE&gt;-5*60*60&lt;/CODE&gt;.
             The &lt;CODE&gt;tm_gmtoff&lt;/CODE&gt; field is derived from BSD and is a GNU library
             extension; it is not visible in a strict ISO C environment.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-localtime" type="function">
    <function returntype="struct tm *">
      <prototype>
        <parameter content="const time_t *time"/>
      </prototype>
      <headers>
        <header filename = "time.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;localtime&lt;/CODE&gt; function converts the simple time pointed to by
         &lt;VAR&gt;time&lt;/VAR&gt; to broken-down time representation, expressed relative to the
         user's specified time zone.
         &lt;br&gt;&lt;br&gt; The return value is a pointer to a static broken-down time structure, which
         might be overwritten by subsequent calls to &lt;CODE&gt;ctime&lt;/CODE&gt;, &lt;CODE&gt;gmtime&lt;/CODE&gt;,
         or &lt;CODE&gt;localtime&lt;/CODE&gt;.  (But no other library function overwrites the contents
         of this object.)
         &lt;br&gt;&lt;br&gt; The return value is the null pointer if &lt;VAR&gt;time&lt;/VAR&gt; cannot be represented
         as a broken-down time; typically this is because the year cannot fit into
         an &lt;CODE&gt;int&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; Calling &lt;CODE&gt;localtime&lt;/CODE&gt; has one other effect: it sets the variable
         &lt;CODE&gt;tzname&lt;/CODE&gt; with information about the current time zone.  .
        </synopsis>
    </function>
  </construct>
  <construct id="function-localtime_r" type="function">
    <function returntype="struct tm *">
      <prototype>
        <parameter content="const time_t *time"/>
        <parameter content="struct tm *resultp"/>
      </prototype>
      <headers>
        <header filename = "time.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;localtime_r&lt;/CODE&gt; function works just like the &lt;CODE&gt;localtime&lt;/CODE&gt;
         function.  It takes a pointer to a variable containing a simple time
         and converts it to the broken-down time format.
         &lt;br&gt;&lt;br&gt; But the result is not placed in a static buffer.  Instead it is placed
         in the object of type &lt;CODE&gt;struct tm&lt;/CODE&gt; to which the parameter
         &lt;VAR&gt;resultp&lt;/VAR&gt; points.
         &lt;br&gt;&lt;br&gt; If the conversion is successful the function returns a pointer to the
         object the result was written into, i.e., it returns &lt;VAR&gt;resultp&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-gmtime" type="function">
    <function returntype="struct tm *">
      <prototype>
        <parameter content="const time_t *time"/>
      </prototype>
      <headers>
        <header filename = "time.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;localtime&lt;/CODE&gt;, except that the broken-down
         time is expressed as Coordinated Universal Time (UTC) (formerly called
         Greenwich Mean Time (GMT)) rather than relative to a local time zone.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-gmtime_r" type="function">
    <function returntype="struct tm *">
      <prototype>
        <parameter content="const time_t *time"/>
        <parameter content="struct tm *resultp"/>
      </prototype>
      <headers>
        <header filename = "time.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;localtime_r&lt;/CODE&gt;, except that it converts
         just like &lt;CODE&gt;gmtime&lt;/CODE&gt; the given time as Coordinated Universal Time.
         &lt;br&gt;&lt;br&gt; If the conversion is successful the function returns a pointer to the
         object the result was written into, i.e., it returns &lt;VAR&gt;resultp&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-mktime" type="function">
    <function returntype="time_t">
      <prototype>
        <parameter content="struct tm *brokentime"/>
      </prototype>
      <headers>
        <header filename = "time.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;mktime&lt;/CODE&gt; function is used to convert a broken-down time structure
         to a simple time representation.  It also ``normalizes'' the contents of
         the broken-down time structure, by filling in the day of week and day of
         year based on the other date and time components.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;mktime&lt;/CODE&gt; function ignores the specified contents of the
         &lt;CODE&gt;tm_wday&lt;/CODE&gt; and &lt;CODE&gt;tm_yday&lt;/CODE&gt; members of the broken-down time
         structure.  It uses the values of the other components to determine the
         calendar time; it's permissible for these components to have
         unnormalized values outside their normal ranges.  The last thing that
         &lt;CODE&gt;mktime&lt;/CODE&gt; does is adjust the components of the &lt;VAR&gt;brokentime&lt;/VAR&gt;
         structure (including the &lt;CODE&gt;tm_wday&lt;/CODE&gt; and &lt;CODE&gt;tm_yday&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; If the specified broken-down time cannot be represented as a simple time,
         &lt;CODE&gt;mktime&lt;/CODE&gt; returns a value of &lt;CODE&gt;(time_t)(-1)&lt;/CODE&gt; and does not modify
         the contents of &lt;VAR&gt;brokentime&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; Calling &lt;CODE&gt;mktime&lt;/CODE&gt; also sets the variable &lt;CODE&gt;tzname&lt;/CODE&gt; with
         information about the current time zone.  .
        </synopsis>
    </function>
  </construct>
  <construct id="function-timelocal" type="function">
    <function returntype="time_t">
      <prototype>
        <parameter content="struct tm *brokentime"/>
      </prototype>
      <headers>
        <header filename = "time.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; &lt;CODE&gt;timelocal&lt;/CODE&gt; is functionally identical to &lt;CODE&gt;mktime&lt;/CODE&gt;, but more
         mnemonically named.  Note that it is the inverse of the &lt;CODE&gt;localtime&lt;/CODE&gt;
         function.
         &lt;br&gt;&lt;br&gt; Portability note:  &lt;CODE&gt;mktime&lt;/CODE&gt; is essentially universally
         available.  &lt;CODE&gt;timelocal&lt;/CODE&gt; is rather rare.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-timegm" type="function">
    <function returntype="time_t">
      <prototype>
        <parameter content="struct tm *brokentime"/>
      </prototype>
      <headers>
        <header filename = "time.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; &lt;CODE&gt;timegm&lt;/CODE&gt; is functionally identical to &lt;CODE&gt;mktime&lt;/CODE&gt; except it
         always takes the input values to be Coordinated Universal Time (UTC)
         regardless of any local time zone setting.
         &lt;br&gt;&lt;br&gt; Note that &lt;CODE&gt;timegm&lt;/CODE&gt; is the inverse of &lt;CODE&gt;gmtime&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; Portability note:  &lt;CODE&gt;mktime&lt;/CODE&gt; is essentially universally
         available.  &lt;CODE&gt;timegm&lt;/CODE&gt; is rather rare.  For the most portable
         conversion from a UTC broken-down time to a simple time, set
         the &lt;CODE&gt;TZ&lt;/CODE&gt; environment variable to UTC, call &lt;CODE&gt;mktime&lt;/CODE&gt;, then set
         &lt;CODE&gt;TZ&lt;/CODE&gt; back.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="struct-ntptimeval" type="struct">
    <structure>
        <synopsis>
        This structure is used for information about the system clock.  It
         contains the following members:
        </synopsis>
      <elements>
        <element content="struct timeval time">
            <synopsis>
            This is the current calendar time, expressed as the elapsed time since
             the epoch.  The &lt;CODE&gt;struct timeval&lt;/CODE&gt; data type is described in
             Elapsed Time.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int maxerror">
            <synopsis>
            This is the maximum error, measured in microseconds.  Unless updated
             via &lt;CODE&gt;ntp_adjtime&lt;/CODE&gt; periodically, this value will reach some
             platform-specific maximum value.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-ntp_gettime" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="struct ntptimeval *tptr"/>
      </prototype>
      <headers>
        <header filename = "sys/timex.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;ntp_gettime&lt;/CODE&gt; function sets the structure pointed to by
         &lt;VAR&gt;tptr&lt;/VAR&gt; to current values.  The elements of the structure afterwards
         contain the values the timer implementation in the kernel assumes.  They
         might or might not be correct.  If they are not a &lt;CODE&gt;ntp_adjtime&lt;/CODE&gt;
         call is necessary.
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; on success and other values on failure.  The
         following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;TIME_ERROR&lt;/CODE&gt;
&lt;DD&gt;
         The precision clock model is not properly set up at the moment, thus the
         clock must be considered unsynchronized, and the values should be
         treated with care.

        </synopsis>
    </function>
  </construct>
  <construct id="struct-timex" type="struct">
    <structure>
        <synopsis>
        This structure is used to control and monitor the system clock.  It
         contains the following members:
        </synopsis>
      <elements>
        <element content="unsigned int modes">
            <synopsis>
            This variable controls whether and which values are set.  Several
             symbolic constants have to be combined with &lt;EM&gt;binary or&lt;/EM&gt; to specify
             the effective mode.  These constants start with &lt;CODE&gt;MOD_&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int offset">
            <synopsis>
            This value indicates the current offset of the system clock from the true
             calendar time.  The value is given in microseconds.  If bit
             &lt;CODE&gt;MOD_OFFSET&lt;/CODE&gt; is set in &lt;CODE&gt;modes&lt;/CODE&gt;, the offset (and possibly other
             dependent values) can be set.  The offset's absolute value must not
             exceed &lt;CODE&gt;MAXPHASE&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int frequency">
            <synopsis>
            This value indicates the difference in frequency between the true
             calendar time and the system clock.  The value is expressed as scaled
             PPM (parts per million, 0.0001%).  The scaling is &lt;CODE&gt;1 &lt;&lt;
             SHIFT_USEC&lt;/CODE&gt;.  The value can be set with bit &lt;CODE&gt;MOD_FREQUENCY&lt;/CODE&gt;, but
             the absolute value must not exceed &lt;CODE&gt;MAXFREQ&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int maxerror">
            <synopsis>
            This is the maximum error, measured in microseconds.  A new value can be
             set using bit &lt;CODE&gt;MOD_MAXERROR&lt;/CODE&gt;.  Unless updated via
             &lt;CODE&gt;ntp_adjtime&lt;/CODE&gt; periodically, this value will increase steadily
             and reach some platform-specific maximum value.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int esterror">
            <synopsis>
            This is the estimated error, measured in microseconds.  This value can
             be set using bit &lt;CODE&gt;MOD_ESTERROR&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int status">
            <synopsis>
            This variable reflects the various states of the clock machinery.  There
             are symbolic constants for the significant bits, starting with
             &lt;CODE&gt;STA_&lt;/CODE&gt;.  Some of these flags can be updated using the
             &lt;CODE&gt;MOD_STATUS&lt;/CODE&gt; bit.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int constant">
            <synopsis>
            This value represents the bandwidth or stiffness of the PLL (phase
             locked loop) implemented in the kernel.  The value can be changed using
             bit &lt;CODE&gt;MOD_TIMECONST&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int precision">
            <synopsis>
            This value represents the accuracy or the maximum error when reading the
             system clock.  The value is expressed in microseconds.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int tolerance">
            <synopsis>
            This value represents the maximum frequency error of the system clock in
             scaled PPM.  This value is used to increase the &lt;CODE&gt;maxerror&lt;/CODE&gt; every
             second.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="struct timeval time">
            <synopsis>
            The current calendar time.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int tick">
            <synopsis>
            The elapsed time between clock ticks in microseconds.  A clock tick is a
             periodic timer interrupt on which the system clock is based.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int ppsfreq">
            <synopsis>
            This is the first of a few optional variables that are present only if
             the system clock can use a PPS (pulse per second) signal to discipline
             the system clock.  The value is expressed in scaled PPM and it denotes
             the difference in frequency between the system clock and the PPS signal.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int jitter">
            <synopsis>
            This value expresses a median filtered average of the PPS signal's
             dispersion in microseconds.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int shift">
            <synopsis>
            This value is a binary exponent for the duration of the PPS calibration
             interval, ranging from &lt;CODE&gt;PPS_SHIFT&lt;/CODE&gt; to &lt;CODE&gt;PPS_SHIFTMAX&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int stabil">
            <synopsis>
            This value represents the median filtered dispersion of the PPS
             frequency in scaled PPM.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int jitcnt">
            <synopsis>
            This counter represents the number of pulses where the jitter exceeded
             the allowed maximum &lt;CODE&gt;MAXTIME&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int calcnt">
            <synopsis>
            This counter reflects the number of successful calibration intervals.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int errcnt">
            <synopsis>
            This counter represents the number of calibration errors (caused by
             large offsets or jitter).
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-ntp_adjtime" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="struct timex *tptr"/>
      </prototype>
      <headers>
        <header filename = "sys/timex.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;ntp_adjtime&lt;/CODE&gt; function sets the structure specified by
         &lt;VAR&gt;tptr&lt;/VAR&gt; to current values.
         &lt;br&gt;&lt;br&gt; In addition, &lt;CODE&gt;ntp_adjtime&lt;/CODE&gt; updates some settings to match what you
         pass to it in *&lt;VAR&gt;tptr&lt;/VAR&gt;.  Use the &lt;CODE&gt;modes&lt;/CODE&gt; element of *&lt;VAR&gt;tptr&lt;/VAR&gt;
         to select what settings to update.  You can set &lt;CODE&gt;offset&lt;/CODE&gt;,
         &lt;CODE&gt;freq&lt;/CODE&gt;, &lt;CODE&gt;maxerror&lt;/CODE&gt;, &lt;CODE&gt;esterror&lt;/CODE&gt;, &lt;CODE&gt;status&lt;/CODE&gt;,
         &lt;CODE&gt;constant&lt;/CODE&gt;, and &lt;CODE&gt;tick&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;modes&lt;/CODE&gt; = zero means set nothing.
         &lt;br&gt;&lt;br&gt; Only the superuser can update settings.
         &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; on success and other values on failure.  The
         following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;TIME_ERROR&lt;/CODE&gt;
&lt;DD&gt;
         The high accuracy clock model is not properly set up at the moment, thus the
         clock must be considered unsynchronized, and the values should be
         treated with care.  Another reason could be that the specified new values
         are not allowed.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EPERM
         The process specified a settings update, but is not superuser.
         &lt;br&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; For more details see RFC1305 (Network Time Protocol, Version 3) and
         related documents.
         &lt;br&gt;&lt;br&gt; Portability note: Early versions of the GNU C library did not
         have this function but did have the synonymous &lt;CODE&gt;adjtimex&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-asctime" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const struct tm *brokentime"/>
      </prototype>
      <headers>
        <header filename = "time.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;asctime&lt;/CODE&gt; function converts the broken-down time value that
         &lt;VAR&gt;brokentime&lt;/VAR&gt; points to into a string in a standard format:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         "Tue May 21 13:46:22 1991\n"&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; The abbreviations for the days of week are: &lt;samp&gt;Sun&lt;/samp&gt;, &lt;samp&gt;Mon&lt;/samp&gt;,
         &lt;samp&gt;Tue&lt;/samp&gt;, &lt;samp&gt;Wed&lt;/samp&gt;, &lt;samp&gt;Thu&lt;/samp&gt;, &lt;samp&gt;Fri&lt;/samp&gt;, and &lt;samp&gt;Sat&lt;/samp&gt;.
         &lt;br&gt;&lt;br&gt; The abbreviations for the months are: &lt;samp&gt;Jan&lt;/samp&gt;, &lt;samp&gt;Feb&lt;/samp&gt;,
         &lt;samp&gt;Mar&lt;/samp&gt;, &lt;samp&gt;Apr&lt;/samp&gt;, &lt;samp&gt;May&lt;/samp&gt;, &lt;samp&gt;Jun&lt;/samp&gt;, &lt;samp&gt;Jul&lt;/samp&gt;, &lt;samp&gt;Aug&lt;/samp&gt;,
         &lt;samp&gt;Sep&lt;/samp&gt;, &lt;samp&gt;Oct&lt;/samp&gt;, &lt;samp&gt;Nov&lt;/samp&gt;, and &lt;samp&gt;Dec&lt;/samp&gt;.
         &lt;br&gt;&lt;br&gt; The return value points to a statically allocated string, which might be
         overwritten by subsequent calls to &lt;CODE&gt;asctime&lt;/CODE&gt; or &lt;CODE&gt;ctime&lt;/CODE&gt;.
         (But no other library function overwrites the contents of this
         string.)
        </synopsis>
    </function>
  </construct>
  <construct id="function-asctime_r" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const struct tm *brokentime"/>
        <parameter content="char *buffer"/>
      </prototype>
      <headers>
        <header filename = "time.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;asctime&lt;/CODE&gt; but instead of placing the
         result in a static buffer it writes the string in the buffer pointed to
         by the parameter &lt;VAR&gt;buffer&lt;/VAR&gt;.  This buffer should have room
         for at least 26 bytes, including the terminating null.
         &lt;br&gt;&lt;br&gt; If no error occurred the function returns a pointer to the string the
         result was written into, i.e., it returns &lt;VAR&gt;buffer&lt;/VAR&gt;.  Otherwise
         return &lt;CODE&gt;NULL&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ctime" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const time_t *time"/>
      </prototype>
      <headers>
        <header filename = "time.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;ctime&lt;/CODE&gt; function is similar to &lt;CODE&gt;asctime&lt;/CODE&gt;, except that you
         specify the calendar time argument as a &lt;CODE&gt;time_t&lt;/CODE&gt; simple time value
         rather than in broken-down local time format.  It is equivalent to
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         asctime (localtime (&lt;VAR&gt;time&lt;/VAR&gt;))&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;ctime&lt;/CODE&gt; sets the variable &lt;CODE&gt;tzname&lt;/CODE&gt;, because &lt;CODE&gt;localtime&lt;/CODE&gt;
         does so.  .
        </synopsis>
    </function>
  </construct>
  <construct id="function-ctime_r" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const time_t *time"/>
        <parameter content="char *buffer"/>
      </prototype>
      <headers>
        <header filename = "time.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;ctime&lt;/CODE&gt;, but places the result in the
         string pointed to by &lt;VAR&gt;buffer&lt;/VAR&gt;.  It is equivalent to (written using
         gcc extensions, ):
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         ({ struct tm tm; asctime_r (localtime_r (time, &amp;tm), buf); })&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; If no error occurred the function returns a pointer to the string the
         result was written into, i.e., it returns &lt;VAR&gt;buffer&lt;/VAR&gt;.  Otherwise
         return &lt;CODE&gt;NULL&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strftime" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="char *s"/>
        <parameter content="size_t size"/>
        <parameter content="const char *template"/>
        <parameter content="const struct tm *brokentime"/>
      </prototype>
      <headers>
        <header filename = "time.h"/>
      </headers>
        <synopsis>
        This function is similar to the &lt;CODE&gt;sprintf&lt;/CODE&gt; function , but the conversion specifications that can appear in the format
         template &lt;VAR&gt;template&lt;/VAR&gt; are specialized for printing components of the date
         and time &lt;VAR&gt;brokentime&lt;/VAR&gt; according to the locale currently specified for
         time conversion .
         &lt;br&gt;&lt;br&gt; Ordinary characters appearing in the &lt;VAR&gt;template&lt;/VAR&gt; are copied to the
         output string &lt;VAR&gt;s&lt;/VAR&gt;; this can include multibyte character sequences.
         Conversion specifiers are introduced by a &lt;samp&gt;%&lt;/samp&gt; character, followed
         by an optional flag which can be one of the following.  These flags
         are all GNU extensions. The first three affect only the output of
         numbers:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;_&lt;/CODE&gt;
&lt;DD&gt;
         The number is padded with spaces.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;-&lt;/CODE&gt;
&lt;DD&gt;
         The number is not padded at all.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;0&lt;/CODE&gt;
&lt;DD&gt;
         The number is padded with zeros even if the format specifies padding
         with spaces.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ^
         The output uses uppercase characters, but only if this is possible
         .

         &lt;br&gt;&lt;br&gt; The default action is to pad the number with zeros to keep it a constant
         width.  Numbers that do not have a range indicated below are never
         padded, since there is no natural width for them.
         &lt;br&gt;&lt;br&gt; Following the flag an optional specification of the width is possible.
         This is specified in decimal notation.  If the natural size of the
         output is of the field has less than the specified number of characters,
         the result is written right adjusted and space padded to the given
         size.
         &lt;br&gt;&lt;br&gt; An optional modifier can follow the optional flag and width
         specification.  The modifiers, which were first standardized by
         POSIX.2-1992 and by ISO C99, are:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;LI&gt; E
         Use the locale's alternate representation for date and time.  This
         modifier applies to the &lt;CODE&gt;%c&lt;/CODE&gt;, &lt;CODE&gt;%C&lt;/CODE&gt;, &lt;CODE&gt;%x&lt;/CODE&gt;, &lt;CODE&gt;%X&lt;/CODE&gt;,
         &lt;CODE&gt;%y&lt;/CODE&gt; and &lt;CODE&gt;%Y&lt;/CODE&gt; format specifiers.  In a Japanese locale, for
         example, &lt;CODE&gt;%Ex&lt;/CODE&gt; might yield a date format based on the Japanese
         Emperors' reigns.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; O
         Use the locale's alternate numeric symbols for numbers.  This modifier
         applies only to numeric format specifiers.

         &lt;br&gt;&lt;br&gt; If the format supports the modifier but no alternate representation
         is available, it is ignored.
         &lt;br&gt;&lt;br&gt; The conversion specifier ends with a format specifier taken from the
         following list.  The whole &lt;samp&gt;%&lt;/samp&gt; sequence is replaced in the output
         string as follows:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;LI&gt; %a
         The abbreviated weekday name according to the current locale.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %A
         The full weekday name according to the current locale.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %b
         The abbreviated month name according to the current locale.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %B
         The full month name according to the current locale.
         &lt;br&gt;&lt;br&gt; Using &lt;CODE&gt;%B&lt;/CODE&gt; together with &lt;CODE&gt;%d&lt;/CODE&gt; produces grammatically
         incorrect results for some locales.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %c
         The preferred calendar time representation for the current locale.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %C
         The century of the year.  This is equivalent to the greatest integer not
         greater than the year divided by 100.
         &lt;br&gt;&lt;br&gt; This format was first standardized by POSIX.2-1992 and by ISO C99.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %d
         The day of the month as a decimal number (range &lt;CODE&gt;01&lt;/CODE&gt; through &lt;CODE&gt;31&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %D
         The date using the format &lt;CODE&gt;%m/%d/%y&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This format was first standardized by POSIX.2-1992 and by ISO C99.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %e
         The day of the month like with &lt;CODE&gt;%d&lt;/CODE&gt;, but padded with blank (range
         &lt;CODE&gt; 1&lt;/CODE&gt; through &lt;CODE&gt;31&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; This format was first standardized by POSIX.2-1992 and by ISO C99.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %F
         The date using the format &lt;CODE&gt;%Y-%m-%d&lt;/CODE&gt;.  This is the form specified
         in the ISO 8601 standard and is the preferred form for all uses.
         &lt;br&gt;&lt;br&gt; This format was first standardized by ISO C99 and by POSIX.1-2001.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %g
         The year corresponding to the ISO week number, but without the century
         (range &lt;CODE&gt;00&lt;/CODE&gt; through &lt;CODE&gt;99&lt;/CODE&gt;).  This has the same format and value
         as &lt;CODE&gt;%y&lt;/CODE&gt;, except that if the ISO week number (see &lt;CODE&gt;%V&lt;/CODE&gt;) belongs
         to the previous or next year, that year is used instead.
         &lt;br&gt;&lt;br&gt; This format was first standardized by ISO C99 and by POSIX.1-2001.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %G
         The year corresponding to the ISO week number.  This has the same format
         and value as &lt;CODE&gt;%Y&lt;/CODE&gt;, except that if the ISO week number (see
         &lt;CODE&gt;%V&lt;/CODE&gt;) belongs to the previous or next year, that year is used
         instead.
         &lt;br&gt;&lt;br&gt; This format was first standardized by ISO C99 and by POSIX.1-2001
         but was previously available as a GNU extension.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %h
         The abbreviated month name according to the current locale.  The action
         is the same as for &lt;CODE&gt;%b&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This format was first standardized by POSIX.2-1992 and by ISO C99.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %H
         The hour as a decimal number, using a 24-hour clock (range &lt;CODE&gt;00&lt;/CODE&gt; through
         &lt;CODE&gt;23&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %I
         The hour as a decimal number, using a 12-hour clock (range &lt;CODE&gt;01&lt;/CODE&gt; through
         &lt;CODE&gt;12&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %j
         The day of the year as a decimal number (range &lt;CODE&gt;001&lt;/CODE&gt; through &lt;CODE&gt;366&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %k
         The hour as a decimal number, using a 24-hour clock like &lt;CODE&gt;%H&lt;/CODE&gt;, but
         padded with blank (range &lt;CODE&gt; 0&lt;/CODE&gt; through &lt;CODE&gt;23&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; This format is a GNU extension.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %l
         The hour as a decimal number, using a 12-hour clock like &lt;CODE&gt;%I&lt;/CODE&gt;, but
         padded with blank (range &lt;CODE&gt; 1&lt;/CODE&gt; through &lt;CODE&gt;12&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; This format is a GNU extension.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %m
         The month as a decimal number (range &lt;CODE&gt;01&lt;/CODE&gt; through &lt;CODE&gt;12&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %M
         The minute as a decimal number (range &lt;CODE&gt;00&lt;/CODE&gt; through &lt;CODE&gt;59&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %n
         A single &lt;samp&gt;\n&lt;/samp&gt; (newline) character.
         &lt;br&gt;&lt;br&gt; This format was first standardized by POSIX.2-1992 and by ISO C99.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %p
         Either &lt;samp&gt;AM&lt;/samp&gt; or &lt;samp&gt;PM&lt;/samp&gt;, according to the given time value; or the
         corresponding strings for the current locale.  Noon is treated as
         &lt;samp&gt;PM&lt;/samp&gt; and midnight as &lt;samp&gt;AM&lt;/samp&gt;.  In most locales
         &lt;samp&gt;AM&lt;/samp&gt;/&lt;samp&gt;PM&lt;/samp&gt; format is not supported, in such cases &lt;CODE&gt;"%p"&lt;/CODE&gt;
         yields an empty string.
         &lt;br&gt;&lt;br&gt;
         &lt;LI&gt; %P
         Either &lt;samp&gt;am&lt;/samp&gt; or &lt;samp&gt;pm&lt;/samp&gt;, according to the given time value; or the
         corresponding strings for the current locale, printed in lowercase
         characters.  Noon is treated as &lt;samp&gt;pm&lt;/samp&gt; and midnight as &lt;samp&gt;am&lt;/samp&gt;.  In
         most locales &lt;samp&gt;AM&lt;/samp&gt;/&lt;samp&gt;PM&lt;/samp&gt; format is not supported, in such cases
         &lt;CODE&gt;"%P"&lt;/CODE&gt; yields an empty string.
         &lt;br&gt;&lt;br&gt; This format is a GNU extension.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %r
         The complete calendar time using the AM/PM format of the current locale.
         &lt;br&gt;&lt;br&gt; This format was first standardized by POSIX.2-1992 and by ISO C99.
         In the POSIX locale, this format is equivalent to &lt;CODE&gt;%I:%M:%S %p&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %R
         The hour and minute in decimal numbers using the format &lt;CODE&gt;%H:%M&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This format was first standardized by ISO C99 and by POSIX.1-2001
         but was previously available as a GNU extension.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %s
         The number of seconds since the epoch, i.e., since 1970-01-01 00:00:00 UTC.
         Leap seconds are not counted unless leap second support is available.
         &lt;br&gt;&lt;br&gt; This format is a GNU extension.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %S
         The seconds as a decimal number (range &lt;CODE&gt;00&lt;/CODE&gt; through &lt;CODE&gt;60&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %t
         A single &lt;samp&gt;\t&lt;/samp&gt; (tabulator) character.
         &lt;br&gt;&lt;br&gt; This format was first standardized by POSIX.2-1992 and by ISO C99.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %T
         The time of day using decimal numbers using the format &lt;CODE&gt;%H:%M:%S&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This format was first standardized by POSIX.2-1992 and by ISO C99.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %u
         The day of the week as a decimal number (range &lt;CODE&gt;1&lt;/CODE&gt; through
         &lt;CODE&gt;7&lt;/CODE&gt;), Monday being &lt;CODE&gt;1&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This format was first standardized by POSIX.2-1992 and by ISO C99.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %U
         The week number of the current year as a decimal number (range &lt;CODE&gt;00&lt;/CODE&gt;
         through &lt;CODE&gt;53&lt;/CODE&gt;), starting with the first Sunday as the first day of
         the first week.  Days preceding the first Sunday in the year are
         considered to be in week &lt;CODE&gt;00&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %V
         The ISO 8601:1988 week number as a decimal number (range &lt;CODE&gt;01&lt;/CODE&gt;
         through &lt;CODE&gt;53&lt;/CODE&gt;).  ISO weeks start with Monday and end with Sunday.
         Week &lt;CODE&gt;01&lt;/CODE&gt; of a year is the first week which has the majority of its
         days in that year; this is equivalent to the week containing the year's
         first Thursday, and it is also equivalent to the week containing January
         4.  Week &lt;CODE&gt;01&lt;/CODE&gt; of a year can contain days from the previous year.
         The week before week &lt;CODE&gt;01&lt;/CODE&gt; of a year is the last week (&lt;CODE&gt;52&lt;/CODE&gt; or
         &lt;CODE&gt;53&lt;/CODE&gt;) of the previous year even if it contains days from the new
         year.
         &lt;br&gt;&lt;br&gt; This format was first standardized by POSIX.2-1992 and by ISO C99.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %w
         The day of the week as a decimal number (range &lt;CODE&gt;0&lt;/CODE&gt; through
         &lt;CODE&gt;6&lt;/CODE&gt;), Sunday being &lt;CODE&gt;0&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %W
         The week number of the current year as a decimal number (range &lt;CODE&gt;00&lt;/CODE&gt;
         through &lt;CODE&gt;53&lt;/CODE&gt;), starting with the first Monday as the first day of
         the first week.  All days preceding the first Monday in the year are
         considered to be in week &lt;CODE&gt;00&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %x
         The preferred date representation for the current locale.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %X
         The preferred time of day representation for the current locale.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %y
         The year without a century as a decimal number (range &lt;CODE&gt;00&lt;/CODE&gt; through
         &lt;CODE&gt;99&lt;/CODE&gt;).  This is equivalent to the year modulo 100.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %Y
         The year as a decimal number, using the Gregorian calendar.  Years
         before the year &lt;CODE&gt;1&lt;/CODE&gt; are numbered &lt;CODE&gt;0&lt;/CODE&gt;, &lt;CODE&gt;-1&lt;/CODE&gt;, and so on.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %z
         RFC 822/ISO 8601:1988 style numeric time zone (e.g.,
         &lt;CODE&gt;-0600&lt;/CODE&gt; or &lt;CODE&gt;+0100&lt;/CODE&gt;), or nothing if no time zone is
         determinable.
         &lt;br&gt;&lt;br&gt; This format was first standardized by ISO C99 and by POSIX.1-2001
         but was previously available as a GNU extension.
         &lt;br&gt;&lt;br&gt; In the POSIX locale, a full RFC 822 timestamp is generated by the format
         &lt;samp&gt;"%a, %d %b %Y %H:%M:%S %z"&lt;/samp&gt; (or the equivalent
         &lt;samp&gt;"%a, %d %b %Y %T %z"&lt;/samp&gt;).
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %Z
         The time zone abbreviation (empty if the time zone can't be determined).
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %%
         A literal &lt;samp&gt;%&lt;/samp&gt; character.

         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;size&lt;/VAR&gt; parameter can be used to specify the maximum number of
         characters to be stored in the array &lt;VAR&gt;s&lt;/VAR&gt;, including the terminating
         null character.  If the formatted time requires more than &lt;VAR&gt;size&lt;/VAR&gt;
         characters, &lt;CODE&gt;strftime&lt;/CODE&gt; returns zero and the contents of the array
         &lt;VAR&gt;s&lt;/VAR&gt; are undefined.  Otherwise the return value indicates the
         number of characters placed in the array &lt;VAR&gt;s&lt;/VAR&gt;, not including the
         terminating null character.
         &lt;br&gt;&lt;br&gt; &lt;EM&gt;Warning:&lt;/EM&gt; This convention for the return value which is prescribed
         in ISO C can lead to problems in some situations.  For certain
         format strings and certain locales the output really can be the empty
         string and this cannot be discovered by testing the return value only.
         E.g., in most locales the AM/PM time format is not supported (most of
         the world uses the 24 hour time representation).  In such locales
         &lt;CODE&gt;"%p"&lt;/CODE&gt; will return the empty string, i.e., the return value is
         zero.  To detect situations like this something similar to the following
         code should be used:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         buf[0] = '\1';&lt;br&gt;
         len = strftime (buf, bufsize, format, tp);&lt;br&gt;
         if (len == 0 &amp;&amp; buf[0] != '\0')&lt;br&gt;
           {&lt;br&gt;
             /* Something went wrong in the strftime call.  */&lt;br&gt;
             &lt;small&gt;...&lt;/small&gt;&lt;br&gt;
           }&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;s&lt;/VAR&gt; is a null pointer, &lt;CODE&gt;strftime&lt;/CODE&gt; does not actually write
         anything, but instead returns the number of characters it would have written.
         &lt;br&gt;&lt;br&gt; According to POSIX.1 every call to &lt;CODE&gt;strftime&lt;/CODE&gt; implies a call to
         &lt;CODE&gt;tzset&lt;/CODE&gt;.  So the contents of the environment variable &lt;CODE&gt;TZ&lt;/CODE&gt;
         is examined before any output is produced.
         &lt;br&gt;&lt;br&gt; For an example of &lt;CODE&gt;strftime&lt;/CODE&gt;, see Time Functions Example.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcsftime" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="wchar_t *s"/>
        <parameter content="size_t size"/>
        <parameter content="const wchar_t *template"/>
        <parameter content="const struct tm *brokentime"/>
      </prototype>
      <headers>
        <header filename = "time.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wcsftime&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;strftime&lt;/CODE&gt;
         function with the difference that it operates on wide character
         strings.  The buffer where the result is stored, pointed to by &lt;VAR&gt;s&lt;/VAR&gt;,
         must be an array of wide characters.  The parameter &lt;VAR&gt;size&lt;/VAR&gt; which
         specifies the size of the output buffer gives the number of wide
         character, not the number of bytes.
         &lt;br&gt;&lt;br&gt; Also the format string &lt;VAR&gt;template&lt;/VAR&gt; is a wide character string.  Since
         all characters needed to specify the format string are in the basic
         character set it is portably possible to write format strings in the C
         source code using the &lt;CODE&gt;L"&lt;small&gt;...&lt;/small&gt;"&lt;/CODE&gt; notation.  The parameter
         &lt;VAR&gt;brokentime&lt;/VAR&gt; has the same meaning as in the &lt;CODE&gt;strftime&lt;/CODE&gt; call.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;wcsftime&lt;/CODE&gt; function supports the same flags, modifiers, and
         format specifiers as the &lt;CODE&gt;strftime&lt;/CODE&gt; function.
         &lt;br&gt;&lt;br&gt; The return value of &lt;CODE&gt;wcsftime&lt;/CODE&gt; is the number of wide characters
         stored in &lt;CODE&gt;s&lt;/CODE&gt;.  When more characters would have to be written than
         can be placed in the buffer &lt;VAR&gt;s&lt;/VAR&gt; the return value is zero, with the
         same problems indicated in the &lt;CODE&gt;strftime&lt;/CODE&gt; documentation.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strptime" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *s"/>
        <parameter content="const char *fmt"/>
        <parameter content="struct tm *tp"/>
      </prototype>
      <headers>
        <header filename = "time.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;strptime&lt;/CODE&gt; function parses the input string &lt;VAR&gt;s&lt;/VAR&gt; according
         to the format string &lt;VAR&gt;fmt&lt;/VAR&gt; and stores its results in the
         structure &lt;VAR&gt;tp&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The input string could be generated by a &lt;CODE&gt;strftime&lt;/CODE&gt; call or
         obtained any other way.  It does not need to be in a human-recognizable
         format; e.g. a date passed as &lt;CODE&gt;"02:1999:9"&lt;/CODE&gt; is acceptable, even
         though it is ambiguous without context.  As long as the format string
         &lt;VAR&gt;fmt&lt;/VAR&gt; matches the input string the function will succeed.
         &lt;br&gt;&lt;br&gt; The user has to make sure, though, that the input can be parsed in a
         unambiguous way.  The string &lt;CODE&gt;"1999112"&lt;/CODE&gt; can be parsed using the
         format &lt;CODE&gt;"%Y%m%d"&lt;/CODE&gt; as 1999-1-12, 1999-11-2, or even 19991-1-2.  It
         is necessary to add appropriate separators to reliably get results.
         &lt;br&gt;&lt;br&gt; The format string consists of the same components as the format string
         of the &lt;CODE&gt;strftime&lt;/CODE&gt; function.  The only difference is that the flags
         &lt;CODE&gt;_&lt;/CODE&gt;, &lt;CODE&gt;-&lt;/CODE&gt;, &lt;CODE&gt;0&lt;/CODE&gt;, and &lt;CODE&gt;^&lt;/CODE&gt; are not allowed.
         Several of the distinct formats of &lt;CODE&gt;strftime&lt;/CODE&gt; do the same work in
         &lt;CODE&gt;strptime&lt;/CODE&gt; since differences like case of the input do not matter.
         For reasons of symmetry all formats are supported, though.
         &lt;br&gt;&lt;br&gt; The modifiers &lt;CODE&gt;E&lt;/CODE&gt; and &lt;CODE&gt;O&lt;/CODE&gt; are also allowed everywhere the
         &lt;CODE&gt;strftime&lt;/CODE&gt; function allows them.
         &lt;br&gt;&lt;br&gt; The formats are:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;%a&lt;/CODE&gt;
&lt;DD&gt;
         &lt;LI&gt;x %A
         The weekday name according to the current locale, in abbreviated form or
         the full name.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %b
         &lt;LI&gt;x %B
         &lt;LI&gt;x %h
         The month name according to the current locale, in abbreviated form or
         the full name.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %c
         The date and time representation for the current locale.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %Ec
         Like &lt;CODE&gt;%c&lt;/CODE&gt; but the locale's alternative date and time format is used.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %C
         The century of the year.
         &lt;br&gt;&lt;br&gt; It makes sense to use this format only if the format string also
         contains the &lt;CODE&gt;%y&lt;/CODE&gt; format.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %EC
         The locale's representation of the period.
         &lt;br&gt;&lt;br&gt; Unlike &lt;CODE&gt;%C&lt;/CODE&gt; it sometimes makes sense to use this format since some
         cultures represent years relative to the beginning of eras instead of
         using the Gregorian years.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %d
         &lt;LI&gt; %e
         The day of the month as a decimal number (range &lt;CODE&gt;1&lt;/CODE&gt; through &lt;CODE&gt;31&lt;/CODE&gt;).
         Leading zeroes are permitted but not required.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %Od
         &lt;LI&gt;x %Oe
         Same as &lt;CODE&gt;%d&lt;/CODE&gt; but using the locale's alternative numeric symbols.
         &lt;br&gt;&lt;br&gt; Leading zeroes are permitted but not required.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %D
         Equivalent to &lt;CODE&gt;%m/%d/%y&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %F
         Equivalent to &lt;CODE&gt;%Y-%m-%d&lt;/CODE&gt;, which is the ISO 8601 date
         format.
         &lt;br&gt;&lt;br&gt; This is a GNU extension following an ISO C99 extension to
         &lt;CODE&gt;strftime&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %g
         The year corresponding to the ISO week number, but without the century
         (range &lt;CODE&gt;00&lt;/CODE&gt; through &lt;CODE&gt;99&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; &lt;EM&gt;Note:&lt;/EM&gt; Currently, this is not fully implemented.  The format is
         recognized, input is consumed but no field in &lt;VAR&gt;tm&lt;/VAR&gt; is set.
         &lt;br&gt;&lt;br&gt; This format is a GNU extension following a GNU extension of &lt;CODE&gt;strftime&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %G
         The year corresponding to the ISO week number.
         &lt;br&gt;&lt;br&gt; &lt;EM&gt;Note:&lt;/EM&gt; Currently, this is not fully implemented.  The format is
         recognized, input is consumed but no field in &lt;VAR&gt;tm&lt;/VAR&gt; is set.
         &lt;br&gt;&lt;br&gt; This format is a GNU extension following a GNU extension of &lt;CODE&gt;strftime&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %H
         &lt;LI&gt;x %k
         The hour as a decimal number, using a 24-hour clock (range &lt;CODE&gt;00&lt;/CODE&gt; through
         &lt;CODE&gt;23&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;%k&lt;/CODE&gt; is a GNU extension following a GNU extension of &lt;CODE&gt;strftime&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %OH
         Same as &lt;CODE&gt;%H&lt;/CODE&gt; but using the locale's alternative numeric symbols.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %I
         &lt;LI&gt;x %l
         The hour as a decimal number, using a 12-hour clock (range &lt;CODE&gt;01&lt;/CODE&gt; through
         &lt;CODE&gt;12&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;%l&lt;/CODE&gt; is a GNU extension following a GNU extension of &lt;CODE&gt;strftime&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %OI
         Same as &lt;CODE&gt;%I&lt;/CODE&gt; but using the locale's alternative numeric symbols.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %j
         The day of the year as a decimal number (range &lt;CODE&gt;1&lt;/CODE&gt; through &lt;CODE&gt;366&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; Leading zeroes are permitted but not required.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %m
         The month as a decimal number (range &lt;CODE&gt;1&lt;/CODE&gt; through &lt;CODE&gt;12&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; Leading zeroes are permitted but not required.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %Om
         Same as &lt;CODE&gt;%m&lt;/CODE&gt; but using the locale's alternative numeric symbols.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %M
         The minute as a decimal number (range &lt;CODE&gt;0&lt;/CODE&gt; through &lt;CODE&gt;59&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; Leading zeroes are permitted but not required.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %OM
         Same as &lt;CODE&gt;%M&lt;/CODE&gt; but using the locale's alternative numeric symbols.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %n
         &lt;LI&gt;x %t
         Matches any white space.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %p
         &lt;LI&gt; %P
         The locale-dependent equivalent to &lt;samp&gt;AM&lt;/samp&gt; or &lt;samp&gt;PM&lt;/samp&gt;.
         &lt;br&gt;&lt;br&gt; This format is not useful unless &lt;CODE&gt;%I&lt;/CODE&gt; or &lt;CODE&gt;%l&lt;/CODE&gt; is also used.
         Another complication is that the locale might not define these values at
         all and therefore the conversion fails.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;%P&lt;/CODE&gt; is a GNU extension following a GNU extension to &lt;CODE&gt;strftime&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %r
         The complete time using the AM/PM format of the current locale.
         &lt;br&gt;&lt;br&gt; A complication is that the locale might not define this format at all
         and therefore the conversion fails.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %R
         The hour and minute in decimal numbers using the format &lt;CODE&gt;%H:%M&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;%R&lt;/CODE&gt; is a GNU extension following a GNU extension to &lt;CODE&gt;strftime&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %s
         The number of seconds since the epoch, i.e., since 1970-01-01 00:00:00 UTC.
         Leap seconds are not counted unless leap second support is available.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;%s&lt;/CODE&gt; is a GNU extension following a GNU extension to &lt;CODE&gt;strftime&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %S
         The seconds as a decimal number (range &lt;CODE&gt;0&lt;/CODE&gt; through &lt;CODE&gt;60&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; Leading zeroes are permitted but not required.
         &lt;br&gt;&lt;br&gt; NB: The Unix specification says the upper bound on this value
         is &lt;CODE&gt;61&lt;/CODE&gt;, a result of a decision to allow double leap seconds.  You
         will not see the value &lt;CODE&gt;61&lt;/CODE&gt; because no minute has more than one
         leap second, but the myth persists.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %OS
         Same as &lt;CODE&gt;%S&lt;/CODE&gt; but using the locale's alternative numeric symbols.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %T
         Equivalent to the use of &lt;CODE&gt;%H:%M:%S&lt;/CODE&gt; in this place.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %u
         The day of the week as a decimal number (range &lt;CODE&gt;1&lt;/CODE&gt; through
         &lt;CODE&gt;7&lt;/CODE&gt;), Monday being &lt;CODE&gt;1&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; Leading zeroes are permitted but not required.
         &lt;br&gt;&lt;br&gt; &lt;EM&gt;Note:&lt;/EM&gt; Currently, this is not fully implemented.  The format is
         recognized, input is consumed but no field in &lt;VAR&gt;tm&lt;/VAR&gt; is set.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %U
         The week number of the current year as a decimal number (range &lt;CODE&gt;0&lt;/CODE&gt;
         through &lt;CODE&gt;53&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; Leading zeroes are permitted but not required.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %OU
         Same as &lt;CODE&gt;%U&lt;/CODE&gt; but using the locale's alternative numeric symbols.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %V
         The ISO 8601:1988 week number as a decimal number (range &lt;CODE&gt;1&lt;/CODE&gt;
         through &lt;CODE&gt;53&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; Leading zeroes are permitted but not required.
         &lt;br&gt;&lt;br&gt; &lt;EM&gt;Note:&lt;/EM&gt; Currently, this is not fully implemented.  The format is
         recognized, input is consumed but no field in &lt;VAR&gt;tm&lt;/VAR&gt; is set.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %w
         The day of the week as a decimal number (range &lt;CODE&gt;0&lt;/CODE&gt; through
         &lt;CODE&gt;6&lt;/CODE&gt;), Sunday being &lt;CODE&gt;0&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; Leading zeroes are permitted but not required.
         &lt;br&gt;&lt;br&gt; &lt;EM&gt;Note:&lt;/EM&gt; Currently, this is not fully implemented.  The format is
         recognized, input is consumed but no field in &lt;VAR&gt;tm&lt;/VAR&gt; is set.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %Ow
         Same as &lt;CODE&gt;%w&lt;/CODE&gt; but using the locale's alternative numeric symbols.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %W
         The week number of the current year as a decimal number (range &lt;CODE&gt;0&lt;/CODE&gt;
         through &lt;CODE&gt;53&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; Leading zeroes are permitted but not required.
         &lt;br&gt;&lt;br&gt; &lt;EM&gt;Note:&lt;/EM&gt; Currently, this is not fully implemented.  The format is
         recognized, input is consumed but no field in &lt;VAR&gt;tm&lt;/VAR&gt; is set.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %OW
         Same as &lt;CODE&gt;%W&lt;/CODE&gt; but using the locale's alternative numeric symbols.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %x
         The date using the locale's date format.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %Ex
         Like &lt;CODE&gt;%x&lt;/CODE&gt; but the locale's alternative data representation is used.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %X
         The time using the locale's time format.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %EX
         Like &lt;CODE&gt;%X&lt;/CODE&gt; but the locale's alternative time representation is used.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %y
         The year without a century as a decimal number (range &lt;CODE&gt;0&lt;/CODE&gt; through
         &lt;CODE&gt;99&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; Leading zeroes are permitted but not required.
         &lt;br&gt;&lt;br&gt; Note that it is questionable to use this format without
         the &lt;CODE&gt;%C&lt;/CODE&gt; format.  The &lt;CODE&gt;strptime&lt;/CODE&gt; function does regard input
         values in the range 68 to 99 as the years 1969 to
         1999 and the values 0 to 68 as the years
         2000 to 2068.  But maybe this heuristic fails for some
         input data.
         &lt;br&gt;&lt;br&gt; Therefore it is best to avoid &lt;CODE&gt;%y&lt;/CODE&gt; completely and use &lt;CODE&gt;%Y&lt;/CODE&gt;
         instead.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %Ey
         The offset from &lt;CODE&gt;%EC&lt;/CODE&gt; in the locale's alternative representation.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %Oy
         The offset of the year (from &lt;CODE&gt;%C&lt;/CODE&gt;) using the locale's alternative
         numeric symbols.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %Y
         The year as a decimal number, using the Gregorian calendar.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %EY
         The full alternative year representation.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %z
         The offset from GMT in ISO 8601/RFC822 format.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %Z
         The timezone name.
         &lt;br&gt;&lt;br&gt; &lt;EM&gt;Note:&lt;/EM&gt; Currently, this is not fully implemented.  The format is
         recognized, input is consumed but no field in &lt;VAR&gt;tm&lt;/VAR&gt; is set.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %%
         A literal &lt;samp&gt;%&lt;/samp&gt; character.

         &lt;br&gt;&lt;br&gt; All other characters in the format string must have a matching character
         in the input string.  Exceptions are white spaces in the input string
         which can match zero or more whitespace characters in the format string.
         &lt;br&gt;&lt;br&gt; Portability Note: The XPG standard advises applications to use
         at least one whitespace character (as specified by &lt;CODE&gt;isspace&lt;/CODE&gt;) or
         other non-alphanumeric characters between any two conversion
         specifications.  The GNU C Library does not have this limitation but
         other libraries might have trouble parsing formats like
         &lt;CODE&gt;"%d%m%Y%H%M%S"&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;strptime&lt;/CODE&gt; function processes the input string from right to
         left.  Each of the three possible input elements (white space, literal,
         or format) are handled one after the other.  If the input cannot be
         matched to the format string the function stops.  The remainder of the
         format and input strings are not processed.
         &lt;br&gt;&lt;br&gt; The function returns a pointer to the first character it was unable to
         process.  If the input string contains more characters than required by
         the format string the return value points right after the last consumed
         input character.  If the whole input string is consumed the return value
         points to the &lt;CODE&gt;NULL&lt;/CODE&gt; byte at the end of the string.  If an error
         occurs, i.e., &lt;CODE&gt;strptime&lt;/CODE&gt; fails to match all of the format string,
         the function returns &lt;CODE&gt;NULL&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getdate" type="function">
    <function returntype="struct tm *">
      <prototype>
        <parameter content="const char *string"/>
      </prototype>
      <headers>
        <header filename = "time.h"/>
      </headers>
        <synopsis>
        The interface to &lt;CODE&gt;getdate&lt;/CODE&gt; is the simplest possible for a function
         to parse a string and return the value.  &lt;VAR&gt;string&lt;/VAR&gt; is the input
         string and the result is returned in a statically-allocated variable.
         &lt;br&gt;&lt;br&gt; The details about how the string is processed are hidden from the user.
         In fact, they can be outside the control of the program.  Which formats
         are recognized is controlled by the file named by the environment
         variable &lt;CODE&gt;DATEMSK&lt;/CODE&gt;.  This file should contain
         lines of valid format strings which could be passed to &lt;CODE&gt;strptime&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;getdate&lt;/CODE&gt; function reads these format strings one after the
         other and tries to match the input string.  The first line which
         completely matches the input string is used.
         &lt;br&gt;&lt;br&gt; Elements not initialized through the format string retain the values
         present at the time of the &lt;CODE&gt;getdate&lt;/CODE&gt; function call.
         &lt;br&gt;&lt;br&gt; The formats recognized by &lt;CODE&gt;getdate&lt;/CODE&gt; are the same as for
         &lt;CODE&gt;strptime&lt;/CODE&gt;.  See above for an explanation.  There are only a few
         extensions to the &lt;CODE&gt;strptime&lt;/CODE&gt; behavior:
         &lt;br&gt;&lt;br&gt; &lt;OL&gt;
         &lt;LI&gt;
         If the &lt;CODE&gt;%Z&lt;/CODE&gt; format is given the broken-down time is based on the
         current time of the timezone matched, not of the current timezone of the
         runtime environment.
         &lt;br&gt;&lt;br&gt; &lt;EM&gt;Note&lt;/EM&gt;: This is not implemented (currently).  The problem is that
         timezone names are not unique.  If a fixed timezone is assumed for a
         given string (say &lt;CODE&gt;EST&lt;/CODE&gt; meaning US East Coast time), then uses for
         countries other than the USA will fail.  So far we have found no good
         solution to this.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         If only the weekday is specified the selected day depends on the current
         date.  If the current weekday is greater or equal to the &lt;CODE&gt;tm_wday&lt;/CODE&gt;
         value the current week's day is chosen, otherwise the day next week is chosen.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         A similar heuristic is used when only the month is given and not the
         year.  If the month is greater than or equal to the current month, then
         the current year is used.  Otherwise it wraps to next year.  The first
         day of the month is assumed if one is not explicitly specified.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         The current hour, minute, and second are used if the appropriate value is
         not set through the format.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         If no date is given tomorrow's date is used if the time is
         smaller than the current time.  Otherwise today's date is taken.
         &lt;/OL&gt;
         &lt;br&gt;&lt;br&gt; It should be noted that the format in the template file need not only
         contain format elements.  The following is a list of possible format
         strings (taken from the Unix standard):
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         %m&lt;br&gt;
         %A %B %d, %Y %H:%M:%S&lt;br&gt;
         %A&lt;br&gt;
         %B&lt;br&gt;
         %m/%d/%y %I %p&lt;br&gt;
         %d,%m,%Y %H:%M&lt;br&gt;
         at %A the %dst of %B in %Y&lt;br&gt;
         run job at %I %p,%B %dnd&lt;br&gt;
         %A den %d. %B %Y %H.%M Uhr&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; As you can see, the template list can contain very specific strings like
         &lt;CODE&gt;run job at %I %p,%B %dnd&lt;/CODE&gt;.  Using the above list of templates and
         assuming the current time is Mon Sep 22 12:19:47 EDT 1986 we can obtain the
         following results for the given input.
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;
&lt;DT&gt;&lt;pre&gt;Input      Match  Result&lt;/pre&gt;
&lt;DD&gt;&lt;br&gt; &lt;DT&gt;&lt;pre&gt;Mon        %a     Mon Sep 22 12:19:47 EDT 1986&lt;/pre&gt;
&lt;DD&gt;&lt;br&gt; &lt;DT&gt;&lt;pre&gt;Sun        %a     Sun Sep 28 12:19:47 EDT 1986&lt;/pre&gt;
&lt;DD&gt;&lt;br&gt; &lt;DT&gt;&lt;pre&gt;Fri        %a     Fri Sep 26 12:19:47 EDT 1986&lt;/pre&gt;
&lt;DD&gt;&lt;br&gt; &lt;DT&gt;&lt;pre&gt;September  %B     Mon Sep 1 12:19:47 EDT 1986&lt;/pre&gt;
&lt;DD&gt;&lt;br&gt; &lt;DT&gt;&lt;pre&gt;January    %B     Thu Jan 1 12:19:47 EST 1987&lt;/pre&gt;
&lt;DD&gt;&lt;br&gt; &lt;DT&gt;&lt;pre&gt;December   %B     Mon Dec 1 12:19:47 EST 1986&lt;/pre&gt;
&lt;DD&gt;&lt;br&gt; &lt;DT&gt;&lt;pre&gt;Sep Mon    %b %a  Mon Sep 1 12:19:47 EDT 1986&lt;/pre&gt;
&lt;DD&gt;&lt;br&gt; &lt;DT&gt;&lt;pre&gt;Jan Fri    %b %a  Fri Jan 2 12:19:47 EST 1987&lt;/pre&gt;
&lt;DD&gt;&lt;br&gt; &lt;DT&gt;&lt;pre&gt;Dec Mon    %b %a  Mon Dec 1 12:19:47 EST 1986&lt;/pre&gt;
&lt;DD&gt;&lt;br&gt; &lt;DT&gt;&lt;pre&gt;Jan Wed 1989   %b %a %Y  Wed Jan 4 12:19:47 EST 1989&lt;/pre&gt;
&lt;DD&gt;&lt;br&gt; &lt;DT&gt;&lt;pre&gt;Fri 9      %a %H  Fri Sep 26 09:00:00 EDT 1986&lt;/pre&gt;
&lt;DD&gt;&lt;br&gt; &lt;DT&gt;&lt;pre&gt;Feb 10:30  %b %H:%S  Sun Feb 1 10:00:30 EST 1987&lt;/pre&gt;
&lt;DD&gt;&lt;br&gt; &lt;DT&gt;&lt;pre&gt;10:30      %H:%M  Tue Sep 23 10:30:00 EDT 1986&lt;/pre&gt;
&lt;DD&gt;&lt;br&gt; &lt;DT&gt;&lt;pre&gt;13:30      %H:%M  Mon Sep 22 13:30:00 EDT 1986&lt;/pre&gt;
&lt;DD&gt;&lt;br&gt; &lt;/DL&gt;
         &lt;br&gt;&lt;br&gt; The return value of the function is a pointer to a static variable of
         type &lt;CODE&gt;struct tm&lt;/CODE&gt;, or a null pointer if an error occurred.  The
         result is only valid until the next &lt;CODE&gt;getdate&lt;/CODE&gt; call, making this
         function unusable in multi-threaded applications.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;errno&lt;/CODE&gt; variable is &lt;EM&gt;not&lt;/EM&gt; changed.  Error conditions are
         stored in the global variable &lt;CODE&gt;getdate_err&lt;/CODE&gt;.  See the
         description above for a list of the possible error values.
         &lt;br&gt;&lt;br&gt; &lt;EM&gt;Warning:&lt;/EM&gt; The &lt;CODE&gt;getdate&lt;/CODE&gt; function should &lt;EM&gt;never&lt;/EM&gt; be
         used in SUID-programs.  The reason is obvious: using the
         &lt;CODE&gt;DATEMSK&lt;/CODE&gt; environment variable you can get the function to open
         any arbitrary file and chances are high that with some bogus input
         (such as a binary file) the program will crash.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getdate_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *string"/>
        <parameter content="struct tm *tp"/>
      </prototype>
      <headers>
        <header filename = "time.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getdate_r&lt;/CODE&gt; function is the reentrant counterpart of
         &lt;CODE&gt;getdate&lt;/CODE&gt;.  It does not use the global variable &lt;CODE&gt;getdate_err&lt;/CODE&gt;
         to signal an error, but instead returns an error code.  The same error
         codes as described in the &lt;CODE&gt;getdate_err&lt;/CODE&gt; documentation above are
         used, with 0 meaning success.
         &lt;br&gt;&lt;br&gt; Moreover, &lt;CODE&gt;getdate_r&lt;/CODE&gt; stores the broken-down time in the variable
         of type &lt;CODE&gt;struct tm&lt;/CODE&gt; pointed to by the second argument, rather than
         in a static variable.
         &lt;br&gt;&lt;br&gt; This function is not defined in the Unix standard.  Nevertheless it is
         available on some other Unix systems as well.
         &lt;br&gt;&lt;br&gt; The warning against using &lt;CODE&gt;getdate&lt;/CODE&gt; in SUID-programs applies to
         &lt;CODE&gt;getdate_r&lt;/CODE&gt; as well.
        </synopsis>
    </function>
  </construct>
  <construct id="function-tzset" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "time.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;tzset&lt;/CODE&gt; function initializes the &lt;CODE&gt;tzname&lt;/CODE&gt; variable from
         the value of the &lt;CODE&gt;TZ&lt;/CODE&gt; environment variable.  It is not usually
         necessary for your program to call this function, because it is called
         automatically when you use the other time conversion functions that
         depend on the time zone.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-itimerval" type="struct">
    <structure>
        <synopsis>
        This structure is used to specify when a timer should expire.  It contains
         the following members:
        </synopsis>
      <elements>
        <element content="struct timeval it_interval">
            <synopsis>
            This is the period between successive timer interrupts.  If zero, the
             alarm will only be sent once.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-setitimer" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int which"/>
        <parameter content="struct itimerval *new"/>
        <parameter content="struct itimerval *old"/>
      </prototype>
      <headers>
        <header filename = "time.h"/>
        <header filename = "sys/time.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;setitimer&lt;/CODE&gt; function sets the timer specified by &lt;VAR&gt;which&lt;/VAR&gt;
         according to &lt;VAR&gt;new&lt;/VAR&gt;.  The &lt;VAR&gt;which&lt;/VAR&gt; argument can have a value of
         &lt;CODE&gt;ITIMER_REAL&lt;/CODE&gt;, &lt;CODE&gt;ITIMER_VIRTUAL&lt;/CODE&gt;, or &lt;CODE&gt;ITIMER_PROF&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;old&lt;/VAR&gt; is not a null pointer, &lt;CODE&gt;setitimer&lt;/CODE&gt; returns information
         about any previous unexpired timer of the same kind in the structure it
         points to.
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; on success and &lt;CODE&gt;-1&lt;/CODE&gt; on failure.  The
         following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EINVAL&lt;/CODE&gt;
&lt;DD&gt;
         The timer period is too large.

        </synopsis>
    </function>
  </construct>
  <construct id="function-getitimer" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int which"/>
        <parameter content="struct itimerval *old"/>
      </prototype>
      <headers>
        <header filename = "sys/time.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getitimer&lt;/CODE&gt; function stores information about the timer specified
         by &lt;VAR&gt;which&lt;/VAR&gt; in the structure pointed at by &lt;VAR&gt;old&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The return value and error conditions are the same as for &lt;CODE&gt;setitimer&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-alarm" type="function">
    <function returntype="unsigned int">
      <prototype>
        <parameter content="unsigned int seconds"/>
      </prototype>
      <headers>
        <header filename = "sys/time.h"/>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;alarm&lt;/CODE&gt; function sets the real-time timer to expire in
         &lt;VAR&gt;seconds&lt;/VAR&gt; seconds.  If you want to cancel any existing alarm, you
         can do this by calling &lt;CODE&gt;alarm&lt;/CODE&gt; with a &lt;VAR&gt;seconds&lt;/VAR&gt; argument of
         zero.
         &lt;br&gt;&lt;br&gt; The return value indicates how many seconds remain before the previous
         alarm would have been sent.  If there is no previous alarm, &lt;CODE&gt;alarm&lt;/CODE&gt;
         returns zero.
        </synopsis>
    </function>
  </construct>
  <construct id="function-sleep" type="function">
    <function returntype="unsigned int">
      <prototype>
        <parameter content="unsigned int seconds"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;sleep&lt;/CODE&gt; function waits for &lt;VAR&gt;seconds&lt;/VAR&gt; or until a signal
         is delivered, whichever happens first.
         &lt;br&gt;&lt;br&gt; If &lt;CODE&gt;sleep&lt;/CODE&gt; function returns because the requested interval is over,
         it returns a value of zero.  If it returns because of delivery of a
         signal, its return value is the remaining time in the sleep interval.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;sleep&lt;/CODE&gt; function is declared in &lt;TT&gt;unistd.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-nanosleep" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const struct timespec *requested_time"/>
        <parameter content="struct timespec *remaining"/>
      </prototype>
      <headers>
        <header filename = "time.h"/>
      </headers>
        <synopsis>
        If resolution to seconds is not enough the &lt;CODE&gt;nanosleep&lt;/CODE&gt; function can
         be used.  As the name suggests the sleep interval can be specified in
         nanoseconds.  The actual elapsed time of the sleep interval might be
         longer since the system rounds the elapsed time you request up to the
         next integer multiple of the actual resolution the system can deliver.
         &lt;br&gt;&lt;br&gt; *&lt;CODE&gt;requested_time&lt;/CODE&gt; is the elapsed time of the interval you want to
         sleep.
         &lt;br&gt;&lt;br&gt; The function returns as *&lt;CODE&gt;remaining&lt;/CODE&gt; the elapsed time left in the
         interval for which you requested to sleep.  If the interval completed
         without getting interrupted by a signal, this is zero.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;struct timespec&lt;/CODE&gt; is described in .
         &lt;br&gt;&lt;br&gt; If the function returns because the interval is over the return value is
         zero.  If the function returns -1 the global variable &lt;VAR&gt;errno&lt;/VAR&gt;
         is set to the following values:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EINTR&lt;/CODE&gt;
&lt;DD&gt;
         The call was interrupted because a signal was delivered to the thread.
         If the &lt;VAR&gt;remaining&lt;/VAR&gt; parameter is not the null pointer the structure
         pointed to by &lt;VAR&gt;remaining&lt;/VAR&gt; is updated to contain the remaining
         elapsed time.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         The nanosecond value in the &lt;VAR&gt;requested_time&lt;/VAR&gt; parameter contains an
         illegal value.  Either the value is negative or greater than or equal to
         1000 million.

         &lt;br&gt;&lt;br&gt; This function is a cancellation point in multi-threaded programs.  This
         is a problem if the thread allocates some resources (like memory, file
         descriptors, semaphores or whatever) at the time &lt;CODE&gt;nanosleep&lt;/CODE&gt; is
         called.  If the thread gets canceled these resources stay allocated
         until the program ends.  To avoid this calls to &lt;CODE&gt;nanosleep&lt;/CODE&gt; should
         be protected using cancellation handlers.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;nanosleep&lt;/CODE&gt; function is declared in &lt;TT&gt;time.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-va_list" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="dtype-ptrdiff_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="dtype-size_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="function-system" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *command"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        This function executes &lt;VAR&gt;command&lt;/VAR&gt; as a shell command.  In the GNU C
         library, it always uses the default shell &lt;CODE&gt;sh&lt;/CODE&gt; to run the command.
         In particular, it searches the directories in &lt;CODE&gt;PATH&lt;/CODE&gt; to find
         programs to execute.  The return value is &lt;CODE&gt;-1&lt;/CODE&gt; if it wasn't
         possible to create the shell process, and otherwise is the status of the
         shell process.  , for details on how this
         status code can be interpreted.
         &lt;br&gt;&lt;br&gt; If the &lt;VAR&gt;command&lt;/VAR&gt; argument is a null pointer, a return value of zero
         indicates that no command processor is available.
         &lt;br&gt;&lt;br&gt; This function is a cancellation point in multi-threaded programs.  This
         is a problem if the thread allocates some resources (like memory, file
         descriptors, semaphores or whatever) at the time &lt;CODE&gt;system&lt;/CODE&gt; is
         called.  If the thread gets canceled these resources stay allocated
         until the program ends.  To avoid this calls to &lt;CODE&gt;system&lt;/CODE&gt; should be
         protected using cancellation handlers.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;system&lt;/CODE&gt; function is declared in the header file
         &lt;TT&gt;stdlib.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-pid_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="function-getpid" type="function">
    <function returntype="pid_t">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "sys/types.h"/>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getpid&lt;/CODE&gt; function returns the process ID of the current process.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getppid" type="function">
    <function returntype="pid_t">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getppid&lt;/CODE&gt; function returns the process ID of the parent of the
         current process.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fork" type="function">
    <function returntype="pid_t">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fork&lt;/CODE&gt; function creates a new process.
         &lt;br&gt;&lt;br&gt; If the operation is successful, there are then both parent and child
         processes and both see &lt;CODE&gt;fork&lt;/CODE&gt; return, but with different values: it
         returns a value of &lt;CODE&gt;0&lt;/CODE&gt; in the child process and returns the child's
         process ID in the parent process.
         &lt;br&gt;&lt;br&gt; If process creation failed, &lt;CODE&gt;fork&lt;/CODE&gt; returns a value of &lt;CODE&gt;-1&lt;/CODE&gt; in
         the parent process.  The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are
         defined for &lt;CODE&gt;fork&lt;/CODE&gt;:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EAGAIN&lt;/CODE&gt;
&lt;DD&gt;
         There aren't enough system resources to create another process, or the
         user already has too many processes running.  This means exceeding the
         &lt;CODE&gt;RLIMIT_NPROC&lt;/CODE&gt; resource limit, which can usually be increased;
         .
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOMEM
         The process requires more space than the system can supply.

        </synopsis>
    </function>
  </construct>
  <construct id="function-vfork" type="function">
    <function returntype="pid_t">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;vfork&lt;/CODE&gt; function is similar to &lt;CODE&gt;fork&lt;/CODE&gt; but on some systems
         it is more efficient; however, there are restrictions you must follow to
         use it safely.
         &lt;br&gt;&lt;br&gt; While &lt;CODE&gt;fork&lt;/CODE&gt; makes a complete copy of the calling process's address
         space and allows both the parent and child to execute independently,
         &lt;CODE&gt;vfork&lt;/CODE&gt; does not make this copy.  Instead, the child process
         created with &lt;CODE&gt;vfork&lt;/CODE&gt; shares its parent's address space until it
         calls &lt;CODE&gt;_exit&lt;/CODE&gt; or one of the &lt;CODE&gt;exec&lt;/CODE&gt; functions.  In the
         meantime, the parent process suspends execution.
         &lt;br&gt;&lt;br&gt; You must be very careful not to allow the child process created with
         &lt;CODE&gt;vfork&lt;/CODE&gt; to modify any global data or even local variables shared
         with the parent.  Furthermore, the child process cannot return from (or
         do a long jump out of) the function that called &lt;CODE&gt;vfork&lt;/CODE&gt;!  This
         would leave the parent process's control information very confused.  If
         in doubt, use &lt;CODE&gt;fork&lt;/CODE&gt; instead.
         &lt;br&gt;&lt;br&gt; Some operating systems don't really implement &lt;CODE&gt;vfork&lt;/CODE&gt;.  The GNU C
         library permits you to use &lt;CODE&gt;vfork&lt;/CODE&gt; on all systems, but actually
         executes &lt;CODE&gt;fork&lt;/CODE&gt; if &lt;CODE&gt;vfork&lt;/CODE&gt; isn't available.  If you follow
         the proper precautions for using &lt;CODE&gt;vfork&lt;/CODE&gt;, your program will still
         work even if the system uses &lt;CODE&gt;fork&lt;/CODE&gt; instead.
        </synopsis>
    </function>
  </construct>
  <construct id="function-execv" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="char *const argv[]"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;execv&lt;/CODE&gt; function executes the file named by &lt;VAR&gt;filename&lt;/VAR&gt; as a
         new process image.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;argv&lt;/VAR&gt; argument is an array of null-terminated strings that is
         used to provide a value for the &lt;CODE&gt;argv&lt;/CODE&gt; argument to the &lt;CODE&gt;main&lt;/CODE&gt;
         function of the program to be executed.  The last element of this array
         must be a null pointer.  By convention, the first element of this array
         is the file name of the program sans directory names.  , for full details on how programs can access these arguments.
         &lt;br&gt;&lt;br&gt; The environment for the new process image is taken from the
         &lt;CODE&gt;environ&lt;/CODE&gt; variable of the current process image; see
         Environment Variables, for information about environments.
        </synopsis>
    </function>
  </construct>
  <construct id="function-execl" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="const char *arg0"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        This is similar to &lt;CODE&gt;execv&lt;/CODE&gt;, but the &lt;VAR&gt;argv&lt;/VAR&gt; strings are
         specified individually instead of as an array.  A null pointer must be
         passed as the last such argument.
        </synopsis>
    </function>
  </construct>
  <construct id="function-execve" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="char *const argv[]"/>
        <parameter content="char *const env[]"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        This is similar to &lt;CODE&gt;execv&lt;/CODE&gt;, but permits you to specify the environment
         for the new program explicitly as the &lt;VAR&gt;env&lt;/VAR&gt; argument.  This should
         be an array of strings in the same format as for the &lt;CODE&gt;environ&lt;/CODE&gt;
         variable; see Environment Access.
        </synopsis>
    </function>
  </construct>
  <construct id="function-execle" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="const char *arg0"/>
        <parameter content="char *const env[]"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        This is similar to &lt;CODE&gt;execl&lt;/CODE&gt;, but permits you to specify the
         environment for the new program explicitly.  The environment argument is
         passed following the null pointer that marks the last &lt;VAR&gt;argv&lt;/VAR&gt;
         argument, and should be an array of strings in the same format as for
         the &lt;CODE&gt;environ&lt;/CODE&gt; variable.
        </synopsis>
    </function>
  </construct>
  <construct id="function-execvp" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="char *const argv[]"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;execvp&lt;/CODE&gt; function is similar to &lt;CODE&gt;execv&lt;/CODE&gt;, except that it
         searches the directories listed in the &lt;CODE&gt;PATH&lt;/CODE&gt; environment variable
          to find the full file name of a
         file from &lt;VAR&gt;filename&lt;/VAR&gt; if &lt;VAR&gt;filename&lt;/VAR&gt; does not contain a slash.
         &lt;br&gt;&lt;br&gt; This function is useful for executing system utility programs, because
         it looks for them in the places that the user has chosen.  Shells use it
         to run the commands that users type.
        </synopsis>
    </function>
  </construct>
  <construct id="function-execlp" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="const char *arg0"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        This function is like &lt;CODE&gt;execl&lt;/CODE&gt;, except that it performs the same
         file name searching as the &lt;CODE&gt;execvp&lt;/CODE&gt; function.
        </synopsis>
    </function>
  </construct>
  <construct id="function-waitpid" type="function">
    <function returntype="pid_t">
      <prototype>
        <parameter content="pid_t pid"/>
        <parameter content="int *status-ptr"/>
        <parameter content="int options"/>
      </prototype>
      <headers>
        <header filename = "sys/wait.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;waitpid&lt;/CODE&gt; function is used to request status information from a
         child process whose process ID is &lt;VAR&gt;pid&lt;/VAR&gt;.  Normally, the calling
         process is suspended until the child process makes status information
         available by terminating.
         &lt;br&gt;&lt;br&gt; Other values for the &lt;VAR&gt;pid&lt;/VAR&gt; argument have special interpretations.  A
         value of &lt;CODE&gt;-1&lt;/CODE&gt; or &lt;CODE&gt;WAIT_ANY&lt;/CODE&gt; requests status information for
         any child process; a value of &lt;CODE&gt;0&lt;/CODE&gt; or &lt;CODE&gt;WAIT_MYPGRP&lt;/CODE&gt; requests
         information for any child process in the same process group as the
         calling process; and any other negative value  &lt;VAR&gt;pgid&lt;/VAR&gt;
         requests information for any child process whose process group ID is
         &lt;VAR&gt;pgid&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If status information for a child process is available immediately, this
         function returns immediately without waiting.  If more than one eligible
         child process has status information available, one of them is chosen
         randomly, and its status is returned immediately.  To get the status
         from the other eligible child processes, you need to call &lt;CODE&gt;waitpid&lt;/CODE&gt;
         again.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;options&lt;/VAR&gt; argument is a bit mask.  Its value should be the
         bitwise OR (that is, the &lt;samp&gt;|&lt;/samp&gt; operator) of zero or more of the
         &lt;CODE&gt;WNOHANG&lt;/CODE&gt; and &lt;CODE&gt;WUNTRACED&lt;/CODE&gt; flags.  You can use the
         &lt;CODE&gt;WNOHANG&lt;/CODE&gt; flag to indicate that the parent process shouldn't wait;
         and the &lt;CODE&gt;WUNTRACED&lt;/CODE&gt; flag to request status information from stopped
         processes as well as processes that have terminated.
         &lt;br&gt;&lt;br&gt; The status information from the child process is stored in the object
         that &lt;VAR&gt;status-ptr&lt;/VAR&gt; points to, unless &lt;VAR&gt;status-ptr&lt;/VAR&gt; is a null pointer.
         &lt;br&gt;&lt;br&gt; This function is a cancellation point in multi-threaded programs.  This
         is a problem if the thread allocates some resources (like memory, file
         descriptors, semaphores or whatever) at the time &lt;CODE&gt;waitpid&lt;/CODE&gt; is
         called.  If the thread gets canceled these resources stay allocated
         until the program ends.  To avoid this calls to &lt;CODE&gt;waitpid&lt;/CODE&gt; should be
         protected using cancellation handlers.
         &lt;br&gt;&lt;br&gt; The return value is normally the process ID of the child process whose
         status is reported.  If there are child processes but none of them is
         waiting to be noticed, &lt;CODE&gt;waitpid&lt;/CODE&gt; will block until one is.  However,
         if the &lt;CODE&gt;WNOHANG&lt;/CODE&gt; option was specified, &lt;CODE&gt;waitpid&lt;/CODE&gt; will return
         zero instead of blocking.
         &lt;br&gt;&lt;br&gt; If a specific PID to wait for was given to &lt;CODE&gt;waitpid&lt;/CODE&gt;, it will
         ignore all other children (if any).  Therefore if there are children
         waiting to be noticed but the child whose PID was specified is not one
         of them, &lt;CODE&gt;waitpid&lt;/CODE&gt; will block or return zero as described above.
         &lt;br&gt;&lt;br&gt; A value of &lt;CODE&gt;-1&lt;/CODE&gt; is returned in case of error.  The following
         &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EINTR&lt;/CODE&gt;
&lt;DD&gt;
         The function was interrupted by delivery of a signal to the calling
         process.  .
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ECHILD
         There are no child processes to wait for, or the specified &lt;VAR&gt;pid&lt;/VAR&gt;
         is not a child of the calling process.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         An invalid value was provided for the &lt;VAR&gt;options&lt;/VAR&gt; argument.

        </synopsis>
    </function>
  </construct>
  <construct id="function-wait" type="function">
    <function returntype="pid_t">
      <prototype>
        <parameter content="int *status-ptr"/>
      </prototype>
      <headers>
        <header filename = "sys/wait.h"/>
      </headers>
        <synopsis>
        This is a simplified version of &lt;CODE&gt;waitpid&lt;/CODE&gt;, and is used to wait
         until any one child process terminates.  The call:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         wait (&amp;status)&lt;br&gt;
         &lt;/pre&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;br&gt;
         is exactly equivalent to:&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         waitpid (-1, &amp;status, 0)&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; This function is a cancellation point in multi-threaded programs.  This
         is a problem if the thread allocates some resources (like memory, file
         descriptors, semaphores or whatever) at the time &lt;CODE&gt;wait&lt;/CODE&gt; is
         called.  If the thread gets canceled these resources stay allocated
         until the program ends.  To avoid this calls to &lt;CODE&gt;wait&lt;/CODE&gt; should be
         protected using cancellation handlers.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wait4" type="function">
    <function returntype="pid_t">
      <prototype>
        <parameter content="pid_t pid"/>
        <parameter content="int *status-ptr"/>
        <parameter content="int options"/>
        <parameter content="struct rusage *usage"/>
      </prototype>
      <headers>
        <header filename = "sys/wait.h"/>
      </headers>
        <synopsis>
        If &lt;VAR&gt;usage&lt;/VAR&gt; is a null pointer, &lt;CODE&gt;wait4&lt;/CODE&gt; is equivalent to
         &lt;CODE&gt;waitpid (&lt;VAR&gt;pid&lt;/VAR&gt;, &lt;VAR&gt;status-ptr&lt;/VAR&gt;, &lt;VAR&gt;options&lt;/VAR&gt;)&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;usage&lt;/VAR&gt; is not null, &lt;CODE&gt;wait4&lt;/CODE&gt; stores usage figures for the
         child process in &lt;CODE&gt;*&lt;VAR&gt;rusage&lt;/VAR&gt;&lt;/CODE&gt; (but only if the child has
         terminated, not if it has stopped).  .
         &lt;br&gt;&lt;br&gt; This function is a BSD extension.
        </synopsis>
    </function>
  </construct>
  <construct id="union-wait" type="union">
    <structure>
        <synopsis>
        This data type represents program termination status values.  It has
         the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="int w_termsig">
            <synopsis>
            The value of this member is the same as that of the
             &lt;CODE&gt;WTERMSIG&lt;/CODE&gt; macro.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int w_coredump">
            <synopsis>
            The value of this member is the same as that of the
             &lt;CODE&gt;WCOREDUMP&lt;/CODE&gt; macro.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int w_retcode">
            <synopsis>
            The value of this member is the same as that of the
             &lt;CODE&gt;WEXITSTATUS&lt;/CODE&gt; macro.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-wait3" type="function">
    <function returntype="pid_t">
      <prototype>
        <parameter content="union wait *status-ptr"/>
        <parameter content="int options"/>
        <parameter content="struct rusage *usage"/>
      </prototype>
      <headers>
        <header filename = "sys/wait.h"/>
      </headers>
        <synopsis>
        If &lt;VAR&gt;usage&lt;/VAR&gt; is a null pointer, &lt;CODE&gt;wait3&lt;/CODE&gt; is equivalent to
         &lt;CODE&gt;waitpid (-1, &lt;VAR&gt;status-ptr&lt;/VAR&gt;, &lt;VAR&gt;options&lt;/VAR&gt;)&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;usage&lt;/VAR&gt; is not null, &lt;CODE&gt;wait3&lt;/CODE&gt; stores usage figures for the
         child process in &lt;CODE&gt;*&lt;VAR&gt;rusage&lt;/VAR&gt;&lt;/CODE&gt; (but only if the child has
         terminated, not if it has stopped).  .
        </synopsis>
    </function>
  </construct>
  <construct id="function-getcwd" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="char *buffer"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getcwd&lt;/CODE&gt; function returns an absolute file name representing
         the current working directory, storing it in the character array
         &lt;VAR&gt;buffer&lt;/VAR&gt; that you provide.  The &lt;VAR&gt;size&lt;/VAR&gt; argument is how you tell
         the system the allocation size of &lt;VAR&gt;buffer&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The GNU library version of this function also permits you to specify a
         null pointer for the &lt;VAR&gt;buffer&lt;/VAR&gt; argument.  Then &lt;CODE&gt;getcwd&lt;/CODE&gt;
         allocates a buffer automatically, as with &lt;CODE&gt;malloc&lt;/CODE&gt;
         .  If the &lt;VAR&gt;size&lt;/VAR&gt; is greater than
         zero, then the buffer is that large; otherwise, the buffer is as large
         as necessary to hold the result.
         &lt;br&gt;&lt;br&gt; The return value is &lt;VAR&gt;buffer&lt;/VAR&gt; on success and a null pointer on failure.
         The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EINVAL&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;size&lt;/VAR&gt; argument is zero and &lt;VAR&gt;buffer&lt;/VAR&gt; is not a null pointer.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ERANGE
         The &lt;VAR&gt;size&lt;/VAR&gt; argument is less than the length of the working directory
         name.  You need to allocate a bigger array and try again.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EACCES
         Permission to read or search a component of the file name was denied.

        </synopsis>
    </function>
  </construct>
  <construct id="function-get_current_dir_name" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>

         This &lt;CODE&gt;get_current_dir_name&lt;/CODE&gt; function is basically equivalent to
         &lt;CODE&gt;getcwd (NULL, 0)&lt;/CODE&gt;.  The only difference is that the value of
         the &lt;CODE&gt;PWD&lt;/CODE&gt; variable is returned if this value is correct.  This is a
         subtle difference which is visible if the path described by the
         &lt;CODE&gt;PWD&lt;/CODE&gt; value is using one or more symbol links in which case the
         value returned by &lt;CODE&gt;getcwd&lt;/CODE&gt; can resolve the symbol links and
         therefore yield a different result.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-chdir" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        This function is used to set the process's working directory to
         &lt;VAR&gt;filename&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The normal, successful return value from &lt;CODE&gt;chdir&lt;/CODE&gt; is &lt;CODE&gt;0&lt;/CODE&gt;.  A
         value of &lt;CODE&gt;-1&lt;/CODE&gt; is returned to indicate an error.  The &lt;CODE&gt;errno&lt;/CODE&gt;
         error conditions defined for this function are the usual file name
         syntax errors , plus &lt;CODE&gt;ENOTDIR&lt;/CODE&gt; if the
         file &lt;VAR&gt;filename&lt;/VAR&gt; is not a directory.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fchdir" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int filedes"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        This function is used to set the process's working directory to
         directory associated with the file descriptor &lt;VAR&gt;filedes&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The normal, successful return value from &lt;CODE&gt;fchdir&lt;/CODE&gt; is &lt;CODE&gt;0&lt;/CODE&gt;.  A
         value of &lt;CODE&gt;-1&lt;/CODE&gt; is returned to indicate an error.  The following
         &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EACCES&lt;/CODE&gt;
&lt;DD&gt;
         Read permission is denied for the directory named by &lt;CODE&gt;dirname&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EBADF
         The &lt;VAR&gt;filedes&lt;/VAR&gt; argument is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOTDIR
         The file descriptor &lt;VAR&gt;filedes&lt;/VAR&gt; is not associated with a directory.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINTR
         The function call was interrupt by a signal.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EIO
         An I/O error occurred.

        </synopsis>
    </function>
  </construct>
  <construct id="struct-dirent" type="struct">
    <structure>
        <synopsis>
        This is a structure type used to return information about directory
         entries.  It contains the following fields:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="char d_name[]">
            <synopsis>
            This is the null-terminated file name component.  This is the only
             field you can count on in all POSIX systems.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="ino_t d_fileno">
            <synopsis>
            This is the file serial number.  For BSD compatibility, you can also
             refer to this member as &lt;CODE&gt;d_ino&lt;/CODE&gt;.  In the GNU system and most POSIX
             systems, for most files this the same as the &lt;CODE&gt;st_ino&lt;/CODE&gt; member that
             &lt;CODE&gt;stat&lt;/CODE&gt; will return for the file.  .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="unsigned char d_namlen">
            <synopsis>
            This is the length of the file name, not including the terminating null
             character.  Its type is &lt;CODE&gt;unsigned char&lt;/CODE&gt; because that is the integer
             type of the appropriate size
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="unsigned char d_type">
            <synopsis>
            This is the type of the file, possibly unknown.  The following constants
             are defined for its value:
             &lt;br&gt;&lt;br&gt; &lt;DL&gt;

            </synopsis>
        </element>
        <element content="DT_UNKNOWN">
            <synopsis>
            The type is unknown.  On some systems this is the only value returned.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="DT_REG">
            <synopsis>
            A regular file.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="DT_DIR">
            <synopsis>
            A directory.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="DT_FIFO">
            <synopsis>
            A named pipe, or FIFO.  .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="DT_SOCK">
            <synopsis>
            A local-domain socket.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="DT_CHR">
            <synopsis>
            A character device.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="dtype-DIR" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="function-opendir" type="function">
    <function returntype="DIR *">
      <prototype>
        <parameter content="const char *dirname"/>
      </prototype>
      <headers>
        <header filename = "dirent.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;opendir&lt;/CODE&gt; function opens and returns a directory stream for
         reading the directory whose file name is &lt;VAR&gt;dirname&lt;/VAR&gt;.  The stream has
         type &lt;CODE&gt;DIR *&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; If unsuccessful, &lt;CODE&gt;opendir&lt;/CODE&gt; returns a null pointer.  In addition to
         the usual file name errors , the
         following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EACCES&lt;/CODE&gt;
&lt;DD&gt;
         Read permission is denied for the directory named by &lt;CODE&gt;dirname&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EMFILE
         The process has too many files open.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENFILE
         The entire system, or perhaps the file system which contains the
         directory, cannot support any additional open files at the moment.
         (This problem cannot happen on the GNU system.)
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOMEM
         Not enough memory available.

         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;DIR&lt;/CODE&gt; type is typically implemented using a file descriptor,
         and the &lt;CODE&gt;opendir&lt;/CODE&gt; function in terms of the &lt;CODE&gt;open&lt;/CODE&gt; function.
         .  Directory streams and the underlying
         file descriptors are closed on &lt;CODE&gt;exec&lt;/CODE&gt; .
        </synopsis>
    </function>
  </construct>
  <construct id="function-fdopendir" type="function">
    <function returntype="DIR *">
      <prototype>
        <parameter content="int fd"/>
      </prototype>
      <headers>
        <header filename = "dirent.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fdopendir&lt;/CODE&gt; function works just like &lt;CODE&gt;opendir&lt;/CODE&gt; but
         instead of taking a file name and opening a file descriptor for the
         directory the caller is required to provide a file descriptor.  This
         file descriptor is then used in subsequent uses of the returned
         directory stream object.
         &lt;br&gt;&lt;br&gt; The caller must make sure the file descriptor is associated with a
         directory and it allows reading.
         &lt;br&gt;&lt;br&gt; If the &lt;CODE&gt;fdopendir&lt;/CODE&gt; call returns successfully the file descriptor
         is now under the control of the system.  It can be used in the same
         way the descriptor implicitly created by &lt;CODE&gt;opendir&lt;/CODE&gt; can be used
         but the program must not close the descriptor.
         &lt;br&gt;&lt;br&gt; In case the function is unsuccessful it returns a null pointer and the
         file descriptor remains to be usable by the program.  The following
         &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The file descriptor is not valid.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOTDIR
         The file descriptor is not associated with a directory.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         The descriptor does not allow reading the directory content.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOMEM
         Not enough memory available.

        </synopsis>
    </function>
  </construct>
  <construct id="function-dirfd" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="DIR *dirstream"/>
      </prototype>
      <headers>
        <header filename = "dirent.h"/>
      </headers>
        <synopsis>
        The function &lt;CODE&gt;dirfd&lt;/CODE&gt; returns the file descriptor associated with
         the directory stream &lt;VAR&gt;dirstream&lt;/VAR&gt;.  This descriptor can be used until
         the directory is closed with &lt;CODE&gt;closedir&lt;/CODE&gt;.  If the directory stream
         implementation is not using file descriptors the return value is
         &lt;CODE&gt;-1&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-readdir" type="function">
    <function returntype="struct dirent *">
      <prototype>
        <parameter content="DIR *dirstream"/>
      </prototype>
      <headers>
        <header filename = "dirent.h"/>
      </headers>
        <synopsis>
        This function reads the next entry from the directory.  It normally
         returns a pointer to a structure containing information about the file.
         This structure is statically allocated and can be rewritten by a
         subsequent call.
         &lt;br&gt;&lt;br&gt; Portability Note: On some systems &lt;CODE&gt;readdir&lt;/CODE&gt; may not
         return entries for &lt;TT&gt;.&lt;/TT&gt; and &lt;TT&gt;..&lt;/TT&gt;, even though these are always
         valid file names in any directory.  .
         &lt;br&gt;&lt;br&gt; If there are no more entries in the directory or an error is detected,
         &lt;CODE&gt;readdir&lt;/CODE&gt; returns a null pointer.  The following &lt;CODE&gt;errno&lt;/CODE&gt; error
         conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;dirstream&lt;/VAR&gt; argument is not valid.

         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;readdir&lt;/CODE&gt; is not thread safe.  Multiple threads using
         &lt;CODE&gt;readdir&lt;/CODE&gt; on the same &lt;VAR&gt;dirstream&lt;/VAR&gt; may overwrite the return
         value.  Use &lt;CODE&gt;readdir_r&lt;/CODE&gt; when this is critical.
        </synopsis>
    </function>
  </construct>
  <construct id="function-readdir_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="DIR *dirstream"/>
        <parameter content="struct dirent *entry"/>
        <parameter content="struct dirent **result"/>
      </prototype>
      <headers>
        <header filename = "dirent.h"/>
      </headers>
        <synopsis>
        This function is the reentrant version of &lt;CODE&gt;readdir&lt;/CODE&gt;.  Like
         &lt;CODE&gt;readdir&lt;/CODE&gt; it returns the next entry from the directory.  But to
         prevent conflicts between simultaneously running threads the result is
         not stored in statically allocated memory.  Instead the argument
         &lt;VAR&gt;entry&lt;/VAR&gt; points to a place to store the result.
         &lt;br&gt;&lt;br&gt; Normally &lt;CODE&gt;readdir_r&lt;/CODE&gt; returns zero and sets &lt;CODE&gt;*&lt;VAR&gt;result&lt;/VAR&gt;&lt;/CODE&gt;
         to &lt;VAR&gt;entry&lt;/VAR&gt;.  If there are no more entries in the directory or an
         error is detected, &lt;CODE&gt;readdir_r&lt;/CODE&gt; sets &lt;CODE&gt;*&lt;VAR&gt;result&lt;/VAR&gt;&lt;/CODE&gt; to a
         null pointer and returns a nonzero error code, also stored in
         &lt;CODE&gt;errno&lt;/CODE&gt;, as described for &lt;CODE&gt;readdir&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; Portability Note: On some systems &lt;CODE&gt;readdir_r&lt;/CODE&gt; may not
         return a NUL terminated string for the file name, even when there is no
         &lt;CODE&gt;d_reclen&lt;/CODE&gt; field in &lt;CODE&gt;struct dirent&lt;/CODE&gt; and the file
         name is the maximum allowed size.  Modern systems all have the
         &lt;CODE&gt;d_reclen&lt;/CODE&gt; field, and on old systems multi-threading is not
         critical.  In any case there is no such problem with the &lt;CODE&gt;readdir&lt;/CODE&gt;
         function, so that even on systems without the &lt;CODE&gt;d_reclen&lt;/CODE&gt; member one
         could use multiple threads by using external locking.
         &lt;br&gt;&lt;br&gt; It is also important to look at the definition of the &lt;CODE&gt;struct
         dirent&lt;/CODE&gt; type.  Simply passing a pointer to an object of this type for
         the second parameter of &lt;CODE&gt;readdir_r&lt;/CODE&gt; might not be enough.  Some
         systems don't define the &lt;CODE&gt;d_name&lt;/CODE&gt; element sufficiently long.  In
         this case the user has to provide additional space.  There must be room
         for at least &lt;CODE&gt;NAME_MAX + 1&lt;/CODE&gt; characters in the &lt;CODE&gt;d_name&lt;/CODE&gt; array.
         Code to call &lt;CODE&gt;readdir_r&lt;/CODE&gt; could look like this:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
           union&lt;br&gt;
           {&lt;br&gt;
             struct dirent d;&lt;br&gt;
             char b[offsetof (struct dirent, d_name) + NAME_MAX + 1];&lt;br&gt;
           } u;&lt;br&gt;
         &lt;br&gt;&lt;br&gt;   if (readdir_r (dir, &amp;u.d, &amp;res) == 0)&lt;br&gt;
             &lt;small&gt;...&lt;/small&gt;&lt;br&gt;
         &lt;/pre&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-readdir64" type="function">
    <function returntype="struct dirent64 *">
      <prototype>
        <parameter content="DIR *dirstream"/>
      </prototype>
      <headers>
        <header filename = "dirent.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;readdir64&lt;/CODE&gt; function is just like the &lt;CODE&gt;readdir&lt;/CODE&gt; function
         except that it returns a pointer to a record of type &lt;CODE&gt;struct
         dirent64&lt;/CODE&gt;.  Some of the members of this data type (notably &lt;CODE&gt;d_ino&lt;/CODE&gt;)
         might have a different size to allow large filesystems.
         &lt;br&gt;&lt;br&gt; In all other aspects this function is equivalent to &lt;CODE&gt;readdir&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-readdir64_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="DIR *dirstream"/>
        <parameter content="struct dirent64 *entry"/>
        <parameter content="struct dirent64 **result"/>
      </prototype>
      <headers>
        <header filename = "dirent.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;readdir64_r&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;readdir_r&lt;/CODE&gt;
         function except that it takes parameters of base type &lt;CODE&gt;struct
         dirent64&lt;/CODE&gt; instead of &lt;CODE&gt;struct dirent&lt;/CODE&gt; in the second and third
         position.  The same precautions mentioned in the documentation of
         &lt;CODE&gt;readdir_r&lt;/CODE&gt; also apply here.
        </synopsis>
    </function>
  </construct>
  <construct id="function-closedir" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="DIR *dirstream"/>
      </prototype>
      <headers>
        <header filename = "dirent.h"/>
      </headers>
        <synopsis>
        This function closes the directory stream &lt;VAR&gt;dirstream&lt;/VAR&gt;.  It returns
         &lt;CODE&gt;0&lt;/CODE&gt; on success and &lt;CODE&gt;-1&lt;/CODE&gt; on failure.
         &lt;br&gt;&lt;br&gt; The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this
         function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;dirstream&lt;/VAR&gt; argument is not valid.

        </synopsis>
    </function>
  </construct>
  <construct id="function-rewinddir" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="DIR *dirstream"/>
      </prototype>
      <headers>
        <header filename = "dirent.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;rewinddir&lt;/CODE&gt; function is used to reinitialize the directory
         stream &lt;VAR&gt;dirstream&lt;/VAR&gt;, so that if you call &lt;CODE&gt;readdir&lt;/CODE&gt; it
         returns information about the first entry in the directory again.  This
         function also notices if files have been added or removed to the
         directory since it was opened with &lt;CODE&gt;opendir&lt;/CODE&gt;.  (Entries for these
         files might or might not be returned by &lt;CODE&gt;readdir&lt;/CODE&gt; if they were
         added or removed since you last called &lt;CODE&gt;opendir&lt;/CODE&gt; or
         &lt;CODE&gt;rewinddir&lt;/CODE&gt;.)
        </synopsis>
    </function>
  </construct>
  <construct id="function-seekdir" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="DIR *dirstream"/>
        <parameter content="long int pos"/>
      </prototype>
      <headers>
        <header filename = "dirent.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;seekdir&lt;/CODE&gt; function sets the file position of the directory
         stream &lt;VAR&gt;dirstream&lt;/VAR&gt; to &lt;VAR&gt;pos&lt;/VAR&gt;.  The value &lt;VAR&gt;pos&lt;/VAR&gt; must be the
         result of a previous call to &lt;CODE&gt;telldir&lt;/CODE&gt; on this particular stream;
         closing and reopening the directory can invalidate values returned by
         &lt;CODE&gt;telldir&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-scandir" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *dir"/>
        <parameter content="struct dirent ***namelist"/>
        <parameter content="int (*selector) (const struct dirent *)"/>
        <parameter content="int (*cmp) (const void *"/>
        <parameter content="const void *)"/>
      </prototype>
      <headers>
        <header filename = "dirent.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;scandir&lt;/CODE&gt; function scans the contents of the directory selected
         by &lt;VAR&gt;dir&lt;/VAR&gt;.  The result in *&lt;VAR&gt;namelist&lt;/VAR&gt; is an array of pointers to
         structure of type &lt;CODE&gt;struct dirent&lt;/CODE&gt; which describe all selected
         directory entries and which is allocated using &lt;CODE&gt;malloc&lt;/CODE&gt;.  Instead
         of always getting all directory entries returned, the user supplied
         function &lt;VAR&gt;selector&lt;/VAR&gt; can be used to decide which entries are in the
         result.  Only the entries for which &lt;VAR&gt;selector&lt;/VAR&gt; returns a non-zero
         value are selected.
         &lt;br&gt;&lt;br&gt; Finally the entries in *&lt;VAR&gt;namelist&lt;/VAR&gt; are sorted using the
         user-supplied function &lt;VAR&gt;cmp&lt;/VAR&gt;.  The arguments passed to the &lt;VAR&gt;cmp&lt;/VAR&gt;
         function are of type &lt;CODE&gt;struct dirent **&lt;/CODE&gt;, therefore one cannot
         directly use the &lt;CODE&gt;strcmp&lt;/CODE&gt; or &lt;CODE&gt;strcoll&lt;/CODE&gt; functions; instead see
         the functions &lt;CODE&gt;alphasort&lt;/CODE&gt; and &lt;CODE&gt;versionsort&lt;/CODE&gt; below.
         &lt;br&gt;&lt;br&gt; The return value of the function is the number of entries placed in
         *&lt;VAR&gt;namelist&lt;/VAR&gt;.  If it is &lt;CODE&gt;-1&lt;/CODE&gt; an error occurred (either the
         directory could not be opened for reading or the malloc call failed) and
         the global variable &lt;CODE&gt;errno&lt;/CODE&gt; contains more information on the error.
        </synopsis>
    </function>
  </construct>
  <construct id="function-alphasort" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const void *a"/>
        <parameter content="const void *b"/>
      </prototype>
      <headers>
        <header filename = "dirent.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;alphasort&lt;/CODE&gt; function behaves like the &lt;CODE&gt;strcoll&lt;/CODE&gt; function
         .  The difference is that the arguments
         are not string pointers but instead they are of type
         &lt;CODE&gt;struct dirent **&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The return value of &lt;CODE&gt;alphasort&lt;/CODE&gt; is less than, equal to, or greater
         than zero depending on the order of the two entries &lt;VAR&gt;a&lt;/VAR&gt; and &lt;VAR&gt;b&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-versionsort" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const void *a"/>
        <parameter content="const void *b"/>
      </prototype>
      <headers>
        <header filename = "dirent.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;versionsort&lt;/CODE&gt; function is like &lt;CODE&gt;alphasort&lt;/CODE&gt; except that it
         uses the &lt;CODE&gt;strverscmp&lt;/CODE&gt; function internally.
        </synopsis>
    </function>
  </construct>
  <construct id="function-scandir64" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *dir"/>
        <parameter content="struct dirent64 ***namelist"/>
        <parameter content="int (*selector) (const struct dirent64 *)"/>
        <parameter content="int (*cmp) (const void *"/>
        <parameter content="const void *)"/>
      </prototype>
      <headers>
        <header filename = "dirent.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;scandir64&lt;/CODE&gt; function works like the &lt;CODE&gt;scandir&lt;/CODE&gt; function
         except that the directory entries it returns are described by elements
         of type &lt;CODE&gt;struct dirent64&lt;/CODE&gt;.  The function pointed to by
         &lt;VAR&gt;selector&lt;/VAR&gt; is again used to select the desired entries, except that
         &lt;VAR&gt;selector&lt;/VAR&gt; now must point to a function which takes a
         &lt;CODE&gt;struct dirent64 *&lt;/CODE&gt; parameter.
         &lt;br&gt;&lt;br&gt; Similarly the &lt;VAR&gt;cmp&lt;/VAR&gt; function should expect its two arguments to be
         of type &lt;CODE&gt;struct dirent64 **&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-alphasort64" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const void *a"/>
        <parameter content="const void *b"/>
      </prototype>
      <headers>
        <header filename = "dirent.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;alphasort64&lt;/CODE&gt; function behaves like the &lt;CODE&gt;strcoll&lt;/CODE&gt; function
         .  The difference is that the arguments
         are not string pointers but instead they are of type
         &lt;CODE&gt;struct dirent64 **&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; Return value of &lt;CODE&gt;alphasort64&lt;/CODE&gt; is less than, equal to, or greater
         than zero depending on the order of the two entries &lt;VAR&gt;a&lt;/VAR&gt; and &lt;VAR&gt;b&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-versionsort64" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const void *a"/>
        <parameter content="const void *b"/>
      </prototype>
      <headers>
        <header filename = "dirent.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;versionsort64&lt;/CODE&gt; function is like &lt;CODE&gt;alphasort64&lt;/CODE&gt;, excepted that it
         uses the &lt;CODE&gt;strverscmp&lt;/CODE&gt; function internally.
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-__ftw_func_t" type="dtype">
    <structure>
        <synopsis>
        &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         int (*) (const char *, const struct stat *, int)&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; The type of callback functions given to the &lt;CODE&gt;ftw&lt;/CODE&gt; function.  The
         first parameter points to the file name, the second parameter to an
         object of type &lt;CODE&gt;struct stat&lt;/CODE&gt; which is filled in for the file named
         in the first parameter.
         &lt;br&gt;&lt;br&gt;
         The last parameter is a flag giving more information about the current
         file.  It can have the following values:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

        </synopsis>
      <elements>
        <element content="FTW_F">
            <synopsis>
            The item is either a normal file or a file which does not fit into one
             of the following categories.  This could be special files, sockets etc.
            </synopsis>
        </element>
        <element content="FTW_D">
            <synopsis>
            The item is a directory.
            </synopsis>
        </element>
        <element content="FTW_NS">
            <synopsis>
            The &lt;CODE&gt;stat&lt;/CODE&gt; call failed and so the information pointed to by the
             second paramater is invalid.
            </synopsis>
        </element>
        <element content="FTW_DNR">
            <synopsis>
            The item is a directory which cannot be read.
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="dtype-__ftw64_func_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="dtype-__nftw_func_t" type="dtype">
    <structure>
        <synopsis>
        &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         int (*) (const char *, const struct stat *, int, struct FTW *)&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt;

         The first three arguments are the same as for the &lt;CODE&gt;__ftw_func_t&lt;/CODE&gt;
         type.  However for the third argument some additional values are defined
         to allow finer differentiation:
        </synopsis>
      <elements>
        <element content="FTW_DP">
            <synopsis>
            The current item is a directory and all subdirectories have already been
             visited and reported.  This flag is returned instead of &lt;CODE&gt;FTW_D&lt;/CODE&gt; if
             the &lt;CODE&gt;FTW_DEPTH&lt;/CODE&gt; flag is passed to &lt;CODE&gt;nftw&lt;/CODE&gt; (see below).
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="dtype-__nftw64_func_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="struct-FTW" type="struct">
    <structure>
        <synopsis>
        The information contained in this structure helps in interpreting the
         name parameter and gives some information about the current state of the
         traversal of the directory hierarchy.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="int base">
            <synopsis>
            The value is the offset into the string passed in the first parameter to
             the callback function of the beginning of the file name.  The rest of
             the string is the path of the file.  This information is especially
             important if the &lt;CODE&gt;FTW_CHDIR&lt;/CODE&gt; flag was set in calling &lt;CODE&gt;nftw&lt;/CODE&gt;
             since then the current directory is the one the current item is found
             in.
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-ftw" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="__ftw_func_t func"/>
        <parameter content="int descriptors"/>
      </prototype>
      <headers>
        <header filename = "ftw.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;ftw&lt;/CODE&gt; function calls the callback function given in the
         parameter &lt;VAR&gt;func&lt;/VAR&gt; for every item which is found in the directory
         specified by &lt;VAR&gt;filename&lt;/VAR&gt; and all directories below.  The function
         follows symbolic links if necessary but does not process an item twice.
         If &lt;VAR&gt;filename&lt;/VAR&gt; is not a directory then it itself is the only object
         returned to the callback function.
         &lt;br&gt;&lt;br&gt; The file name passed to the callback function is constructed by taking
         the &lt;VAR&gt;filename&lt;/VAR&gt; parameter and appending the names of all passed
         directories and then the local file name.  So the callback function can
         use this parameter to access the file.  &lt;CODE&gt;ftw&lt;/CODE&gt; also calls
         &lt;CODE&gt;stat&lt;/CODE&gt; for the file and passes that information on to the callback
         function.  If this &lt;CODE&gt;stat&lt;/CODE&gt; call was not successful the failure is
         indicated by setting the third argument of the callback function to
         &lt;CODE&gt;FTW_NS&lt;/CODE&gt;.  Otherwise it is set according to the description given
         in the account of &lt;CODE&gt;__ftw_func_t&lt;/CODE&gt; above.
         &lt;br&gt;&lt;br&gt; The callback function is expected to return 0 to indicate that no
         error occurred and that processing should continue.  If an error
         occurred in the callback function or it wants &lt;CODE&gt;ftw&lt;/CODE&gt; to return
         immediately, the callback function can return a value other than
         0.  This is the only correct way to stop the function.  The
         program must not use &lt;CODE&gt;setjmp&lt;/CODE&gt; or similar techniques to continue
         from another place.  This would leave resources allocated by the
         &lt;CODE&gt;ftw&lt;/CODE&gt; function unfreed.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;descriptors&lt;/VAR&gt; parameter to &lt;CODE&gt;ftw&lt;/CODE&gt; specifies how many file
         descriptors it is allowed to consume.  The function runs faster the more
         descriptors it can use.  For each level in the directory hierarchy at
         most one descriptor is used, but for very deep ones any limit on open
         file descriptors for the process or the system may be exceeded.
         Moreover, file descriptor limits in a multi-threaded program apply to
         all the threads as a group, and therefore it is a good idea to supply a
         reasonable limit to the number of open descriptors.
         &lt;br&gt;&lt;br&gt; The return value of the &lt;CODE&gt;ftw&lt;/CODE&gt; function is 0 if all callback
         function calls returned 0 and all actions performed by the
         &lt;CODE&gt;ftw&lt;/CODE&gt; succeeded.  If a function call failed (other than calling
         &lt;CODE&gt;stat&lt;/CODE&gt; on an item) the function returns -1.  If a callback
         function returns a value other than 0 this value is returned as
         the return value of &lt;CODE&gt;ftw&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; on a
         32-bit system this function is in fact &lt;CODE&gt;ftw64&lt;/CODE&gt;, i.e., the LFS
         interface transparently replaces the old interface.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ftw64" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="__ftw64_func_t func"/>
        <parameter content="int descriptors"/>
      </prototype>
      <headers>
        <header filename = "ftw.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;ftw&lt;/CODE&gt; but it can work on filesystems
         with large files.  File information is reported using a variable of type
         &lt;CODE&gt;struct stat64&lt;/CODE&gt; which is passed by reference to the callback
         function.
         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; on a
         32-bit system this function is available under the name &lt;CODE&gt;ftw&lt;/CODE&gt; and
         transparently replaces the old implementation.
        </synopsis>
    </function>
  </construct>
  <construct id="function-nftw" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="__nftw_func_t func"/>
        <parameter content="int descriptors"/>
        <parameter content="int flag"/>
      </prototype>
      <headers>
        <header filename = "ftw.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;nftw&lt;/CODE&gt; function works like the &lt;CODE&gt;ftw&lt;/CODE&gt; functions.  They call
         the callback function &lt;VAR&gt;func&lt;/VAR&gt; for all items found in the directory
         &lt;VAR&gt;filename&lt;/VAR&gt; and below.  At most &lt;VAR&gt;descriptors&lt;/VAR&gt; file descriptors
         are consumed during the &lt;CODE&gt;nftw&lt;/CODE&gt; call.
         &lt;br&gt;&lt;br&gt; One difference is that the callback function is of a different type.  It
         is of type &lt;CODE&gt;struct FTW *&lt;/CODE&gt; and provides the callback function
         with the extra information described above.
         &lt;br&gt;&lt;br&gt; A second difference is that &lt;CODE&gt;nftw&lt;/CODE&gt; takes a fourth argument, which
         is 0 or a bitwise-OR combination of any of the following values.
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;FTW_PHYS&lt;/CODE&gt;
&lt;DD&gt;
         While traversing the directory symbolic links are not followed.  Instead
         symbolic links are reported using the &lt;CODE&gt;FTW_SL&lt;/CODE&gt; value for the type
         parameter to the callback function.  If the file referenced by a
         symbolic link does not exist &lt;CODE&gt;FTW_SLN&lt;/CODE&gt; is returned instead.
         &lt;DT&gt;&lt;CODE&gt;FTW_MOUNT&lt;/CODE&gt;
&lt;DD&gt;
         The callback function is only called for items which are on the same
         mounted filesystem as the directory given by the &lt;VAR&gt;filename&lt;/VAR&gt;
         parameter to &lt;CODE&gt;nftw&lt;/CODE&gt;.
         &lt;DT&gt;&lt;CODE&gt;FTW_CHDIR&lt;/CODE&gt;
&lt;DD&gt;
         If this flag is given the current working directory is changed to the
         directory of the reported object before the callback function is called.
         When &lt;CODE&gt;ntfw&lt;/CODE&gt; finally returns the current directory is restored to
         its original value.
         &lt;DT&gt;&lt;CODE&gt;FTW_DEPTH&lt;/CODE&gt;
&lt;DD&gt;
         If this option is specified then all subdirectories and files within
         them are processed before processing the top directory itself
         (depth-first processing).  This also means the type flag given to the
         callback function is &lt;CODE&gt;FTW_DP&lt;/CODE&gt; and not &lt;CODE&gt;FTW_D&lt;/CODE&gt;.
         &lt;DT&gt;&lt;CODE&gt;FTW_ACTIONRETVAL&lt;/CODE&gt;
&lt;DD&gt;
         If this option is specified then return values from callbacks
         are handled differently.  If the callback returns &lt;CODE&gt;FTW_CONTINUE&lt;/CODE&gt;,
         walking continues normally.  &lt;CODE&gt;FTW_STOP&lt;/CODE&gt; means walking stops
         and &lt;CODE&gt;FTW_STOP&lt;/CODE&gt; is returned to the caller.  If &lt;CODE&gt;FTW_SKIP_SUBTREE&lt;/CODE&gt;
         is returned by the callback with &lt;CODE&gt;FTW_D&lt;/CODE&gt; argument, the subtree
         is skipped and walking continues with next sibling of the directory.
         If &lt;CODE&gt;FTW_SKIP_SIBLINGS&lt;/CODE&gt; is returned by the callback, all siblings
         of the current entry are skipped and walking continues in its parent.
         No other return values should be returned from the callbacks if
         this option is set.  This option is a GNU extension.
         &lt;/DL&gt;
         &lt;br&gt;&lt;br&gt; The return value is computed in the same way as for &lt;CODE&gt;ftw&lt;/CODE&gt;.
         &lt;CODE&gt;nftw&lt;/CODE&gt; returns 0 if no failures occurred and all callback
         functions returned 0.  In case of internal errors, such as memory
         problems, the return value is -1 and &lt;VAR&gt;errno&lt;/VAR&gt; is set
         accordingly.  If the return value of a callback invocation was non-zero
         then that value is returned.
         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; on a
         32-bit system this function is in fact &lt;CODE&gt;nftw64&lt;/CODE&gt;, i.e., the LFS
         interface transparently replaces the old interface.
        </synopsis>
    </function>
  </construct>
  <construct id="function-nftw64" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="__nftw64_func_t func"/>
        <parameter content="int descriptors"/>
        <parameter content="int flag"/>
      </prototype>
      <headers>
        <header filename = "ftw.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;nftw&lt;/CODE&gt; but it can work on filesystems
         with large files.  File information is reported using a variable of type
         &lt;CODE&gt;struct stat64&lt;/CODE&gt; which is passed by reference to the callback
         function.
         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; on a
         32-bit system this function is available under the name &lt;CODE&gt;nftw&lt;/CODE&gt; and
         transparently replaces the old implementation.
        </synopsis>
    </function>
  </construct>
  <construct id="function-link" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *oldname"/>
        <parameter content="const char *newname"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;link&lt;/CODE&gt; function makes a new link to the existing file named by
         &lt;VAR&gt;oldname&lt;/VAR&gt;, under the new name &lt;VAR&gt;newname&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; This function returns a value of &lt;CODE&gt;0&lt;/CODE&gt; if it is successful and
         &lt;CODE&gt;-1&lt;/CODE&gt; on failure.  In addition to the usual file name errors
          for both &lt;VAR&gt;oldname&lt;/VAR&gt; and &lt;VAR&gt;newname&lt;/VAR&gt;, the
         following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EACCES&lt;/CODE&gt;
&lt;DD&gt;
         You are not allowed to write to the directory in which the new link is
         to be written.

         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EEXIST
         There is already a file named &lt;VAR&gt;newname&lt;/VAR&gt;.  If you want to replace
         this link with a new link, you must remove the old link explicitly first.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EMLINK
         There are already too many links to the file named by &lt;VAR&gt;oldname&lt;/VAR&gt;.
         (The maximum number of links to a file is &lt;CODE&gt;LINK_MAX&lt;/CODE&gt;; see
         Limits for Files.)
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOENT
         The file named by &lt;VAR&gt;oldname&lt;/VAR&gt; doesn't exist.  You can't make a link to
         a file that doesn't exist.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOSPC
         The directory or file system that would contain the new link is full
         and cannot be extended.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EPERM
         In the GNU system and some others, you cannot make links to directories.
         Many systems allow only privileged users to do so.  This error
         is used to report the problem.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EROFS
         The directory containing the new link can't be modified because it's on
         a read-only file system.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EXDEV
         The directory specified in &lt;VAR&gt;newname&lt;/VAR&gt; is on a different file system
         than the existing file.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EIO
         A hardware error occurred while trying to read or write the to filesystem.

        </synopsis>
    </function>
  </construct>
  <construct id="function-symlink" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *oldname"/>
        <parameter content="const char *newname"/>
      </prototype>
      <headers>
        <header filename = "sys/param.h"/>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;symlink&lt;/CODE&gt; function makes a symbolic link to &lt;VAR&gt;oldname&lt;/VAR&gt; named
         &lt;VAR&gt;newname&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The normal return value from &lt;CODE&gt;symlink&lt;/CODE&gt; is &lt;CODE&gt;0&lt;/CODE&gt;.  A return value
         of &lt;CODE&gt;-1&lt;/CODE&gt; indicates an error.  In addition to the usual file name
         syntax errors , the following &lt;CODE&gt;errno&lt;/CODE&gt;
         error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EEXIST&lt;/CODE&gt;
&lt;DD&gt;
         There is already an existing file named &lt;VAR&gt;newname&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EROFS
         The file &lt;VAR&gt;newname&lt;/VAR&gt; would exist on a read-only file system.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOSPC
         The directory or file system cannot be extended to make the new link.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EIO
         A hardware error occurred while reading or writing data on the disk.
         &lt;br&gt;&lt;br&gt;

        </synopsis>
    </function>
  </construct>
  <construct id="function-readlink" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="char *buffer"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;readlink&lt;/CODE&gt; function gets the value of the symbolic link
         &lt;VAR&gt;filename&lt;/VAR&gt;.  The file name that the link points to is copied into
         &lt;VAR&gt;buffer&lt;/VAR&gt;.  This file name string is &lt;EM&gt;not&lt;/EM&gt; null-terminated;
         &lt;CODE&gt;readlink&lt;/CODE&gt; normally returns the number of characters copied.  The
         &lt;VAR&gt;size&lt;/VAR&gt; argument specifies the maximum number of characters to copy,
         usually the allocation size of &lt;VAR&gt;buffer&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If the return value equals &lt;VAR&gt;size&lt;/VAR&gt;, you cannot tell whether or not
         there was room to return the entire name.  So make a bigger buffer and
         call &lt;CODE&gt;readlink&lt;/CODE&gt; again.  Here is an example:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         char *&lt;br&gt;
         readlink_malloc (const char *filename)&lt;br&gt;
         {&lt;br&gt;
           int size = 100;&lt;br&gt;
           char *buffer = NULL;&lt;br&gt;
         &lt;br&gt;&lt;br&gt;   while (1)&lt;br&gt;
             {&lt;br&gt;
               buffer = (char *) xrealloc (buffer, size);&lt;br&gt;
               int nchars = readlink (filename, buffer, size);&lt;br&gt;
               if (nchars &lt; 0)&lt;br&gt;
                 {&lt;br&gt;
                   free (buffer);&lt;br&gt;
                   return NULL;&lt;br&gt;
                 }&lt;br&gt;
               if (nchars &lt; size)&lt;br&gt;
                 return buffer;&lt;br&gt;
               size *= 2;&lt;br&gt;
             }&lt;br&gt;
         }&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; A value of &lt;CODE&gt;-1&lt;/CODE&gt; is returned in case of error.  In addition to the
         usual file name errors , the following
         &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EINVAL&lt;/CODE&gt;
&lt;DD&gt;
         The named file is not a symbolic link.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EIO
         A hardware error occurred while reading or writing data on the disk.

        </synopsis>
    </function>
  </construct>
  <construct id="function-canonicalize_file_name" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *name"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;canonicalize_file_name&lt;/CODE&gt; function returns the absolute name of
         the file named by &lt;VAR&gt;name&lt;/VAR&gt; which contains no &lt;CODE&gt;.&lt;/CODE&gt;, &lt;CODE&gt;..&lt;/CODE&gt;
         components nor any repeated path separators (&lt;CODE&gt;/&lt;/CODE&gt;) or symlinks.  The
         result is passed back as the return value of the function in a block of
         memory allocated with &lt;CODE&gt;malloc&lt;/CODE&gt;.  If the result is not used anymore
         the memory should be freed with a call to &lt;CODE&gt;free&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; If any of the path components is missing the function returns a NULL
         pointer.  This is also what is returned if the length of the path
         reaches or exceeds &lt;CODE&gt;PATH_MAX&lt;/CODE&gt; characters.  In any case
         &lt;CODE&gt;errno&lt;/CODE&gt; is set accordingly.
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;ENAMETOOLONG&lt;/CODE&gt;
&lt;DD&gt;
         The resulting path is too long.  This error only occurs on systems which
         have a limit on the file name length.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EACCES
         At least one of the path components is not readable.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOENT
         The input file name is empty.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOENT
         At least one of the path components does not exist.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ELOOP
         More than &lt;CODE&gt;MAXSYMLINKS&lt;/CODE&gt; many symlinks have been followed.

         &lt;br&gt;&lt;br&gt; This function is a GNU extension and is declared in &lt;TT&gt;stdlib.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-realpath" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *restrict name"/>
        <parameter content="char *restrict resolved"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; A call to &lt;CODE&gt;realpath&lt;/CODE&gt; where the &lt;VAR&gt;resolved&lt;/VAR&gt; parameter is
         &lt;CODE&gt;NULL&lt;/CODE&gt; behaves exactly like &lt;CODE&gt;canonicalize_file_name&lt;/CODE&gt;.  The
         function allocates a buffer for the file name and returns a pointer to
         it.  If &lt;VAR&gt;resolved&lt;/VAR&gt; is not &lt;CODE&gt;NULL&lt;/CODE&gt; it points to a buffer into
         which the result is copied.  It is the callers responsibility to
         allocate a buffer which is large enough.  On systems which define
         &lt;CODE&gt;PATH_MAX&lt;/CODE&gt; this means the buffer must be large enough for a
         pathname of this size.  For systems without limitations on the pathname
         length the requirement cannot be met and programs should not call
         &lt;CODE&gt;realpath&lt;/CODE&gt; with anything but &lt;CODE&gt;NULL&lt;/CODE&gt; for the second parameter.
         &lt;br&gt;&lt;br&gt; One other difference is that the buffer &lt;VAR&gt;resolved&lt;/VAR&gt; (if nonzero) will
         contain the part of the path component which does not exist or is not
         readable if the function returns &lt;CODE&gt;NULL&lt;/CODE&gt; and &lt;CODE&gt;errno&lt;/CODE&gt; is set to
         &lt;CODE&gt;EACCES&lt;/CODE&gt; or &lt;CODE&gt;ENOENT&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This function is declared in &lt;TT&gt;stdlib.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-unlink" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;unlink&lt;/CODE&gt; function deletes the file name &lt;VAR&gt;filename&lt;/VAR&gt;.  If
         this is a file's sole name, the file itself is also deleted.  (Actually,
         if any process has the file open when this happens, deletion is
         postponed until all processes have closed the file.)
         &lt;br&gt;&lt;br&gt; The function &lt;CODE&gt;unlink&lt;/CODE&gt; is declared in the header file &lt;TT&gt;unistd.h&lt;/TT&gt;.
         &lt;br&gt;&lt;br&gt; This function returns &lt;CODE&gt;0&lt;/CODE&gt; on successful completion, and &lt;CODE&gt;-1&lt;/CODE&gt;
         on error.  In addition to the usual file name errors
         , the following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are
         defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EACCES&lt;/CODE&gt;
&lt;DD&gt;
         Write permission is denied for the directory from which the file is to be
         removed, or the directory has the sticky bit set and you do not own the file.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EBUSY
         This error indicates that the file is being used by the system in such a
         way that it can't be unlinked.  For example, you might see this error if
         the file name specifies the root directory or a mount point for a file
         system.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOENT
         The file name to be deleted doesn't exist.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EPERM
         On some systems &lt;CODE&gt;unlink&lt;/CODE&gt; cannot be used to delete the name of a
         directory, or at least can only be used this way by a privileged user.
         To avoid such problems, use &lt;CODE&gt;rmdir&lt;/CODE&gt; to delete directories.  (In the
         GNU system &lt;CODE&gt;unlink&lt;/CODE&gt; can never delete the name of a directory.)
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EROFS
         The directory containing the file name to be deleted is on a read-only
         file system and can't be modified.

        </synopsis>
    </function>
  </construct>
  <construct id="function-rmdir" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        , deleting
          a directory
         The &lt;CODE&gt;rmdir&lt;/CODE&gt; function deletes a directory.  The directory must be
         empty before it can be removed; in other words, it can only contain
         entries for &lt;TT&gt;.&lt;/TT&gt; and &lt;TT&gt;..&lt;/TT&gt;.
         &lt;br&gt;&lt;br&gt; In most other respects, &lt;CODE&gt;rmdir&lt;/CODE&gt; behaves like &lt;CODE&gt;unlink&lt;/CODE&gt;.  There
         are two additional &lt;CODE&gt;errno&lt;/CODE&gt; error conditions defined for
         &lt;CODE&gt;rmdir&lt;/CODE&gt;:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;ENOTEMPTY&lt;/CODE&gt;
&lt;DD&gt;
         &lt;LI&gt;x EEXIST
         The directory to be deleted is not empty.

         &lt;br&gt;&lt;br&gt; These two error codes are synonymous; some systems use one, and some use
         the other.  The GNU system always uses &lt;CODE&gt;ENOTEMPTY&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The prototype for this function is declared in the header file
         &lt;TT&gt;unistd.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-remove" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This is the ISO C function to remove a file.  It works like
         &lt;CODE&gt;unlink&lt;/CODE&gt; for files and like &lt;CODE&gt;rmdir&lt;/CODE&gt; for directories.
         &lt;CODE&gt;remove&lt;/CODE&gt; is declared in &lt;TT&gt;stdio.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-rename" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *oldname"/>
        <parameter content="const char *newname"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;rename&lt;/CODE&gt; function renames the file &lt;VAR&gt;oldname&lt;/VAR&gt; to
         &lt;VAR&gt;newname&lt;/VAR&gt;.  The file formerly accessible under the name
         &lt;VAR&gt;oldname&lt;/VAR&gt; is afterwards accessible as &lt;VAR&gt;newname&lt;/VAR&gt; instead.  (If
         the file had any other names aside from &lt;VAR&gt;oldname&lt;/VAR&gt;, it continues to
         have those names.)
         &lt;br&gt;&lt;br&gt; The directory containing the name &lt;VAR&gt;newname&lt;/VAR&gt; must be on the same file
         system as the directory containing the name &lt;VAR&gt;oldname&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; One special case for &lt;CODE&gt;rename&lt;/CODE&gt; is when &lt;VAR&gt;oldname&lt;/VAR&gt; and
         &lt;VAR&gt;newname&lt;/VAR&gt; are two names for the same file.  The consistent way to
         handle this case is to delete &lt;VAR&gt;oldname&lt;/VAR&gt;.  However, in this case
         POSIX requires that &lt;CODE&gt;rename&lt;/CODE&gt; do nothing and report success---which
         is inconsistent.  We don't know what your operating system will do.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;oldname&lt;/VAR&gt; is not a directory, then any existing file named
         &lt;VAR&gt;newname&lt;/VAR&gt; is removed during the renaming operation.  However, if
         &lt;VAR&gt;newname&lt;/VAR&gt; is the name of a directory, &lt;CODE&gt;rename&lt;/CODE&gt; fails in this
         case.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;oldname&lt;/VAR&gt; is a directory, then either &lt;VAR&gt;newname&lt;/VAR&gt; must not
         exist or it must name a directory that is empty.  In the latter case,
         the existing directory named &lt;VAR&gt;newname&lt;/VAR&gt; is deleted first.  The name
         &lt;VAR&gt;newname&lt;/VAR&gt; must not specify a subdirectory of the directory
         &lt;CODE&gt;oldname&lt;/CODE&gt; which is being renamed.
         &lt;br&gt;&lt;br&gt; One useful feature of &lt;CODE&gt;rename&lt;/CODE&gt; is that the meaning of &lt;VAR&gt;newname&lt;/VAR&gt;
         changes ``atomically'' from any previously existing file by that name to
         its new meaning (i.e., the file that was called &lt;VAR&gt;oldname&lt;/VAR&gt;).  There is
         no instant at which &lt;VAR&gt;newname&lt;/VAR&gt; is non-existent ``in between'' the old
         meaning and the new meaning.  If there is a system crash during the
         operation, it is possible for both names to still exist; but
         &lt;VAR&gt;newname&lt;/VAR&gt; will always be intact if it exists at all.
         &lt;br&gt;&lt;br&gt; If &lt;CODE&gt;rename&lt;/CODE&gt; fails, it returns &lt;CODE&gt;-1&lt;/CODE&gt;.  In addition to the usual
         file name errors , the following
         &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EACCES&lt;/CODE&gt;
&lt;DD&gt;
         One of the directories containing &lt;VAR&gt;newname&lt;/VAR&gt; or &lt;VAR&gt;oldname&lt;/VAR&gt;
         refuses write permission; or &lt;VAR&gt;newname&lt;/VAR&gt; and &lt;VAR&gt;oldname&lt;/VAR&gt; are
         directories and write permission is refused for one of them.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EBUSY
         A directory named by &lt;VAR&gt;oldname&lt;/VAR&gt; or &lt;VAR&gt;newname&lt;/VAR&gt; is being used by
         the system in a way that prevents the renaming from working.  This includes
         directories that are mount points for filesystems, and directories
         that are the current working directories of processes.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOTEMPTY
         &lt;LI&gt;x EEXIST
         The directory &lt;VAR&gt;newname&lt;/VAR&gt; isn't empty.  The GNU system always returns
         &lt;CODE&gt;ENOTEMPTY&lt;/CODE&gt; for this, but some other systems return &lt;CODE&gt;EEXIST&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         &lt;VAR&gt;oldname&lt;/VAR&gt; is a directory that contains &lt;VAR&gt;newname&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EISDIR
         &lt;VAR&gt;newname&lt;/VAR&gt; is a directory but the &lt;VAR&gt;oldname&lt;/VAR&gt; isn't.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EMLINK
         The parent directory of &lt;VAR&gt;newname&lt;/VAR&gt; would have too many links
         (entries).
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOENT
         The file &lt;VAR&gt;oldname&lt;/VAR&gt; doesn't exist.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOSPC
         The directory that would contain &lt;VAR&gt;newname&lt;/VAR&gt; has no room for another
         entry, and there is no space left in the file system to expand it.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EROFS
         The operation would involve writing to a directory on a read-only file
         system.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EXDEV
         The two file names &lt;VAR&gt;newname&lt;/VAR&gt; and &lt;VAR&gt;oldname&lt;/VAR&gt; are on different
         file systems.

        </synopsis>
    </function>
  </construct>
  <construct id="function-mkdir" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="mode_t mode"/>
      </prototype>
      <headers>
        <header filename = "sys/stat.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;mkdir&lt;/CODE&gt; function creates a new, empty directory with name
         &lt;VAR&gt;filename&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The argument &lt;VAR&gt;mode&lt;/VAR&gt; specifies the file permissions for the new
         directory file.  , for more information about
         this.
         &lt;br&gt;&lt;br&gt; A return value of &lt;CODE&gt;0&lt;/CODE&gt; indicates successful completion, and
         &lt;CODE&gt;-1&lt;/CODE&gt; indicates failure.  In addition to the usual file name syntax
         errors , the following &lt;CODE&gt;errno&lt;/CODE&gt; error
         conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EACCES&lt;/CODE&gt;
&lt;DD&gt;
         Write permission is denied for the parent directory in which the new
         directory is to be added.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EEXIST
         A file named &lt;VAR&gt;filename&lt;/VAR&gt; already exists.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EMLINK
         The parent directory has too many links (entries).
         &lt;br&gt;&lt;br&gt; Well-designed file systems never report this error, because they permit
         more links than your disk could possibly hold.  However, you must still
         take account of the possibility of this error, as it could result from
         network access to a file system on another machine.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOSPC
         The file system doesn't have enough room to create the new directory.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EROFS
         The parent directory of the directory being created is on a read-only
         file system and cannot be modified.

         &lt;br&gt;&lt;br&gt; To use this function, your program should include the header file
         &lt;TT&gt;sys/stat.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-stat" type="struct">
    <structure>
        <synopsis>
        The &lt;CODE&gt;stat&lt;/CODE&gt; structure type is used to return information about the
         attributes of a file.  It contains at least the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="mode_t st_mode">
            <synopsis>
            Specifies the mode of the file.  This includes file type information
              and the file permission bits
             .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="ino_t st_ino">
            <synopsis>
            The file serial number, which distinguishes this file from all other
             files on the same device.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="dev_t st_dev">
            <synopsis>
            Identifies the device containing the file.  The &lt;CODE&gt;st_ino&lt;/CODE&gt; and
             &lt;CODE&gt;st_dev&lt;/CODE&gt;, taken together, uniquely identify the file.  The
             &lt;CODE&gt;st_dev&lt;/CODE&gt; value is not necessarily consistent across reboots or
             system crashes, however.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="nlink_t st_nlink">
            <synopsis>
            The number of hard links to the file.  This count keeps track of how
             many directories have entries for this file.  If the count is ever
             decremented to zero, then the file itself is discarded as soon as no
             process still holds it open.  Symbolic links are not counted in the
             total.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="uid_t st_uid">
            <synopsis>
            The user ID of the file's owner.  .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="gid_t st_gid">
            <synopsis>
            The group ID of the file.  .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="off_t st_size">
            <synopsis>
            This specifies the size of a regular file in bytes.  For files that are
             really devices this field isn't usually meaningful.  For symbolic links
             this specifies the length of the file name the link refers to.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="time_t st_atime">
            <synopsis>
            This is the last access time for the file.  .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="unsigned long int st_atime_usec">
            <synopsis>
            This is the fractional part of the last access time for the file.
             .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="time_t st_mtime">
            <synopsis>
            This is the time of the last modification to the contents of the file.
             .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="unsigned long int st_mtime_usec">
            <synopsis>
            This is the fractional part of the time of the last modification to the
             contents of the file.  .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="time_t st_ctime">
            <synopsis>
            This is the time of the last modification to the attributes of the file.
             .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="unsigned long int st_ctime_usec">
            <synopsis>
            This is the fractional part of the time of the last modification to the
             attributes of the file.  .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="blkcnt_t st_blocks">
            <synopsis>
            This is the amount of disk space that the file occupies, measured in
             units of 512-byte blocks.
             &lt;br&gt;&lt;br&gt; The number of disk blocks is not strictly proportional to the size of
             the file, for two reasons: the file system may use some blocks for
             internal record keeping; and the file may be sparse---it may have
             ``holes'' which contain zeros but do not actually take up space on the
             disk.
             &lt;br&gt;&lt;br&gt; You can tell (approximately) whether a file is sparse by comparing this
             value with &lt;CODE&gt;st_size&lt;/CODE&gt;, like this:
             &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
             (st.st_blocks * 512 &lt; st.st_size)&lt;br&gt;
             &lt;/pre&gt;
             &lt;br&gt;&lt;br&gt; This test is not perfect because a file that is just slightly sparse
             might not be detected as sparse at all.  For practical applications,
             this is not a problem.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="struct-stat64" type="struct">
    <structure>
        <synopsis>
        The members of this type are the same and have the same names as those
         in &lt;CODE&gt;struct stat&lt;/CODE&gt;.  The only difference is that the members
         &lt;CODE&gt;st_ino&lt;/CODE&gt;, &lt;CODE&gt;st_size&lt;/CODE&gt;, and &lt;CODE&gt;st_blocks&lt;/CODE&gt; have a different
         type to support larger values.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="mode_t st_mode">
            <synopsis>
            Specifies the mode of the file.  This includes file type information
              and the file permission bits
             .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="ino64_t st_ino">
            <synopsis>
            The file serial number, which distinguishes this file from all other
             files on the same device.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="dev_t st_dev">
            <synopsis>
            Identifies the device containing the file.  The &lt;CODE&gt;st_ino&lt;/CODE&gt; and
             &lt;CODE&gt;st_dev&lt;/CODE&gt;, taken together, uniquely identify the file.  The
             &lt;CODE&gt;st_dev&lt;/CODE&gt; value is not necessarily consistent across reboots or
             system crashes, however.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="nlink_t st_nlink">
            <synopsis>
            The number of hard links to the file.  This count keeps track of how
             many directories have entries for this file.  If the count is ever
             decremented to zero, then the file itself is discarded as soon as no
             process still holds it open.  Symbolic links are not counted in the
             total.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="uid_t st_uid">
            <synopsis>
            The user ID of the file's owner.  .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="gid_t st_gid">
            <synopsis>
            The group ID of the file.  .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="off64_t st_size">
            <synopsis>
            This specifies the size of a regular file in bytes.  For files that are
             really devices this field isn't usually meaningful.  For symbolic links
             this specifies the length of the file name the link refers to.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="time_t st_atime">
            <synopsis>
            This is the last access time for the file.  .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="unsigned long int st_atime_usec">
            <synopsis>
            This is the fractional part of the last access time for the file.
             .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="time_t st_mtime">
            <synopsis>
            This is the time of the last modification to the contents of the file.
             .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="unsigned long int st_mtime_usec">
            <synopsis>
            This is the fractional part of the time of the last modification to the
             contents of the file.  .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="time_t st_ctime">
            <synopsis>
            This is the time of the last modification to the attributes of the file.
             .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="unsigned long int st_ctime_usec">
            <synopsis>
            This is the fractional part of the time of the last modification to the
             attributes of the file.  .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="blkcnt64_t st_blocks">
            <synopsis>
            This is the amount of disk space that the file occupies, measured in
             units of 512-byte blocks.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="dtype-mode_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="dtype-ino_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="dtype-ino64_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="dtype-dev_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="dtype-nlink_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="dtype-blkcnt_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="dtype-blkcnt64_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="function-stat" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="struct stat *buf"/>
      </prototype>
      <headers>
        <header filename = "sys/stat.h"/>
        <header filename = "sys/types.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;stat&lt;/CODE&gt; function returns information about the attributes of the
         file named by &lt;VAR&gt;filename&lt;/VAR&gt; in the structure pointed to by &lt;VAR&gt;buf&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;filename&lt;/VAR&gt; is the name of a symbolic link, the attributes you get
         describe the file that the link points to.  If the link points to a
         nonexistent file name, then &lt;CODE&gt;stat&lt;/CODE&gt; fails reporting a nonexistent
         file.
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; if the operation is successful, or
         &lt;CODE&gt;-1&lt;/CODE&gt; on failure.  In addition to the usual file name errors
         (, the following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions
         are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;ENOENT&lt;/CODE&gt;
&lt;DD&gt;
         The file named by &lt;VAR&gt;filename&lt;/VAR&gt; doesn't exist.

         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; this
         function is in fact &lt;CODE&gt;stat64&lt;/CODE&gt; since the LFS interface transparently
         replaces the normal implementation.
        </synopsis>
    </function>
  </construct>
  <construct id="function-stat64" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="struct stat64 *buf"/>
      </prototype>
      <headers>
        <header filename = "sys/stat.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;stat&lt;/CODE&gt; but it is also able to work on
         files larger then 2^31 bytes on 32-bit systems.  To be able to do
         this the result is stored in a variable of type &lt;CODE&gt;struct stat64&lt;/CODE&gt; to
         which &lt;VAR&gt;buf&lt;/VAR&gt; must point.
         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; this
         function is available under the name &lt;CODE&gt;stat&lt;/CODE&gt; and so transparently
         replaces the interface for small files on 32-bit machines.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fstat" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="struct stat *buf"/>
      </prototype>
      <headers>
        <header filename = "sys/stat.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fstat&lt;/CODE&gt; function is like &lt;CODE&gt;stat&lt;/CODE&gt;, except that it takes an
         open file descriptor as an argument instead of a file name.
         .
         &lt;br&gt;&lt;br&gt; Like &lt;CODE&gt;stat&lt;/CODE&gt;, &lt;CODE&gt;fstat&lt;/CODE&gt; returns &lt;CODE&gt;0&lt;/CODE&gt; on success and &lt;CODE&gt;-1&lt;/CODE&gt;
         on failure.  The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for
         &lt;CODE&gt;fstat&lt;/CODE&gt;:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;filedes&lt;/VAR&gt; argument is not a valid file descriptor.

         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; this
         function is in fact &lt;CODE&gt;fstat64&lt;/CODE&gt; since the LFS interface transparently
         replaces the normal implementation.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fstat64" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="struct stat64 *buf"/>
      </prototype>
      <headers>
        <header filename = "sys/stat.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;fstat&lt;/CODE&gt; but is able to work on large
         files on 32-bit platforms.  For large files the file descriptor
         &lt;VAR&gt;filedes&lt;/VAR&gt; should be obtained by &lt;CODE&gt;open64&lt;/CODE&gt; or &lt;CODE&gt;creat64&lt;/CODE&gt;.
         The &lt;VAR&gt;buf&lt;/VAR&gt; pointer points to a variable of type &lt;CODE&gt;struct stat64&lt;/CODE&gt;
         which is able to represent the larger values.
         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; this
         function is available under the name &lt;CODE&gt;fstat&lt;/CODE&gt; and so transparently
         replaces the interface for small files on 32-bit machines.
        </synopsis>
    </function>
  </construct>
  <construct id="function-lstat" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="struct stat *buf"/>
      </prototype>
      <headers>
        <header filename = "sys/stat.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;lstat&lt;/CODE&gt; function is like &lt;CODE&gt;stat&lt;/CODE&gt;, except that it does not
         follow symbolic links.  If &lt;VAR&gt;filename&lt;/VAR&gt; is the name of a symbolic
         link, &lt;CODE&gt;lstat&lt;/CODE&gt; returns information about the link itself; otherwise
         &lt;CODE&gt;lstat&lt;/CODE&gt; works like &lt;CODE&gt;stat&lt;/CODE&gt;.  .
         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; this
         function is in fact &lt;CODE&gt;lstat64&lt;/CODE&gt; since the LFS interface transparently
         replaces the normal implementation.
        </synopsis>
    </function>
  </construct>
  <construct id="function-lstat64" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="struct stat64 *buf"/>
      </prototype>
      <headers>
        <header filename = "sys/stat.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;lstat&lt;/CODE&gt; but it is also able to work on
         files larger then 2^31 bytes on 32-bit systems.  To be able to do
         this the result is stored in a variable of type &lt;CODE&gt;struct stat64&lt;/CODE&gt; to
         which &lt;VAR&gt;buf&lt;/VAR&gt; must point.
         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; this
         function is available under the name &lt;CODE&gt;lstat&lt;/CODE&gt; and so transparently
         replaces the interface for small files on 32-bit machines.
        </synopsis>
    </function>
  </construct>
  <construct id="function-chown" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="uid_t owner"/>
        <parameter content="gid_t group"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;chown&lt;/CODE&gt; function changes the owner of the file &lt;VAR&gt;filename&lt;/VAR&gt; to
         &lt;VAR&gt;owner&lt;/VAR&gt;, and its group owner to &lt;VAR&gt;group&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; Changing the owner of the file on certain systems clears the set-user-ID
         and set-group-ID permission bits.  (This is because those bits may not
         be appropriate for the new owner.)  Other file permission bits are not
         changed.
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; on success and &lt;CODE&gt;-1&lt;/CODE&gt; on failure.
         In addition to the usual file name errors ,
         the following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EPERM&lt;/CODE&gt;
&lt;DD&gt;
         This process lacks permission to make the requested change.
         &lt;br&gt;&lt;br&gt; Only privileged users or the file's owner can change the file's group.
         On most file systems, only privileged users can change the file owner;
         some file systems allow you to change the owner if you are currently the
         owner.  When you access a remote file system, the behavior you encounter
         is determined by the system that actually holds the file, not by the
         system your program is running on.
         &lt;br&gt;&lt;br&gt; , for information about the
         &lt;CODE&gt;_POSIX_CHOWN_RESTRICTED&lt;/CODE&gt; macro.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EROFS
         The file is on a read-only file system.

        </synopsis>
    </function>
  </construct>
  <construct id="function-fchown" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="int owner"/>
        <parameter content="int group"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        This is like &lt;CODE&gt;chown&lt;/CODE&gt;, except that it changes the owner of the open
         file with descriptor &lt;VAR&gt;filedes&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The return value from &lt;CODE&gt;fchown&lt;/CODE&gt; is &lt;CODE&gt;0&lt;/CODE&gt; on success and &lt;CODE&gt;-1&lt;/CODE&gt;
         on failure.  The following &lt;CODE&gt;errno&lt;/CODE&gt; error codes are defined for this
         function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;filedes&lt;/VAR&gt; argument is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         The &lt;VAR&gt;filedes&lt;/VAR&gt; argument corresponds to a pipe or socket, not an ordinary
         file.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EPERM
         This process lacks permission to make the requested change.  For details
         see &lt;CODE&gt;chmod&lt;/CODE&gt; above.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EROFS
         The file resides on a read-only file system.

        </synopsis>
    </function>
  </construct>
  <construct id="function-umask" type="function">
    <function returntype="mode_t">
      <prototype>
        <parameter content="mode_t mask"/>
      </prototype>
      <headers>
        <header filename = "sys/stat.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;umask&lt;/CODE&gt; function sets the file creation mask of the current
         process to &lt;VAR&gt;mask&lt;/VAR&gt;, and returns the previous value of the file
         creation mask.
         &lt;br&gt;&lt;br&gt; Here is an example showing how to read the mask with &lt;CODE&gt;umask&lt;/CODE&gt;
         without changing it permanently:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         mode_t&lt;br&gt;
         read_umask (void)&lt;br&gt;
         {&lt;br&gt;
           mode_t mask = umask (0);&lt;br&gt;
           umask (mask);&lt;br&gt;
           return mask;&lt;br&gt;
         }&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt;
         However, it is better to use &lt;CODE&gt;getumask&lt;/CODE&gt; if you just want to read
         the mask value, because it is reentrant (at least if you use the GNU
         operating system).
        </synopsis>
    </function>
  </construct>
  <construct id="function-getumask" type="function">
    <function returntype="mode_t">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "sys/stat.h"/>
      </headers>
        <synopsis>
        Return the current value of the file creation mask for the current
         process.  This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-chmod" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="mode_t mode"/>
      </prototype>
      <headers>
        <header filename = "sys/stat.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;chmod&lt;/CODE&gt; function sets the access permission bits for the file
         named by &lt;VAR&gt;filename&lt;/VAR&gt; to &lt;VAR&gt;mode&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;filename&lt;/VAR&gt; is a symbolic link, &lt;CODE&gt;chmod&lt;/CODE&gt; changes the
         permissions of the file pointed to by the link, not those of the link
         itself.
         &lt;br&gt;&lt;br&gt; This function returns &lt;CODE&gt;0&lt;/CODE&gt; if successful and &lt;CODE&gt;-1&lt;/CODE&gt; if not.  In
         addition to the usual file name errors , the following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for
         this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;ENOENT&lt;/CODE&gt;
&lt;DD&gt;
         The named file doesn't exist.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EPERM
         This process does not have permission to change the access permissions
         of this file.  Only the file's owner (as judged by the effective user ID
         of the process) or a privileged user can change them.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EROFS
         The file resides on a read-only file system.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EFTYPE
         &lt;VAR&gt;mode&lt;/VAR&gt; has the &lt;CODE&gt;S_ISVTX&lt;/CODE&gt; bit (the ``sticky bit'') set,
         and the named file is not a directory.  Some systems do not allow setting the
         sticky bit on non-directory files, and some do (and only some of those
         assign a useful meaning to the bit for non-directory files).
         &lt;br&gt;&lt;br&gt; You only get &lt;CODE&gt;EFTYPE&lt;/CODE&gt; on systems where the sticky bit has no useful
         meaning for non-directory files, so it is always safe to just clear the
         bit in &lt;VAR&gt;mode&lt;/VAR&gt; and call &lt;CODE&gt;chmod&lt;/CODE&gt; again.  ,
         for full details on the sticky bit.

        </synopsis>
    </function>
  </construct>
  <construct id="function-fchmod" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="int mode"/>
      </prototype>
      <headers>
        <header filename = "sys/stat.h"/>
      </headers>
        <synopsis>
        This is like &lt;CODE&gt;chmod&lt;/CODE&gt;, except that it changes the permissions of the
         currently open file given by &lt;VAR&gt;filedes&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The return value from &lt;CODE&gt;fchmod&lt;/CODE&gt; is &lt;CODE&gt;0&lt;/CODE&gt; on success and &lt;CODE&gt;-1&lt;/CODE&gt;
         on failure.  The following &lt;CODE&gt;errno&lt;/CODE&gt; error codes are defined for this
         function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;filedes&lt;/VAR&gt; argument is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         The &lt;VAR&gt;filedes&lt;/VAR&gt; argument corresponds to a pipe or socket, or something
         else that doesn't really have access permissions.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EPERM
         This process does not have permission to change the access permissions
         of this file.  Only the file's owner (as judged by the effective user ID
         of the process) or a privileged user can change them.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EROFS
         The file resides on a read-only file system.

        </synopsis>
    </function>
  </construct>
  <construct id="function-access" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="int how"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;access&lt;/CODE&gt; function checks to see whether the file named by
         &lt;VAR&gt;filename&lt;/VAR&gt; can be accessed in the way specified by the &lt;VAR&gt;how&lt;/VAR&gt;
         argument.  The &lt;VAR&gt;how&lt;/VAR&gt; argument either can be the bitwise OR of the
         flags &lt;CODE&gt;R_OK&lt;/CODE&gt;, &lt;CODE&gt;W_OK&lt;/CODE&gt;, &lt;CODE&gt;X_OK&lt;/CODE&gt;, or the existence test
         &lt;CODE&gt;F_OK&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This function uses the &lt;EM&gt;real&lt;/EM&gt; user and group IDs of the calling
         process, rather than the &lt;EM&gt;effective&lt;/EM&gt; IDs, to check for access
         permission.  As a result, if you use the function from a &lt;CODE&gt;setuid&lt;/CODE&gt;
         or &lt;CODE&gt;setgid&lt;/CODE&gt; program , it gives
         information relative to the user who actually ran the program.
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; if the access is permitted, and &lt;CODE&gt;-1&lt;/CODE&gt;
         otherwise.  (In other words, treated as a predicate function,
         &lt;CODE&gt;access&lt;/CODE&gt; returns true if the requested access is &lt;EM&gt;denied&lt;/EM&gt;.)
         &lt;br&gt;&lt;br&gt; In addition to the usual file name errors , the following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for
         this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EACCES&lt;/CODE&gt;
&lt;DD&gt;
         The access specified by &lt;VAR&gt;how&lt;/VAR&gt; is denied.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOENT
         The file doesn't exist.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EROFS
         Write permission was requested for a file on a read-only file system.

        </synopsis>
    </function>
  </construct>
  <construct id="struct-utimbuf" type="struct">
    <structure>
        <synopsis>
        The &lt;CODE&gt;utimbuf&lt;/CODE&gt; structure is used with the &lt;CODE&gt;utime&lt;/CODE&gt; function to
         specify new access and modification times for a file.  It contains the
         following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="time_t actime">
            <synopsis>
            This is the access time for the file.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-utime" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="const struct utimbuf *times"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
        <header filename = "time.h"/>
      </headers>
        <synopsis>
        This function is used to modify the file times associated with the file
         named &lt;VAR&gt;filename&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;times&lt;/VAR&gt; is a null pointer, then the access and modification times
         of the file are set to the current time.  Otherwise, they are set to the
         values from the &lt;CODE&gt;actime&lt;/CODE&gt; and &lt;CODE&gt;modtime&lt;/CODE&gt; members (respectively)
         of the &lt;CODE&gt;utimbuf&lt;/CODE&gt; structure pointed to by &lt;VAR&gt;times&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The attribute modification time for the file is set to the current time
         in either case (since changing the time stamps is itself a modification
         of the file attributes).
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;utime&lt;/CODE&gt; function returns &lt;CODE&gt;0&lt;/CODE&gt; if successful and &lt;CODE&gt;-1&lt;/CODE&gt;
         on failure.  In addition to the usual file name errors
         , the following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions
         are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EACCES&lt;/CODE&gt;
&lt;DD&gt;
         There is a permission problem in the case where a null pointer was
         passed as the &lt;VAR&gt;times&lt;/VAR&gt; argument.  In order to update the time stamp on
         the file, you must either be the owner of the file, have write
         permission for the file, or be a privileged user.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOENT
         The file doesn't exist.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EPERM
         If the &lt;VAR&gt;times&lt;/VAR&gt; argument is not a null pointer, you must either be
         the owner of the file or be a privileged user.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EROFS
         The file lives on a read-only file system.

        </synopsis>
    </function>
  </construct>
  <construct id="function-utimes" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="struct timeval tvp[2]"/>
      </prototype>
      <headers>
        <header filename = "sys/time.h"/>
      </headers>
        <synopsis>
        This function sets the file access and modification times of the file
         &lt;VAR&gt;filename&lt;/VAR&gt;.  The new file access time is specified by
         &lt;CODE&gt;&lt;VAR&gt;tvp&lt;/VAR&gt;[0]&lt;/CODE&gt;, and the new modification time by
         &lt;CODE&gt;&lt;VAR&gt;tvp&lt;/VAR&gt;[1]&lt;/CODE&gt;.  Similar to &lt;CODE&gt;utime&lt;/CODE&gt;, if &lt;VAR&gt;tvp&lt;/VAR&gt; is a null
         pointer then the access and modification times of the file are set to
         the current time.  This function comes from BSD.
         &lt;br&gt;&lt;br&gt; The return values and error conditions are the same as for the &lt;CODE&gt;utime&lt;/CODE&gt;
         function.
        </synopsis>
    </function>
  </construct>
  <construct id="function-lutimes" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="struct timeval tvp[2]"/>
      </prototype>
      <headers>
        <header filename = "sys/time.h"/>
      </headers>
        <synopsis>
        This function is like &lt;CODE&gt;utimes&lt;/CODE&gt;, except that it does not follow
         symbolic links.  If &lt;VAR&gt;filename&lt;/VAR&gt; is the name of a symbolic link,
         &lt;CODE&gt;lutimes&lt;/CODE&gt; sets the file access and modification times of the
         symbolic link special file itself (as seen by &lt;CODE&gt;lstat&lt;/CODE&gt;;
         ) while &lt;CODE&gt;utimes&lt;/CODE&gt; sets the file access and
         modification times of the file the symbolic link refers to.  This
         function comes from FreeBSD, and is not available on all platforms (if
         not available, it will fail with &lt;CODE&gt;ENOSYS&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; The return values and error conditions are the same as for the &lt;CODE&gt;utime&lt;/CODE&gt;
         function.
        </synopsis>
    </function>
  </construct>
  <construct id="function-futimes" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int fd"/>
        <parameter content="struct timeval tvp[2]"/>
      </prototype>
      <headers>
        <header filename = "sys/time.h"/>
      </headers>
        <synopsis>
        This function is like &lt;CODE&gt;utimes&lt;/CODE&gt;, except that it takes an open file
         descriptor as an argument instead of a file name.  .  This function comes from FreeBSD, and is not available on all
         platforms (if not available, it will fail with &lt;CODE&gt;ENOSYS&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; Like &lt;CODE&gt;utimes&lt;/CODE&gt;, &lt;CODE&gt;futimes&lt;/CODE&gt; returns &lt;CODE&gt;0&lt;/CODE&gt; on success and &lt;CODE&gt;-1&lt;/CODE&gt;
         on failure.  The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for
         &lt;CODE&gt;futimes&lt;/CODE&gt;:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EACCES&lt;/CODE&gt;
&lt;DD&gt;
         There is a permission problem in the case where a null pointer was
         passed as the &lt;VAR&gt;times&lt;/VAR&gt; argument.  In order to update the time stamp on
         the file, you must either be the owner of the file, have write
         permission for the file, or be a privileged user.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EBADF
         The &lt;VAR&gt;filedes&lt;/VAR&gt; argument is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EPERM
         If the &lt;VAR&gt;times&lt;/VAR&gt; argument is not a null pointer, you must either be
         the owner of the file or be a privileged user.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EROFS
         The file lives on a read-only file system.

        </synopsis>
    </function>
  </construct>
  <construct id="function-truncate" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="off_t length"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;truncate&lt;/CODE&gt; function changes the size of &lt;VAR&gt;filename&lt;/VAR&gt; to
         &lt;VAR&gt;length&lt;/VAR&gt;.  If &lt;VAR&gt;length&lt;/VAR&gt; is shorter than the previous length, data
         at the end will be lost.  The file must be writable by the user to
         perform this operation.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;length&lt;/VAR&gt; is longer, holes will be added to the end.  However, some
         systems do not support this feature and will leave the file unchanged.
         &lt;br&gt;&lt;br&gt; When the source file is compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; the
         &lt;CODE&gt;truncate&lt;/CODE&gt; function is in fact &lt;CODE&gt;truncate64&lt;/CODE&gt; and the type
         &lt;CODE&gt;off_t&lt;/CODE&gt; has 64 bits which makes it possible to handle files up to
         2^63 bytes in length.
         &lt;br&gt;&lt;br&gt; The return value is 0 for success, or -1 for an error.  In
         addition to the usual file name errors, the following errors may occur:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;EACCES&lt;/CODE&gt;
&lt;DD&gt;
         The file is a directory or not writable.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         &lt;VAR&gt;length&lt;/VAR&gt; is negative.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EFBIG
         The operation would extend the file beyond the limits of the operating system.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EIO
         A hardware I/O error occurred.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EPERM
         The file is "append-only" or "immutable".
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINTR
         The operation was interrupted by a signal.
         &lt;br&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-truncate64" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *name"/>
        <parameter content="off64_t length"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        This function is similar to the &lt;CODE&gt;truncate&lt;/CODE&gt; function.  The
         difference is that the &lt;VAR&gt;length&lt;/VAR&gt; argument is 64 bits wide even on 32
         bits machines, which allows the handling of files with sizes up to
         2^63 bytes.
         &lt;br&gt;&lt;br&gt; When the source file is compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; on a
         32 bits machine this function is actually available under the name
         &lt;CODE&gt;truncate&lt;/CODE&gt; and so transparently replaces the 32 bits interface.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ftruncate" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int fd"/>
        <parameter content="off_t length"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; This is like &lt;CODE&gt;truncate&lt;/CODE&gt;, but it works on a file descriptor &lt;VAR&gt;fd&lt;/VAR&gt;
         for an opened file instead of a file name to identify the object.  The
         file must be opened for writing to successfully carry out the operation.
         &lt;br&gt;&lt;br&gt; The POSIX standard leaves it implementation defined what happens if the
         specified new &lt;VAR&gt;length&lt;/VAR&gt; of the file is bigger than the original size.
         The &lt;CODE&gt;ftruncate&lt;/CODE&gt; function might simply leave the file alone and do
         nothing or it can increase the size to the desired size.  In this later
         case the extended area should be zero-filled.  So using &lt;CODE&gt;ftruncate&lt;/CODE&gt;
         is no reliable way to increase the file size but if it is possible it is
         probably the fastest way.  The function also operates on POSIX shared
         memory segments if these are implemented by the system.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;ftruncate&lt;/CODE&gt; is especially useful in combination with &lt;CODE&gt;mmap&lt;/CODE&gt;.
         Since the mapped region must have a fixed size one cannot enlarge the
         file by writing something beyond the last mapped page.  Instead one has
         to enlarge the file itself and then remap the file with the new size.
         The example below shows how this works.
         &lt;br&gt;&lt;br&gt; When the source file is compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; the
         &lt;CODE&gt;ftruncate&lt;/CODE&gt; function is in fact &lt;CODE&gt;ftruncate64&lt;/CODE&gt; and the type
         &lt;CODE&gt;off_t&lt;/CODE&gt; has 64 bits which makes it possible to handle files up to
         2^63 bytes in length.
         &lt;br&gt;&lt;br&gt; The return value is 0 for success, or -1 for an error.  The
         following errors may occur:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         &lt;VAR&gt;fd&lt;/VAR&gt; does not correspond to an open file.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EACCES
         &lt;VAR&gt;fd&lt;/VAR&gt; is a directory or not open for writing.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         &lt;VAR&gt;length&lt;/VAR&gt; is negative.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EFBIG
         The operation would extend the file beyond the limits of the operating system.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EIO
         A hardware I/O error occurred.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EPERM
         The file is "append-only" or "immutable".
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINTR
         The operation was interrupted by a signal.
         &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-ftruncate64" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int id"/>
        <parameter content="off64_t length"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        This function is similar to the &lt;CODE&gt;ftruncate&lt;/CODE&gt; function.  The
         difference is that the &lt;VAR&gt;length&lt;/VAR&gt; argument is 64 bits wide even on 32
         bits machines which allows the handling of files with sizes up to
         2^63 bytes.
         &lt;br&gt;&lt;br&gt; When the source file is compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; on a
         32 bits machine this function is actually available under the name
         &lt;CODE&gt;ftruncate&lt;/CODE&gt; and so transparently replaces the 32 bits interface.
        </synopsis>
    </function>
  </construct>
  <construct id="function-mknod" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="int mode"/>
        <parameter content="int dev"/>
      </prototype>
      <headers>
        <header filename = "sys/stat.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;mknod&lt;/CODE&gt; function makes a special file with name &lt;VAR&gt;filename&lt;/VAR&gt;.
         The &lt;VAR&gt;mode&lt;/VAR&gt; specifies the mode of the file, and may include the various
         special file bits, such as &lt;CODE&gt;S_IFCHR&lt;/CODE&gt; (for a character special file)
         or &lt;CODE&gt;S_IFBLK&lt;/CODE&gt; (for a block special file).  .
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;dev&lt;/VAR&gt; argument specifies which device the special file refers to.
         Its exact interpretation depends on the kind of special file being created.
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; on success and &lt;CODE&gt;-1&lt;/CODE&gt; on error.  In addition
         to the usual file name errors , the
         following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EPERM&lt;/CODE&gt;
&lt;DD&gt;
         The calling process is not privileged.  Only the superuser can create
         special files.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOSPC
         The directory or file system that would contain the new file is full
         and cannot be extended.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EROFS
         The directory containing the new file can't be modified because it's on
         a read-only file system.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EEXIST
         There is already a file named &lt;VAR&gt;filename&lt;/VAR&gt;.  If you want to replace
         this file, you must remove the old file explicitly first.

        </synopsis>
    </function>
  </construct>
  <construct id="function-tmpfile" type="function">
    <function returntype="FILE *">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function creates a temporary binary file for update mode, as if by
         calling &lt;CODE&gt;fopen&lt;/CODE&gt; with mode &lt;CODE&gt;"wb+"&lt;/CODE&gt;.  The file is deleted
         automatically when it is closed or when the program terminates.  (On
         some other ISO C systems the file may fail to be deleted if the program
         terminates abnormally).
         &lt;br&gt;&lt;br&gt; This function is reentrant.
         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; on a
         32-bit system this function is in fact &lt;CODE&gt;tmpfile64&lt;/CODE&gt;, i.e., the LFS
         interface transparently replaces the old interface.
        </synopsis>
    </function>
  </construct>
  <construct id="function-tmpfile64" type="function">
    <function returntype="FILE *">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;tmpfile&lt;/CODE&gt;, but the stream it returns a
         pointer to was opened using &lt;CODE&gt;tmpfile64&lt;/CODE&gt;.  Therefore this stream can
         be used for files larger then 2^31 bytes on 32-bit machines.
         &lt;br&gt;&lt;br&gt; Please note that the return type is still &lt;CODE&gt;FILE *&lt;/CODE&gt;.  There is no
         special &lt;CODE&gt;FILE&lt;/CODE&gt; type for the LFS interface.
         &lt;br&gt;&lt;br&gt; If the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; on a 32
         bits machine this function is available under the name &lt;CODE&gt;tmpfile&lt;/CODE&gt;
         and so transparently replaces the old interface.
        </synopsis>
    </function>
  </construct>
  <construct id="function-tmpnam" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="char *result"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function constructs and returns a valid file name that does not
         refer to any existing file.  If the &lt;VAR&gt;result&lt;/VAR&gt; argument is a null
         pointer, the return value is a pointer to an internal static string,
         which might be modified by subsequent calls and therefore makes this
         function non-reentrant.  Otherwise, the &lt;VAR&gt;result&lt;/VAR&gt; argument should be
         a pointer to an array of at least &lt;CODE&gt;L_tmpnam&lt;/CODE&gt; characters, and the
         result is written into that array.
         &lt;br&gt;&lt;br&gt; It is possible for &lt;CODE&gt;tmpnam&lt;/CODE&gt; to fail if you call it too many times
         without removing previously-created files.  This is because the limited
         length of the temporary file names gives room for only a finite number
         of different names.  If &lt;CODE&gt;tmpnam&lt;/CODE&gt; fails it returns a null pointer.
         &lt;br&gt;&lt;br&gt; Warning: Between the time the pathname is constructed and the
         file is created another process might have created a file with the same
         name using &lt;CODE&gt;tmpnam&lt;/CODE&gt;, leading to a possible security hole.  The
         implementation generates names which can hardly be predicted, but when
         opening the file you should use the &lt;CODE&gt;O_EXCL&lt;/CODE&gt; flag.  Using
         &lt;CODE&gt;tmpfile&lt;/CODE&gt; or &lt;CODE&gt;mkstemp&lt;/CODE&gt; is a safe way to avoid this problem.
        </synopsis>
    </function>
  </construct>
  <construct id="function-tmpnam_r" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="char *result"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function is nearly identical to the &lt;CODE&gt;tmpnam&lt;/CODE&gt; function, except
         that if &lt;VAR&gt;result&lt;/VAR&gt; is a null pointer it returns a null pointer.
         &lt;br&gt;&lt;br&gt; This guarantees reentrancy because the non-reentrant situation of
         &lt;CODE&gt;tmpnam&lt;/CODE&gt; cannot happen here.
         &lt;br&gt;&lt;br&gt; &lt;h3&gt;Warning&lt;/h3&gt;: This function has the same security problems as
         &lt;CODE&gt;tmpnam&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-tempnam" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *dir"/>
        <parameter content="const char *prefix"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function generates a unique temporary file name.  If &lt;VAR&gt;prefix&lt;/VAR&gt;
         is not a null pointer, up to five characters of this string are used as
         a prefix for the file name.  The return value is a string newly
         allocated with &lt;CODE&gt;malloc&lt;/CODE&gt;, so you should release its storage with
         &lt;CODE&gt;free&lt;/CODE&gt; when it is no longer needed.
         &lt;br&gt;&lt;br&gt; Because the string is dynamically allocated this function is reentrant.
         &lt;br&gt;&lt;br&gt; The directory prefix for the temporary file name is determined by
         testing each of the following in sequence.  The directory must exist and
         be writable.
         &lt;br&gt;&lt;br&gt; &lt;OL&gt;
         &lt;LI&gt;
         The environment variable &lt;CODE&gt;TMPDIR&lt;/CODE&gt;, if it is defined.  For security
         reasons this only happens if the program is not SUID or SGID enabled.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         The &lt;VAR&gt;dir&lt;/VAR&gt; argument, if it is not a null pointer.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         The value of the &lt;CODE&gt;P_tmpdir&lt;/CODE&gt; macro.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         The directory &lt;TT&gt;/tmp&lt;/TT&gt;.
         &lt;/OL&gt;
         &lt;br&gt;&lt;br&gt; This function is defined for SVID compatibility.
         &lt;br&gt;&lt;br&gt; Warning: Between the time the pathname is constructed and the
         file is created another process might have created a file with the same
         name using &lt;CODE&gt;tempnam&lt;/CODE&gt;, leading to a possible security hole.  The
         implementation generates names which can hardly be predicted, but when
         opening the file you should use the &lt;CODE&gt;O_EXCL&lt;/CODE&gt; flag.  Using
         &lt;CODE&gt;tmpfile&lt;/CODE&gt; or &lt;CODE&gt;mkstemp&lt;/CODE&gt; is a safe way to avoid this problem.
        </synopsis>
    </function>
  </construct>
  <construct id="function-mktemp" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="char *template"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;mktemp&lt;/CODE&gt; function generates a unique file name by modifying
         &lt;VAR&gt;template&lt;/VAR&gt; as described above.  If successful, it returns
         &lt;VAR&gt;template&lt;/VAR&gt; as modified.  If &lt;CODE&gt;mktemp&lt;/CODE&gt; cannot find a unique file
         name, it makes &lt;VAR&gt;template&lt;/VAR&gt; an empty string and returns that.  If
         &lt;VAR&gt;template&lt;/VAR&gt; does not end with &lt;samp&gt;XXXXXX&lt;/samp&gt;, &lt;CODE&gt;mktemp&lt;/CODE&gt; returns a
         null pointer.
         &lt;br&gt;&lt;br&gt; Warning: Between the time the pathname is constructed and the
         file is created another process might have created a file with the same
         name using &lt;CODE&gt;mktemp&lt;/CODE&gt;, leading to a possible security hole.  The
         implementation generates names which can hardly be predicted, but when
         opening the file you should use the &lt;CODE&gt;O_EXCL&lt;/CODE&gt; flag.  Using
         &lt;CODE&gt;mkstemp&lt;/CODE&gt; is a safe way to avoid this problem.
        </synopsis>
    </function>
  </construct>
  <construct id="function-mkstemp" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="char *template"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;mkstemp&lt;/CODE&gt; function generates a unique file name just as
         &lt;CODE&gt;mktemp&lt;/CODE&gt; does, but it also opens the file for you with &lt;CODE&gt;open&lt;/CODE&gt;
         .  If successful, it modifies
         &lt;VAR&gt;template&lt;/VAR&gt; in place and returns a file descriptor for that file open
         for reading and writing.  If &lt;CODE&gt;mkstemp&lt;/CODE&gt; cannot create a
         uniquely-named file, it returns &lt;CODE&gt;-1&lt;/CODE&gt;.  If &lt;VAR&gt;template&lt;/VAR&gt; does not
         end with &lt;samp&gt;XXXXXX&lt;/samp&gt;, &lt;CODE&gt;mkstemp&lt;/CODE&gt; returns &lt;CODE&gt;-1&lt;/CODE&gt; and does not
         modify &lt;VAR&gt;template&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The file is opened using mode &lt;CODE&gt;0600&lt;/CODE&gt;.  If the file is meant to be
         used by other users this mode must be changed explicitly.
        </synopsis>
    </function>
  </construct>
  <construct id="function-mkdtemp" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="char *template"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;mkdtemp&lt;/CODE&gt; function creates a directory with a unique name.  If
         it succeeds, it overwrites &lt;VAR&gt;template&lt;/VAR&gt; with the name of the
         directory, and returns &lt;VAR&gt;template&lt;/VAR&gt;.  As with &lt;CODE&gt;mktemp&lt;/CODE&gt; and
         &lt;CODE&gt;mkstemp&lt;/CODE&gt;, &lt;VAR&gt;template&lt;/VAR&gt; should be a string ending with
         &lt;samp&gt;XXXXXX&lt;/samp&gt;.
         &lt;br&gt;&lt;br&gt; If &lt;CODE&gt;mkdtemp&lt;/CODE&gt; cannot create an uniquely named directory, it returns
         &lt;CODE&gt;NULL&lt;/CODE&gt; and sets &lt;VAR&gt;errno&lt;/VAR&gt; appropriately.  If &lt;VAR&gt;template&lt;/VAR&gt; does
         not end with &lt;samp&gt;XXXXXX&lt;/samp&gt;, &lt;CODE&gt;mkdtemp&lt;/CODE&gt; returns &lt;CODE&gt;NULL&lt;/CODE&gt; and does
         not modify &lt;VAR&gt;template&lt;/VAR&gt;.  &lt;VAR&gt;errno&lt;/VAR&gt; will be set to &lt;CODE&gt;EINVAL&lt;/CODE&gt; in
         this case.
         &lt;br&gt;&lt;br&gt; The directory is created using mode &lt;CODE&gt;0700&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strsignal" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="int signum"/>
      </prototype>
      <headers>
        <header filename = "signal.h"/>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        This function returns a pointer to a statically-allocated string
         containing a message describing the signal &lt;VAR&gt;signum&lt;/VAR&gt;.  You
         should not modify the contents of this string; and, since it can be
         rewritten on subsequent calls, you should save a copy of it if you need
         to reference it later.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension, declared in the header file
         &lt;TT&gt;string.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-psignal" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="int signum"/>
        <parameter content="const char *message"/>
      </prototype>
      <headers>
        <header filename = "signal.h"/>
      </headers>
        <synopsis>
        This function prints a message describing the signal &lt;VAR&gt;signum&lt;/VAR&gt; to the
         standard error output stream &lt;CODE&gt;stderr&lt;/CODE&gt;; see Standard Streams.
         &lt;br&gt;&lt;br&gt; If you call &lt;CODE&gt;psignal&lt;/CODE&gt; with a &lt;VAR&gt;message&lt;/VAR&gt; that is either a null
         pointer or an empty string, &lt;CODE&gt;psignal&lt;/CODE&gt; just prints the message
         corresponding to &lt;VAR&gt;signum&lt;/VAR&gt;, adding a trailing newline.
         &lt;br&gt;&lt;br&gt; If you supply a non-null &lt;VAR&gt;message&lt;/VAR&gt; argument, then &lt;CODE&gt;psignal&lt;/CODE&gt;
         prefixes its output with this string.  It adds a colon and a space
         character to separate the &lt;VAR&gt;message&lt;/VAR&gt; from the string corresponding
         to &lt;VAR&gt;signum&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; This function is a BSD feature, declared in the header file &lt;TT&gt;signal.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-sighandler_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="function-signal" type="function">
    <function returntype="sighandler_t">
      <prototype>
        <parameter content="int signum"/>
        <parameter content="sighandler_t action"/>
      </prototype>
      <headers>
        <header filename = "signal.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;signal&lt;/CODE&gt; function establishes &lt;VAR&gt;action&lt;/VAR&gt; as the action for
         the signal &lt;VAR&gt;signum&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The first argument, &lt;VAR&gt;signum&lt;/VAR&gt;, identifies the signal whose behavior
         you want to control, and should be a signal number.  The proper way to
         specify a signal number is with one of the symbolic signal names
         ---don't use an explicit number, because
         the numerical code for a given kind of signal may vary from operating
         system to operating system.
         &lt;br&gt;&lt;br&gt; The second argument, &lt;VAR&gt;action&lt;/VAR&gt;, specifies the action to use for the
         signal &lt;VAR&gt;signum&lt;/VAR&gt;.  This can be one of the following:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;SIG_DFL&lt;/CODE&gt;
&lt;DD&gt;

          action for a signal
         &lt;CODE&gt;SIG_DFL&lt;/CODE&gt; specifies the default action for the particular signal.
         The default actions for various kinds of signals are stated in
         Standard Signals.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;SIG_IGN&lt;/CODE&gt;
&lt;DD&gt;

          action for a signal
         &lt;CODE&gt;SIG_IGN&lt;/CODE&gt; specifies that the signal should be ignored.
         &lt;br&gt;&lt;br&gt; Your program generally should not ignore signals that represent serious
         events or that are normally used to request termination.  You cannot
         ignore the &lt;CODE&gt;SIGKILL&lt;/CODE&gt; or &lt;CODE&gt;SIGSTOP&lt;/CODE&gt; signals at all.  You can
         ignore program error signals like &lt;CODE&gt;SIGSEGV&lt;/CODE&gt;, but ignoring the error
         won't enable the program to continue executing meaningfully.  Ignoring
         user requests such as &lt;CODE&gt;SIGINT&lt;/CODE&gt;, &lt;CODE&gt;SIGQUIT&lt;/CODE&gt;, and &lt;CODE&gt;SIGTSTP&lt;/CODE&gt;
         is unfriendly.
         &lt;br&gt;&lt;br&gt; When you do not wish signals to be delivered during a certain part of
         the program, the thing to do is to block them, not ignore them.
         .
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; &lt;VAR&gt;handler&lt;/VAR&gt;
         Supply the address of a handler function in your program, to specify
         running this handler as the way to deliver the signal.
         &lt;br&gt;&lt;br&gt; For more information about defining signal handler functions,
         see Defining Handlers.

         &lt;br&gt;&lt;br&gt; If you set the action for a signal to &lt;CODE&gt;SIG_IGN&lt;/CODE&gt;, or if you set it
         to &lt;CODE&gt;SIG_DFL&lt;/CODE&gt; and the default action is to ignore that signal, then
         any pending signals of that type are discarded (even if they are
         blocked).  Discarding the pending signals means that they will never be
         delivered, not even if you subsequently specify another action and
         unblock this kind of signal.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;signal&lt;/CODE&gt; function returns the action that was previously in
         effect for the specified &lt;VAR&gt;signum&lt;/VAR&gt;.  You can save this value and
         restore it later by calling &lt;CODE&gt;signal&lt;/CODE&gt; again.
         &lt;br&gt;&lt;br&gt; If &lt;CODE&gt;signal&lt;/CODE&gt; can't honor the request, it returns &lt;CODE&gt;SIG_ERR&lt;/CODE&gt;
         instead.  The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for
         this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;LI&gt; EINVAL
         You specified an invalid &lt;VAR&gt;signum&lt;/VAR&gt;; or you tried to ignore or provide
         a handler for &lt;CODE&gt;SIGKILL&lt;/CODE&gt; or &lt;CODE&gt;SIGSTOP&lt;/CODE&gt;.

        </synopsis>
    </function>
  </construct>
  <construct id="function-sysv_signal" type="function">
    <function returntype="sighandler_t">
      <prototype>
        <parameter content="int signum"/>
        <parameter content="sighandler_t action"/>
      </prototype>
      <headers>
        <header filename = "signal.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;sysv_signal&lt;/CODE&gt; implements the behavior of the standard
         &lt;CODE&gt;signal&lt;/CODE&gt; function as found on SVID systems.  The difference to BSD
         systems is that the handler is deinstalled after a delivery of a signal.
         &lt;br&gt;&lt;br&gt; Compatibility Note: As said above for &lt;CODE&gt;signal&lt;/CODE&gt;, this
         function should be avoided when possible.  &lt;CODE&gt;sigaction&lt;/CODE&gt; is the
         preferred method.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ssignal" type="function">
    <function returntype="sighandler_t">
      <prototype>
        <parameter content="int signum"/>
        <parameter content="sighandler_t action"/>
      </prototype>
      <headers>
        <header filename = "signal.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;ssignal&lt;/CODE&gt; function does the same thing as &lt;CODE&gt;signal&lt;/CODE&gt;; it is
         provided only for compatibility with SVID.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-sigaction" type="struct">
    <structure>
        <synopsis>
        Structures of type &lt;CODE&gt;struct sigaction&lt;/CODE&gt; are used in the
         &lt;CODE&gt;sigaction&lt;/CODE&gt; function to specify all the information about how to
         handle a particular signal.  This structure contains at least the
         following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="sighandler_t sa_handler">
            <synopsis>
            This is used in the same way as the &lt;VAR&gt;action&lt;/VAR&gt; argument to the
             &lt;CODE&gt;signal&lt;/CODE&gt; function.  The value can be &lt;CODE&gt;SIG_DFL&lt;/CODE&gt;,
             &lt;CODE&gt;SIG_IGN&lt;/CODE&gt;, or a function pointer.  .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="sigset_t sa_mask">
            <synopsis>
            This specifies a set of signals to be blocked while the handler runs.
             Blocking is explained in Blocking for Handler.  Note that the
             signal that was delivered is automatically blocked by default before its
             handler is started; this is true regardless of the value in
             &lt;CODE&gt;sa_mask&lt;/CODE&gt;.  If you want that signal not to be blocked within its
             handler, you must write code in the handler to unblock it.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-sigaction" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int signum"/>
        <parameter content="const struct sigaction *restrict action"/>
        <parameter content="struct sigaction *restrict old-action"/>
      </prototype>
      <headers>
        <header filename = "signal.h"/>
      </headers>
        <synopsis>
        The &lt;VAR&gt;action&lt;/VAR&gt; argument is used to set up a new action for the signal
         &lt;VAR&gt;signum&lt;/VAR&gt;, while the &lt;VAR&gt;old-action&lt;/VAR&gt; argument is used to return
         information about the action previously associated with this symbol.
         (In other words, &lt;VAR&gt;old-action&lt;/VAR&gt; has the same purpose as the
         &lt;CODE&gt;signal&lt;/CODE&gt; function's return value---you can check to see what the
         old action in effect for the signal was, and restore it later if you
         want.)
         &lt;br&gt;&lt;br&gt; Either &lt;VAR&gt;action&lt;/VAR&gt; or &lt;VAR&gt;old-action&lt;/VAR&gt; can be a null pointer.  If
         &lt;VAR&gt;old-action&lt;/VAR&gt; is a null pointer, this simply suppresses the return
         of information about the old action.  If &lt;VAR&gt;action&lt;/VAR&gt; is a null pointer,
         the action associated with the signal &lt;VAR&gt;signum&lt;/VAR&gt; is unchanged; this
         allows you to inquire about how a signal is being handled without changing
         that handling.
         &lt;br&gt;&lt;br&gt; The return value from &lt;CODE&gt;sigaction&lt;/CODE&gt; is zero if it succeeds, and
         &lt;CODE&gt;-1&lt;/CODE&gt; on failure.  The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are
         defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EINVAL&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;signum&lt;/VAR&gt; argument is not valid, or you are trying to
         trap or ignore &lt;CODE&gt;SIGKILL&lt;/CODE&gt; or &lt;CODE&gt;SIGSTOP&lt;/CODE&gt;.

        </synopsis>
    </function>
  </construct>
  <construct id="dtype-sig_atomic_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="function-raise" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int signum"/>
      </prototype>
      <headers>
        <header filename = "signal.h"/>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;raise&lt;/CODE&gt; function sends the signal &lt;VAR&gt;signum&lt;/VAR&gt; to the calling
         process.  It returns zero if successful and a nonzero value if it fails.
         About the only reason for failure would be if the value of &lt;VAR&gt;signum&lt;/VAR&gt;
         is invalid.
        </synopsis>
    </function>
  </construct>
  <construct id="function-gsignal" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int signum"/>
      </prototype>
      <headers>
        <header filename = "signal.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;gsignal&lt;/CODE&gt; function does the same thing as &lt;CODE&gt;raise&lt;/CODE&gt;; it is
         provided only for compatibility with SVID.
        </synopsis>
    </function>
  </construct>
  <construct id="function-kill" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="pid_t pid"/>
        <parameter content="int signum"/>
      </prototype>
      <headers>
        <header filename = "signal.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;kill&lt;/CODE&gt; function sends the signal &lt;VAR&gt;signum&lt;/VAR&gt; to the process
         or process group specified by &lt;VAR&gt;pid&lt;/VAR&gt;.  Besides the signals listed in
         Standard Signals, &lt;VAR&gt;signum&lt;/VAR&gt; can also have a value of zero to
         check the validity of the &lt;VAR&gt;pid&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;pid&lt;/VAR&gt; specifies the process or process group to receive the
         signal:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;&lt;VAR&gt;pid&lt;/VAR&gt; &gt; 0&lt;/CODE&gt;
&lt;DD&gt;
         The process whose identifier is &lt;VAR&gt;pid&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;&lt;VAR&gt;pid&lt;/VAR&gt; == 0&lt;/CODE&gt;
&lt;DD&gt;
         All processes in the same process group as the sender.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; &lt;VAR&gt;pid&lt;/VAR&gt; &lt; -1
         The process group whose identifier is &lt;VAR&gt;pid&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; &lt;VAR&gt;pid&lt;/VAR&gt; == -1
         If the process is privileged, send the signal to all processes except
         for some special system processes.  Otherwise, send the signal to all
         processes with the same effective user ID.

         &lt;br&gt;&lt;br&gt; A process can send a signal to itself with a call like &lt;CODE&gt;kill
         (getpid(), &lt;VAR&gt;signum&lt;/VAR&gt;)&lt;/CODE&gt;.  If &lt;CODE&gt;kill&lt;/CODE&gt; is used by a process to send
         a signal to itself, and the signal is not blocked, then &lt;CODE&gt;kill&lt;/CODE&gt;
         delivers at least one signal (which might be some other pending
         unblocked signal instead of the signal &lt;VAR&gt;signum&lt;/VAR&gt;) to that process
         before it returns.
         &lt;br&gt;&lt;br&gt; The return value from &lt;CODE&gt;kill&lt;/CODE&gt; is zero if the signal can be sent
         successfully.  Otherwise, no signal is sent, and a value of &lt;CODE&gt;-1&lt;/CODE&gt; is
         returned.  If &lt;VAR&gt;pid&lt;/VAR&gt; specifies sending a signal to several processes,
         &lt;CODE&gt;kill&lt;/CODE&gt; succeeds if it can send the signal to at least one of them.
         There's no way you can tell which of the processes got the signal
         or whether all of them did.
         &lt;br&gt;&lt;br&gt; The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;LI&gt; EINVAL
         The &lt;VAR&gt;signum&lt;/VAR&gt; argument is an invalid or unsupported number.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EPERM
         You do not have the privilege to send a signal to the process or any of
         the processes in the process group named by &lt;VAR&gt;pid&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ESRCH
         The &lt;VAR&gt;pid&lt;/VAR&gt; argument does not refer to an existing process or group.

        </synopsis>
    </function>
  </construct>
  <construct id="function-killpg" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int pgid"/>
        <parameter content="int signum"/>
      </prototype>
      <headers>
        <header filename = "signal.h"/>
      </headers>
        <synopsis>
        This is similar to &lt;CODE&gt;kill&lt;/CODE&gt;, but sends signal &lt;VAR&gt;signum&lt;/VAR&gt; to the
         process group &lt;VAR&gt;pgid&lt;/VAR&gt;.  This function is provided for compatibility
         with BSD; using &lt;CODE&gt;kill&lt;/CODE&gt; to do this is more portable.
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-sigset_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="function-sigemptyset" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="sigset_t *set"/>
      </prototype>
      <headers>
        <header filename = "signal.h"/>
      </headers>
        <synopsis>
        This function initializes the signal set &lt;VAR&gt;set&lt;/VAR&gt; to exclude all of the
         defined signals.  It always returns &lt;CODE&gt;0&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-sigfillset" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="sigset_t *set"/>
      </prototype>
      <headers>
        <header filename = "signal.h"/>
      </headers>
        <synopsis>
        This function initializes the signal set &lt;VAR&gt;set&lt;/VAR&gt; to include
         all of the defined signals.  Again, the return value is &lt;CODE&gt;0&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-sigaddset" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="sigset_t *set"/>
        <parameter content="int signum"/>
      </prototype>
      <headers>
        <header filename = "signal.h"/>
      </headers>
        <synopsis>
        This function adds the signal &lt;VAR&gt;signum&lt;/VAR&gt; to the signal set &lt;VAR&gt;set&lt;/VAR&gt;.
         All &lt;CODE&gt;sigaddset&lt;/CODE&gt; does is modify &lt;VAR&gt;set&lt;/VAR&gt;; it does not block or
         unblock any signals.
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; on success and &lt;CODE&gt;-1&lt;/CODE&gt; on failure.
         The following &lt;CODE&gt;errno&lt;/CODE&gt; error condition is defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EINVAL&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;signum&lt;/VAR&gt; argument doesn't specify a valid signal.

        </synopsis>
    </function>
  </construct>
  <construct id="function-sigdelset" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="sigset_t *set"/>
        <parameter content="int signum"/>
      </prototype>
      <headers>
        <header filename = "signal.h"/>
      </headers>
        <synopsis>
        This function removes the signal &lt;VAR&gt;signum&lt;/VAR&gt; from the signal set
         &lt;VAR&gt;set&lt;/VAR&gt;.  All &lt;CODE&gt;sigdelset&lt;/CODE&gt; does is modify &lt;VAR&gt;set&lt;/VAR&gt;; it does not
         block or unblock any signals.  The return value and error conditions are
         the same as for &lt;CODE&gt;sigaddset&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-sigismember" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const sigset_t *set"/>
        <parameter content="int signum"/>
      </prototype>
      <headers>
        <header filename = "signal.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;sigismember&lt;/CODE&gt; function tests whether the signal &lt;VAR&gt;signum&lt;/VAR&gt; is
         a member of the signal set &lt;VAR&gt;set&lt;/VAR&gt;.  It returns &lt;CODE&gt;1&lt;/CODE&gt; if the signal
         is in the set, &lt;CODE&gt;0&lt;/CODE&gt; if not, and &lt;CODE&gt;-1&lt;/CODE&gt; if there is an error.
         &lt;br&gt;&lt;br&gt; The following &lt;CODE&gt;errno&lt;/CODE&gt; error condition is defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EINVAL&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;signum&lt;/VAR&gt; argument doesn't specify a valid signal.

        </synopsis>
    </function>
  </construct>
  <construct id="function-sigprocmask" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int how"/>
        <parameter content="const sigset_t *restrict set"/>
        <parameter content="sigset_t *restrict oldset"/>
      </prototype>
      <headers>
        <header filename = "signal.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;sigprocmask&lt;/CODE&gt; function is used to examine or change the calling
         process's signal mask.  The &lt;VAR&gt;how&lt;/VAR&gt; argument determines how the signal
         mask is changed, and must be one of the following values:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;


         &lt;DT&gt;&lt;CODE&gt;SIG_BLOCK&lt;/CODE&gt;
&lt;DD&gt;
         Block the signals in &lt;CODE&gt;set&lt;/CODE&gt;---add them to the existing mask.  In
         other words, the new mask is the union of the existing mask and
         &lt;VAR&gt;set&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;SIG_UNBLOCK&lt;/CODE&gt;
&lt;DD&gt;
         Unblock the signals in &lt;VAR&gt;set&lt;/VAR&gt;---remove them from the existing mask.
         &lt;br&gt;&lt;br&gt;
         &lt;LI&gt; SIG_SETMASK
         Use &lt;VAR&gt;set&lt;/VAR&gt; for the mask; ignore the previous value of the mask.

         &lt;br&gt;&lt;br&gt; The last argument, &lt;VAR&gt;oldset&lt;/VAR&gt;, is used to return information about the
         old process signal mask.  If you just want to change the mask without
         looking at it, pass a null pointer as the &lt;VAR&gt;oldset&lt;/VAR&gt; argument.
         Similarly, if you want to know what's in the mask without changing it,
         pass a null pointer for &lt;VAR&gt;set&lt;/VAR&gt; (in this case the &lt;VAR&gt;how&lt;/VAR&gt; argument
         is not significant).  The &lt;VAR&gt;oldset&lt;/VAR&gt; argument is often used to
         remember the previous signal mask in order to restore it later.  (Since
         the signal mask is inherited over &lt;CODE&gt;fork&lt;/CODE&gt; and &lt;CODE&gt;exec&lt;/CODE&gt; calls, you
         can't predict what its contents are when your program starts running.)
         &lt;br&gt;&lt;br&gt; If invoking &lt;CODE&gt;sigprocmask&lt;/CODE&gt; causes any pending signals to be
         unblocked, at least one of those signals is delivered to the process
         before &lt;CODE&gt;sigprocmask&lt;/CODE&gt; returns.  The order in which pending signals
         are delivered is not specified, but you can control the order explicitly
         by making multiple &lt;CODE&gt;sigprocmask&lt;/CODE&gt; calls to unblock various signals
         one at a time.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;sigprocmask&lt;/CODE&gt; function returns &lt;CODE&gt;0&lt;/CODE&gt; if successful, and &lt;CODE&gt;-1&lt;/CODE&gt;
         to indicate an error.  The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are
         defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;LI&gt; EINVAL
         The &lt;VAR&gt;how&lt;/VAR&gt; argument is invalid.

         &lt;br&gt;&lt;br&gt; You can't block the &lt;CODE&gt;SIGKILL&lt;/CODE&gt; and &lt;CODE&gt;SIGSTOP&lt;/CODE&gt; signals, but
         if the signal set includes these, &lt;CODE&gt;sigprocmask&lt;/CODE&gt; just ignores
         them instead of returning an error status.
         &lt;br&gt;&lt;br&gt; Remember, too, that blocking program error signals such as &lt;CODE&gt;SIGFPE&lt;/CODE&gt;
         leads to undesirable results for signals generated by an actual program
         error (as opposed to signals sent with &lt;CODE&gt;raise&lt;/CODE&gt; or &lt;CODE&gt;kill&lt;/CODE&gt;).
         This is because your program may be too broken to be able to continue
         executing to a point where the signal is unblocked again.
         .
        </synopsis>
    </function>
  </construct>
  <construct id="function-sigpending" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="sigset_t *set"/>
      </prototype>
      <headers>
        <header filename = "signal.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;sigpending&lt;/CODE&gt; function stores information about pending signals
         in &lt;VAR&gt;set&lt;/VAR&gt;.  If there is a pending signal that is blocked from
         delivery, then that signal is a member of the returned set.  (You can
         test whether a particular signal is a member of this set using
         &lt;CODE&gt;sigismember&lt;/CODE&gt;; see Signal Sets.)
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; if successful, and &lt;CODE&gt;-1&lt;/CODE&gt; on failure.
        </synopsis>
    </function>
  </construct>
  <construct id="function-pause" type="function">
    <function returntype="int">
      <prototype>
        <parameter content=""/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;pause&lt;/CODE&gt; function suspends program execution until a signal
         arrives whose action is either to execute a handler function, or to
         terminate the process.
         &lt;br&gt;&lt;br&gt; If the signal causes a handler function to be executed, then
         &lt;CODE&gt;pause&lt;/CODE&gt; returns.  This is considered an unsuccessful return (since
         ``successful'' behavior would be to suspend the program forever), so the
         return value is &lt;CODE&gt;-1&lt;/CODE&gt;.  Even if you specify that other primitives
         should resume when a system handler returns , this has no effect on &lt;CODE&gt;pause&lt;/CODE&gt;; it always fails when a
         signal is handled.
         &lt;br&gt;&lt;br&gt; The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EINTR&lt;/CODE&gt;
&lt;DD&gt;
         The function was interrupted by delivery of a signal.

         &lt;br&gt;&lt;br&gt; If the signal causes program termination, &lt;CODE&gt;pause&lt;/CODE&gt; doesn't return
         (obviously).
         &lt;br&gt;&lt;br&gt; This function is a cancellation point in multithreaded programs.  This
         is a problem if the thread allocates some resources (like memory, file
         descriptors, semaphores or whatever) at the time &lt;CODE&gt;pause&lt;/CODE&gt; is
         called.  If the thread gets cancelled these resources stay allocated
         until the program ends.  To avoid this calls to &lt;CODE&gt;pause&lt;/CODE&gt; should be
         protected using cancellation handlers.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;pause&lt;/CODE&gt; function is declared in  &lt;TT&gt;unistd.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-sigsuspend" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const sigset_t *set"/>
      </prototype>
      <headers>
        <header filename = "signal.h"/>
      </headers>
        <synopsis>
        This function replaces the process's signal mask with &lt;VAR&gt;set&lt;/VAR&gt; and then
         suspends the process until a signal is delivered whose action is either
         to terminate the process or invoke a signal handling function.  In other
         words, the program is effectively suspended until one of the signals that
         is not a member of &lt;VAR&gt;set&lt;/VAR&gt; arrives.
         &lt;br&gt;&lt;br&gt; If the process is woken up by delivery of a signal that invokes a handler
         function, and the handler function returns, then &lt;CODE&gt;sigsuspend&lt;/CODE&gt; also
         returns.
         &lt;br&gt;&lt;br&gt; The mask remains &lt;VAR&gt;set&lt;/VAR&gt; only as long as &lt;CODE&gt;sigsuspend&lt;/CODE&gt; is waiting.
         The function &lt;CODE&gt;sigsuspend&lt;/CODE&gt; always restores the previous signal mask
         when it returns.
         &lt;br&gt;&lt;br&gt; The return value and error conditions are the same as for &lt;CODE&gt;pause&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-stack_t" type="dtype">
    <structure>
        <synopsis>
        This structure describes a signal stack.  It contains the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="void *ss_sp">
            <synopsis>
            This points to the base of the signal stack.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="size_t ss_size">
            <synopsis>
            This is the size (in bytes) of the signal stack which &lt;samp&gt;ss_sp&lt;/samp&gt; points to.
             You should set this to however much space you allocated for the stack.
             &lt;br&gt;&lt;br&gt; There are two macros defined in &lt;TT&gt;signal.h&lt;/TT&gt; that you should use in
             calculating this size:
             &lt;br&gt;&lt;br&gt; &lt;DL&gt;

            </synopsis>
        </element>
        <element content="SIGSTKSZ">
            <synopsis>
            This is the canonical size for a signal stack.  It is judged to be
             sufficient for normal uses.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="MINSIGSTKSZ">
            <synopsis>
            This is the amount of signal stack space the operating system needs just
             to implement signal delivery.  The size of a signal stack &lt;h3&gt;must&lt;/h3&gt;
             be greater than this.
             &lt;br&gt;&lt;br&gt; For most cases, just using &lt;CODE&gt;SIGSTKSZ&lt;/CODE&gt; for &lt;CODE&gt;ss_size&lt;/CODE&gt; is
             sufficient.  But if you know how much stack space your program's signal
             handlers will need, you may want to use a different size.  In this case,
             you should allocate &lt;CODE&gt;MINSIGSTKSZ&lt;/CODE&gt; additional bytes for the signal
             stack and increase &lt;CODE&gt;ss_size&lt;/CODE&gt; accordingly.
             &lt;/DL&gt;
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int ss_flags">
            <synopsis>
            This field contains the bitwise or of these flags:
             &lt;br&gt;&lt;br&gt; &lt;DL&gt;

            </synopsis>
        </element>
        <element content="SS_DISABLE">
            <synopsis>
            This tells the system that it should not use the signal stack.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-sigaltstack" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const stack_t *restrict stack"/>
        <parameter content="stack_t *restrict oldstack"/>
      </prototype>
      <headers>
        <header filename = "signal.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;sigaltstack&lt;/CODE&gt; function specifies an alternate stack for use
         during signal handling.  When a signal is received by the process and
         its action indicates that the signal stack is used, the system arranges
         a switch to the currently installed signal stack while the handler for
         that signal is executed.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;oldstack&lt;/VAR&gt; is not a null pointer, information about the currently
         installed signal stack is returned in the location it points to.  If
         &lt;VAR&gt;stack&lt;/VAR&gt; is not a null pointer, then this is installed as the new
         stack for use by signal handlers.
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; on success and &lt;CODE&gt;-1&lt;/CODE&gt; on failure.  If
         &lt;CODE&gt;sigaltstack&lt;/CODE&gt; fails, it sets &lt;CODE&gt;errno&lt;/CODE&gt; to one of these values:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EINVAL&lt;/CODE&gt;
&lt;DD&gt;
         You tried to disable a stack that was in fact currently in use.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOMEM
         The size of the alternate stack was too small.
         It must be greater than &lt;CODE&gt;MINSIGSTKSZ&lt;/CODE&gt;.

        </synopsis>
    </function>
  </construct>
  <construct id="struct-sigstack" type="struct">
    <structure>
        <synopsis>
        This structure describes a signal stack.  It contains the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="void *ss_sp">
            <synopsis>
            This is the stack pointer.  If the stack grows downwards on your
             machine, this should point to the top of the area you allocated.  If the
             stack grows upwards, it should point to the bottom.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-sigstack" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const struct sigstack *stack"/>
        <parameter content="struct sigstack *oldstack"/>
      </prototype>
      <headers>
        <header filename = "signal.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;sigstack&lt;/CODE&gt; function specifies an alternate stack for use during
         signal handling.  When a signal is received by the process and its
         action indicates that the signal stack is used, the system arranges a
         switch to the currently installed signal stack while the handler for
         that signal is executed.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;oldstack&lt;/VAR&gt; is not a null pointer, information about the currently
         installed signal stack is returned in the location it points to.  If
         &lt;VAR&gt;stack&lt;/VAR&gt; is not a null pointer, then this is installed as the new
         stack for use by signal handlers.
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; on success and &lt;CODE&gt;-1&lt;/CODE&gt; on failure.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-sigvec" type="struct">
    <structure>
        <synopsis>
        This data type is the BSD equivalent of &lt;CODE&gt;struct sigaction&lt;/CODE&gt;
         ; it is used to specify signal actions
         to the &lt;CODE&gt;sigvec&lt;/CODE&gt; function.  It contains the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="sighandler_t sv_handler">
            <synopsis>
            This is the handler function.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int sv_mask">
            <synopsis>
            This is the mask of additional signals to be blocked while the handler
             function is being called.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-sigvec" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int signum"/>
        <parameter content="const struct sigvec *action,struct sigvec *old-action"/>
      </prototype>
      <headers>
        <header filename = "signal.h"/>
      </headers>
        <synopsis>
        This function is the equivalent of &lt;CODE&gt;sigaction&lt;/CODE&gt; ; it installs the action &lt;VAR&gt;action&lt;/VAR&gt; for the signal &lt;VAR&gt;signum&lt;/VAR&gt;,
         returning information about the previous action in effect for that signal
         in &lt;VAR&gt;old-action&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-siginterrupt" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int signum"/>
        <parameter content="int failflag"/>
      </prototype>
      <headers>
        <header filename = "signal.h"/>
      </headers>
        <synopsis>
        This function specifies which approach to use when certain primitives
         are interrupted by handling signal &lt;VAR&gt;signum&lt;/VAR&gt;.  If &lt;VAR&gt;failflag&lt;/VAR&gt; is
         false, signal &lt;VAR&gt;signum&lt;/VAR&gt; restarts primitives.  If &lt;VAR&gt;failflag&lt;/VAR&gt; is
         true, handling &lt;VAR&gt;signum&lt;/VAR&gt; causes these primitives to fail with error
         code &lt;CODE&gt;EINTR&lt;/CODE&gt;.  .
        </synopsis>
    </function>
  </construct>
  <construct id="function-sigblock" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int mask"/>
      </prototype>
      <headers>
        <header filename = "signal.h"/>
      </headers>
        <synopsis>
        This function is equivalent to &lt;CODE&gt;sigprocmask&lt;/CODE&gt;  with a &lt;VAR&gt;how&lt;/VAR&gt; argument of &lt;CODE&gt;SIG_BLOCK&lt;/CODE&gt;: it adds the
         signals specified by &lt;VAR&gt;mask&lt;/VAR&gt; to the calling process's set of blocked
         signals.  The return value is the previous set of blocked signals.
        </synopsis>
    </function>
  </construct>
  <construct id="function-sigsetmask" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int mask"/>
      </prototype>
      <headers>
        <header filename = "signal.h"/>
      </headers>
        <synopsis>
        This function equivalent to &lt;CODE&gt;sigprocmask&lt;/CODE&gt;  with a &lt;VAR&gt;how&lt;/VAR&gt; argument of &lt;CODE&gt;SIG_SETMASK&lt;/CODE&gt;: it sets
         the calling process's signal mask to &lt;VAR&gt;mask&lt;/VAR&gt;.  The return value is
         the previous set of blocked signals.
        </synopsis>
    </function>
  </construct>
  <construct id="function-sigpause" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int mask"/>
      </prototype>
      <headers>
        <header filename = "signal.h"/>
      </headers>
        <synopsis>
        This function is the equivalent of &lt;CODE&gt;sigsuspend&lt;/CODE&gt; :  it sets the calling process's signal mask to &lt;VAR&gt;mask&lt;/VAR&gt;,
         and waits for a signal to arrive.  On return the previous set of blocked
         signals is restored.
        </synopsis>
    </function>
  </construct>
  <construct id="function-pipe" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int filedes[2]"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;pipe&lt;/CODE&gt; function creates a pipe and puts the file descriptors
         for the reading and writing ends of the pipe (respectively) into
         &lt;CODE&gt;&lt;VAR&gt;filedes&lt;/VAR&gt;[0]&lt;/CODE&gt; and &lt;CODE&gt;&lt;VAR&gt;filedes&lt;/VAR&gt;[1]&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; An easy way to remember that the input end comes first is that file
         descriptor &lt;CODE&gt;0&lt;/CODE&gt; is standard input, and file descriptor &lt;CODE&gt;1&lt;/CODE&gt; is
         standard output.
         &lt;br&gt;&lt;br&gt; If successful, &lt;CODE&gt;pipe&lt;/CODE&gt; returns a value of &lt;CODE&gt;0&lt;/CODE&gt;.  On failure,
         &lt;CODE&gt;-1&lt;/CODE&gt; is returned.  The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are
         defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EMFILE&lt;/CODE&gt;
&lt;DD&gt;
         The process has too many files open.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENFILE
         There are too many open files in the entire system.  ,
         for more information about &lt;CODE&gt;ENFILE&lt;/CODE&gt;.  This error never occurs in
         the GNU system.

        </synopsis>
    </function>
  </construct>
  <construct id="function-popen" type="function">
    <function returntype="FILE *">
      <prototype>
        <parameter content="const char *command"/>
        <parameter content="const char *mode"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;popen&lt;/CODE&gt; function is closely related to the &lt;CODE&gt;system&lt;/CODE&gt;
         function; see Running a Command.  It executes the shell command
         &lt;VAR&gt;command&lt;/VAR&gt; as a subprocess.  However, instead of waiting for the
         command to complete, it creates a pipe to the subprocess and returns a
         stream that corresponds to that pipe.
         &lt;br&gt;&lt;br&gt; If you specify a &lt;VAR&gt;mode&lt;/VAR&gt; argument of &lt;CODE&gt;"r"&lt;/CODE&gt;, you can read from the
         stream to retrieve data from the standard output channel of the subprocess.
         The subprocess inherits its standard input channel from the parent process.
         &lt;br&gt;&lt;br&gt; Similarly, if you specify a &lt;VAR&gt;mode&lt;/VAR&gt; argument of &lt;CODE&gt;"w"&lt;/CODE&gt;, you can
         write to the stream to send data to the standard input channel of the
         subprocess.  The subprocess inherits its standard output channel from
         the parent process.
         &lt;br&gt;&lt;br&gt; In the event of an error &lt;CODE&gt;popen&lt;/CODE&gt; returns a null pointer.  This
         might happen if the pipe or stream cannot be created, if the subprocess
         cannot be forked, or if the program cannot be executed.
        </synopsis>
    </function>
  </construct>
  <construct id="function-pclose" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;pclose&lt;/CODE&gt; function is used to close a stream created by &lt;CODE&gt;popen&lt;/CODE&gt;.
         It waits for the child process to terminate and returns its status value,
         as for the &lt;CODE&gt;system&lt;/CODE&gt; function.
        </synopsis>
    </function>
  </construct>
  <construct id="function-mkfifo" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="mode_t mode"/>
      </prototype>
      <headers>
        <header filename = "sys/stat.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;mkfifo&lt;/CODE&gt; function makes a FIFO special file with name
         &lt;VAR&gt;filename&lt;/VAR&gt;.  The &lt;VAR&gt;mode&lt;/VAR&gt; argument is used to set the file's
         permissions; see Setting Permissions.
         &lt;br&gt;&lt;br&gt; The normal, successful return value from &lt;CODE&gt;mkfifo&lt;/CODE&gt; is &lt;CODE&gt;0&lt;/CODE&gt;.  In
         the case of an error, &lt;CODE&gt;-1&lt;/CODE&gt; is returned.  In addition to the usual
         file name errors , the following
         &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EEXIST&lt;/CODE&gt;
&lt;DD&gt;
         The named file already exists.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOSPC
         The directory or file system cannot be extended.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EROFS
         The directory that would contain the file resides on a read-only file
         system.

        </synopsis>
    </function>
  </construct>
  <construct id="function-strerror" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="int errnum"/>
      </prototype>
      <headers>
        <header filename = "errno.h"/>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;strerror&lt;/CODE&gt; function maps the error code  specified by the &lt;VAR&gt;errnum&lt;/VAR&gt; argument to a descriptive error
         message string.  The return value is a pointer to this string.
         &lt;br&gt;&lt;br&gt; The value &lt;VAR&gt;errnum&lt;/VAR&gt; normally comes from the variable &lt;CODE&gt;errno&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; You should not modify the string returned by &lt;CODE&gt;strerror&lt;/CODE&gt;.  Also, if
         you make subsequent calls to &lt;CODE&gt;strerror&lt;/CODE&gt;, the string might be
         overwritten.  (But it's guaranteed that no library function ever calls
         &lt;CODE&gt;strerror&lt;/CODE&gt; behind your back.)
         &lt;br&gt;&lt;br&gt; The function &lt;CODE&gt;strerror&lt;/CODE&gt; is declared in &lt;TT&gt;string.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strerror_r" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="int errnum"/>
        <parameter content="char *buf"/>
        <parameter content="size_t n"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;strerror_r&lt;/CODE&gt; function works like &lt;CODE&gt;strerror&lt;/CODE&gt; but instead of
         returning the error message in a statically allocated buffer shared by
         all threads in the process, it returns a private copy for the
         thread. This might be either some permanent global data or a message
         string in the user supplied buffer starting at &lt;VAR&gt;buf&lt;/VAR&gt; with the
         length of &lt;VAR&gt;n&lt;/VAR&gt; bytes.
         &lt;br&gt;&lt;br&gt; At most &lt;VAR&gt;n&lt;/VAR&gt; characters are written (including the NUL byte) so it is
         up to the user to select the buffer large enough.
         &lt;br&gt;&lt;br&gt; This function should always be used in multi-threaded programs since
         there is no way to guarantee the string returned by &lt;CODE&gt;strerror&lt;/CODE&gt;
         really belongs to the last call of the current thread.
         &lt;br&gt;&lt;br&gt; This function &lt;CODE&gt;strerror_r&lt;/CODE&gt; is a GNU extension and it is declared in
         &lt;TT&gt;string.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-perror" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="const char *message"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function prints an error message to the stream &lt;CODE&gt;stderr&lt;/CODE&gt;;
         see Standard Streams.  The orientation of &lt;CODE&gt;stderr&lt;/CODE&gt; is not
         changed.
         &lt;br&gt;&lt;br&gt; If you call &lt;CODE&gt;perror&lt;/CODE&gt; with a &lt;VAR&gt;message&lt;/VAR&gt; that is either a null
         pointer or an empty string, &lt;CODE&gt;perror&lt;/CODE&gt; just prints the error message
         corresponding to &lt;CODE&gt;errno&lt;/CODE&gt;, adding a trailing newline.
         &lt;br&gt;&lt;br&gt; If you supply a non-null &lt;VAR&gt;message&lt;/VAR&gt; argument, then &lt;CODE&gt;perror&lt;/CODE&gt;
         prefixes its output with this string.  It adds a colon and a space
         character to separate the &lt;VAR&gt;message&lt;/VAR&gt; from the error string corresponding
         to &lt;CODE&gt;errno&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The function &lt;CODE&gt;perror&lt;/CODE&gt; is declared in &lt;TT&gt;stdio.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-error" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="int status"/>
        <parameter content="int errnum"/>
        <parameter content="const char *format"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "errno.h"/>
        <header filename = "error.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;error&lt;/CODE&gt; function can be used to report general problems during
         program execution.  The &lt;VAR&gt;format&lt;/VAR&gt; argument is a format string just
         like those given to the &lt;CODE&gt;printf&lt;/CODE&gt; family of functions.  The
         arguments required for the format can follow the &lt;VAR&gt;format&lt;/VAR&gt; parameter.
         Just like &lt;CODE&gt;perror&lt;/CODE&gt;, &lt;CODE&gt;error&lt;/CODE&gt; also can report an error code in
         textual form.  But unlike &lt;CODE&gt;perror&lt;/CODE&gt; the error value is explicitly
         passed to the function in the &lt;VAR&gt;errnum&lt;/VAR&gt; parameter.  This eliminates
         the problem mentioned above that the error reporting function must be
         called immediately after the function causing the error since otherwise
         &lt;CODE&gt;errno&lt;/CODE&gt; might have a different value.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;error&lt;/CODE&gt; prints first the program name.  If the application
         defined a global variable &lt;CODE&gt;error_print_progname&lt;/CODE&gt; and points it to a
         function this function will be called to print the program name.
         Otherwise the string from the global variable &lt;CODE&gt;program_name&lt;/CODE&gt; is
         used.  The program name is followed by a colon and a space which in turn
         is followed by the output produced by the format string.  If the
         &lt;VAR&gt;errnum&lt;/VAR&gt; parameter is non-zero the format string output is followed
         by a colon and a space, followed by the error message for the error code
         &lt;VAR&gt;errnum&lt;/VAR&gt;.  In any case is the output terminated with a newline.
         &lt;br&gt;&lt;br&gt; The output is directed to the &lt;CODE&gt;stderr&lt;/CODE&gt; stream.  If the
         &lt;CODE&gt;stderr&lt;/CODE&gt; wasn't oriented before the call it will be narrow-oriented
         afterwards.
         &lt;br&gt;&lt;br&gt; The function will return unless the &lt;VAR&gt;status&lt;/VAR&gt; parameter has a
         non-zero value.  In this case the function will call &lt;CODE&gt;exit&lt;/CODE&gt; with
         the &lt;VAR&gt;status&lt;/VAR&gt; value for its parameter and therefore never return.  If
         &lt;CODE&gt;error&lt;/CODE&gt; returns the global variable &lt;CODE&gt;error_message_count&lt;/CODE&gt; is
         incremented by one to keep track of the number of errors reported.
        </synopsis>
    </function>
  </construct>
  <construct id="function-error_at_line" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="int status"/>
        <parameter content="int errnum"/>
        <parameter content="const char *fname"/>
        <parameter content="unsigned int lineno"/>
        <parameter content="const char *format"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "error.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;error_at_line&lt;/CODE&gt; function is very similar to the &lt;CODE&gt;error&lt;/CODE&gt;
         function.  The only difference are the additional parameters &lt;VAR&gt;fname&lt;/VAR&gt;
         and &lt;VAR&gt;lineno&lt;/VAR&gt;.  The handling of the other parameters is identical to
         that of &lt;CODE&gt;error&lt;/CODE&gt; except that between the program name and the string
         generated by the format string additional text is inserted.
         &lt;br&gt;&lt;br&gt; Directly following the program name a colon, followed by the file name
         pointer to by &lt;VAR&gt;fname&lt;/VAR&gt;, another colon, and a value of &lt;VAR&gt;lineno&lt;/VAR&gt; is
         printed.
         &lt;br&gt;&lt;br&gt; This additional output of course is meant to be used to locate an error
         in an input file (like a programming language source code file etc).
         &lt;br&gt;&lt;br&gt; If the global variable &lt;CODE&gt;error_one_per_line&lt;/CODE&gt; is set to a non-zero
         value &lt;CODE&gt;error_at_line&lt;/CODE&gt; will avoid printing consecutive messages for
         the same file and line.  Repetition which are not directly following
         each other are not caught.
         &lt;br&gt;&lt;br&gt; Just like &lt;CODE&gt;error&lt;/CODE&gt; this function only returned if &lt;VAR&gt;status&lt;/VAR&gt; is
         zero.  Otherwise &lt;CODE&gt;exit&lt;/CODE&gt; is called with the non-zero value.  If
         &lt;CODE&gt;error&lt;/CODE&gt; returns the global variable &lt;CODE&gt;error_message_count&lt;/CODE&gt; is
         incremented by one to keep track of the number of errors reported.
        </synopsis>
    </function>
  </construct>
  <construct id="function-warn" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="const char *format"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "error.h"/>
        <header filename = "err.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;warn&lt;/CODE&gt; function is roughly equivalent to a call like
         &lt;pre&gt;&lt;br&gt;
           error (0, errno, format, the parameters)&lt;br&gt;
         &lt;/pre&gt;

         except that the global variables &lt;CODE&gt;error&lt;/CODE&gt; respects and modifies
         are not used.
        </synopsis>
    </function>
  </construct>
  <construct id="function-vwarn" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="const char *format"/>
        <parameter content="va_list"/>
      </prototype>
      <headers>
        <header filename = "err.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;vwarn&lt;/CODE&gt; function is just like &lt;CODE&gt;warn&lt;/CODE&gt; except that the
         parameters for the handling of the format string &lt;VAR&gt;format&lt;/VAR&gt; are passed
         in as an value of type &lt;CODE&gt;va_list&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-warnx" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="const char *format"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "err.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;warnx&lt;/CODE&gt; function is roughly equivalent to a call like
         &lt;pre&gt;&lt;br&gt;
           error (0, 0, format, the parameters)&lt;br&gt;
         &lt;/pre&gt;

         except that the global variables &lt;CODE&gt;error&lt;/CODE&gt; respects and modifies
         are not used.  The difference to &lt;CODE&gt;warn&lt;/CODE&gt; is that no error number
         string is printed.
        </synopsis>
    </function>
  </construct>
  <construct id="function-vwarnx" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="const char *format"/>
        <parameter content="va_list"/>
      </prototype>
      <headers>
        <header filename = "err.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;vwarnx&lt;/CODE&gt; function is just like &lt;CODE&gt;warnx&lt;/CODE&gt; except that the
         parameters for the handling of the format string &lt;VAR&gt;format&lt;/VAR&gt; are passed
         in as an value of type &lt;CODE&gt;va_list&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-err" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="int status"/>
        <parameter content="const char *format"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "err.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;err&lt;/CODE&gt; function is roughly equivalent to a call like
         &lt;pre&gt;&lt;br&gt;
           error (status, errno, format, the parameters)&lt;br&gt;
         &lt;/pre&gt;

         except that the global variables &lt;CODE&gt;error&lt;/CODE&gt; respects and modifies
         are not used and that the program is exited even if &lt;VAR&gt;status&lt;/VAR&gt; is zero.
        </synopsis>
    </function>
  </construct>
  <construct id="function-verr" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="int status"/>
        <parameter content="const char *format"/>
        <parameter content="va_list"/>
      </prototype>
      <headers>
        <header filename = "err.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;verr&lt;/CODE&gt; function is just like &lt;CODE&gt;err&lt;/CODE&gt; except that the
         parameters for the handling of the format string &lt;VAR&gt;format&lt;/VAR&gt; are passed
         in as an value of type &lt;CODE&gt;va_list&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-errx" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="int status"/>
        <parameter content="const char *format"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "err.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;errx&lt;/CODE&gt; function is roughly equivalent to a call like
         &lt;pre&gt;&lt;br&gt;
           error (status, 0, format, the parameters)&lt;br&gt;
         &lt;/pre&gt;

         except that the global variables &lt;CODE&gt;error&lt;/CODE&gt; respects and modifies
         are not used and that the program is exited even if &lt;VAR&gt;status&lt;/VAR&gt;
         is zero.  The difference to &lt;CODE&gt;err&lt;/CODE&gt; is that no error number
         string is printed.
        </synopsis>
    </function>
  </construct>
  <construct id="function-verrx" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="int status"/>
        <parameter content="const char *format"/>
        <parameter content="va_list"/>
      </prototype>
      <headers>
        <header filename = "err.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;verrx&lt;/CODE&gt; function is just like &lt;CODE&gt;errx&lt;/CODE&gt; except that the
         parameters for the handling of the format string &lt;VAR&gt;format&lt;/VAR&gt; are passed
         in as an value of type &lt;CODE&gt;va_list&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fnmatch" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *pattern"/>
        <parameter content="const char *string"/>
        <parameter content="int flags"/>
      </prototype>
      <headers>
        <header filename = "fnmatch.h"/>
      </headers>
        <synopsis>
        This function tests whether the string &lt;VAR&gt;string&lt;/VAR&gt; matches the pattern
         &lt;VAR&gt;pattern&lt;/VAR&gt;.  It returns &lt;CODE&gt;0&lt;/CODE&gt; if they do match; otherwise, it
         returns the nonzero value &lt;CODE&gt;FNM_NOMATCH&lt;/CODE&gt;.  The arguments
         &lt;VAR&gt;pattern&lt;/VAR&gt; and &lt;VAR&gt;string&lt;/VAR&gt; are both strings.
         &lt;br&gt;&lt;br&gt; The argument &lt;VAR&gt;flags&lt;/VAR&gt; is a combination of flag bits that alter the
         details of matching.  See below for a list of the defined flags.
         &lt;br&gt;&lt;br&gt; In the GNU C Library, &lt;CODE&gt;fnmatch&lt;/CODE&gt; cannot experience an ``error''---it
         always returns an answer for whether the match succeeds.  However, other
         implementations of &lt;CODE&gt;fnmatch&lt;/CODE&gt; might sometimes report ``errors''.
         They would do so by returning nonzero values that are not equal to
         &lt;CODE&gt;FNM_NOMATCH&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-glob_t" type="dtype">
    <structure>
        <synopsis>
        This data type holds a pointer to a word vector.  More precisely, it
         records both the address of the word vector and its size.  The GNU
         implementation contains some more fields which are non-standard
         extensions.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="gl_pathc">
            <synopsis>
            The number of elements in the vector, excluding the initial null entries
             if the GLOB_DOOFFS flag is used (see gl_offs below).
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="gl_pathv">
            <synopsis>
            The address of the vector.  This field has type &lt;CODE&gt;char **&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="gl_offs">
            <synopsis>
            The offset of the first real element of the vector, from its nominal
             address in the &lt;CODE&gt;gl_pathv&lt;/CODE&gt; field.  Unlike the other fields, this
             is always an input to &lt;CODE&gt;glob&lt;/CODE&gt;, rather than an output from it.
             &lt;br&gt;&lt;br&gt; If you use a nonzero offset, then that many elements at the beginning of
             the vector are left empty.  (The &lt;CODE&gt;glob&lt;/CODE&gt; function fills them with
             null pointers.)
             &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;gl_offs&lt;/CODE&gt; field is meaningful only if you use the
             &lt;CODE&gt;GLOB_DOOFFS&lt;/CODE&gt; flag.  Otherwise, the offset is always zero
             regardless of what is in this field, and the first real element comes at
             the beginning of the vector.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="gl_closedir">
            <synopsis>
            The address of an alternative implementation of the &lt;CODE&gt;closedir&lt;/CODE&gt;
             function.  It is used if the &lt;CODE&gt;GLOB_ALTDIRFUNC&lt;/CODE&gt; bit is set in
             the flag parameter.  The type of this field is
             &lt;CODE&gt;void (*) (void *)&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt; This is a GNU extension.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="gl_readdir">
            <synopsis>
            The address of an alternative implementation of the &lt;CODE&gt;readdir&lt;/CODE&gt;
             function used to read the contents of a directory.  It is used if the
             &lt;CODE&gt;GLOB_ALTDIRFUNC&lt;/CODE&gt; bit is set in the flag parameter.  The type of
             this field is &lt;CODE&gt;struct dirent *(*) (void *)&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt; This is a GNU extension.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="gl_opendir">
            <synopsis>
            The address of an alternative implementation of the &lt;CODE&gt;opendir&lt;/CODE&gt;
             function.  It is used if the &lt;CODE&gt;GLOB_ALTDIRFUNC&lt;/CODE&gt; bit is set in
             the flag parameter.  The type of this field is
             &lt;CODE&gt;void *(*) (const char *)&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt; This is a GNU extension.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="gl_stat">
            <synopsis>
            The address of an alternative implementation of the &lt;CODE&gt;stat&lt;/CODE&gt; function
             to get information about an object in the filesystem.  It is used if the
             &lt;CODE&gt;GLOB_ALTDIRFUNC&lt;/CODE&gt; bit is set in the flag parameter.  The type of
             this field is &lt;CODE&gt;int (*) (const char *, struct stat *)&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt; This is a GNU extension.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="dtype-glob64_t" type="dtype">
    <structure>
        <synopsis>
        This data type holds a pointer to a word vector.  More precisely, it
         records both the address of the word vector and its size.  The GNU
         implementation contains some more fields which are non-standard
         extensions.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="gl_pathc">
            <synopsis>
            The number of elements in the vector, excluding the initial null entries
             if the GLOB_DOOFFS flag is used (see gl_offs below).
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="gl_pathv">
            <synopsis>
            The address of the vector.  This field has type &lt;CODE&gt;char **&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="gl_offs">
            <synopsis>
            The offset of the first real element of the vector, from its nominal
             address in the &lt;CODE&gt;gl_pathv&lt;/CODE&gt; field.  Unlike the other fields, this
             is always an input to &lt;CODE&gt;glob&lt;/CODE&gt;, rather than an output from it.
             &lt;br&gt;&lt;br&gt; If you use a nonzero offset, then that many elements at the beginning of
             the vector are left empty.  (The &lt;CODE&gt;glob&lt;/CODE&gt; function fills them with
             null pointers.)
             &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;gl_offs&lt;/CODE&gt; field is meaningful only if you use the
             &lt;CODE&gt;GLOB_DOOFFS&lt;/CODE&gt; flag.  Otherwise, the offset is always zero
             regardless of what is in this field, and the first real element comes at
             the beginning of the vector.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="gl_closedir">
            <synopsis>
            The address of an alternative implementation of the &lt;CODE&gt;closedir&lt;/CODE&gt;
             function.  It is used if the &lt;CODE&gt;GLOB_ALTDIRFUNC&lt;/CODE&gt; bit is set in
             the flag parameter.  The type of this field is
             &lt;CODE&gt;void (*) (void *)&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt; This is a GNU extension.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="gl_readdir">
            <synopsis>
            The address of an alternative implementation of the &lt;CODE&gt;readdir64&lt;/CODE&gt;
             function used to read the contents of a directory.  It is used if the
             &lt;CODE&gt;GLOB_ALTDIRFUNC&lt;/CODE&gt; bit is set in the flag parameter.  The type of
             this field is &lt;CODE&gt;struct dirent64 *(*) (void *)&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt; This is a GNU extension.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="gl_opendir">
            <synopsis>
            The address of an alternative implementation of the &lt;CODE&gt;opendir&lt;/CODE&gt;
             function.  It is used if the &lt;CODE&gt;GLOB_ALTDIRFUNC&lt;/CODE&gt; bit is set in
             the flag parameter.  The type of this field is
             &lt;CODE&gt;void *(*) (const char *)&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt; This is a GNU extension.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="gl_stat">
            <synopsis>
            The address of an alternative implementation of the &lt;CODE&gt;stat64&lt;/CODE&gt; function
             to get information about an object in the filesystem.  It is used if the
             &lt;CODE&gt;GLOB_ALTDIRFUNC&lt;/CODE&gt; bit is set in the flag parameter.  The type of
             this field is &lt;CODE&gt;int (*) (const char *, struct stat64 *)&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt; This is a GNU extension.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-glob" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *pattern"/>
        <parameter content="int flags"/>
        <parameter content="int (*errfunc) (const char *filename"/>
        <parameter content="int error-code)"/>
        <parameter content="glob_t *vector-ptr"/>
      </prototype>
      <headers>
        <header filename = "fnmatch.h"/>
        <header filename = "glob.h"/>
      </headers>
        <synopsis>
        The function &lt;CODE&gt;glob&lt;/CODE&gt; does globbing using the pattern &lt;VAR&gt;pattern&lt;/VAR&gt;
         in the current directory.  It puts the result in a newly allocated
         vector, and stores the size and address of this vector into
         &lt;CODE&gt;*&lt;VAR&gt;vector-ptr&lt;/VAR&gt;&lt;/CODE&gt;.  The argument &lt;VAR&gt;flags&lt;/VAR&gt; is a combination of
         bit flags; see Flags for Globbing, for details of the flags.
         &lt;br&gt;&lt;br&gt; The result of globbing is a sequence of file names.  The function
         &lt;CODE&gt;glob&lt;/CODE&gt; allocates a string for each resulting word, then
         allocates a vector of type &lt;CODE&gt;char **&lt;/CODE&gt; to store the addresses of
         these strings.  The last element of the vector is a null pointer.
         This vector is called the word vector.
         &lt;br&gt;&lt;br&gt; To return this vector, &lt;CODE&gt;glob&lt;/CODE&gt; stores both its address and its
         length (number of elements, not counting the terminating null pointer)
         into &lt;CODE&gt;*&lt;VAR&gt;vector-ptr&lt;/VAR&gt;&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; Normally, &lt;CODE&gt;glob&lt;/CODE&gt; sorts the file names alphabetically before
         returning them.  You can turn this off with the flag &lt;CODE&gt;GLOB_NOSORT&lt;/CODE&gt;
         if you want to get the information as fast as possible.  Usually it's
         a good idea to let &lt;CODE&gt;glob&lt;/CODE&gt; sort them---if you process the files in
         alphabetical order, the users will have a feel for the rate of progress
         that your application is making.
         &lt;br&gt;&lt;br&gt; If &lt;CODE&gt;glob&lt;/CODE&gt; succeeds, it returns 0.  Otherwise, it returns one
         of these error codes:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;GLOB_ABORTED&lt;/CODE&gt;
&lt;DD&gt;
         There was an error opening a directory, and you used the flag
         &lt;CODE&gt;GLOB_ERR&lt;/CODE&gt; or your specified &lt;VAR&gt;errfunc&lt;/VAR&gt; returned a nonzero
         value.


         ,

         for an explanation of the &lt;CODE&gt;GLOB_ERR&lt;/CODE&gt; flag and &lt;VAR&gt;errfunc&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;GLOB_NOMATCH&lt;/CODE&gt;
&lt;DD&gt;
         The pattern didn't match any existing files.  If you use the
         &lt;CODE&gt;GLOB_NOCHECK&lt;/CODE&gt; flag, then you never get this error code, because
         that flag tells &lt;CODE&gt;glob&lt;/CODE&gt; to &lt;EM&gt;pretend&lt;/EM&gt; that the pattern matched
         at least one file.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;GLOB_NOSPACE&lt;/CODE&gt;
&lt;DD&gt;
         It was impossible to allocate memory to hold the result.
         &lt;/DL&gt;
         &lt;br&gt;&lt;br&gt; In the event of an error, &lt;CODE&gt;glob&lt;/CODE&gt; stores information in
         &lt;CODE&gt;*&lt;VAR&gt;vector-ptr&lt;/VAR&gt;&lt;/CODE&gt; about all the matches it has found so far.
         &lt;br&gt;&lt;br&gt; It is important to notice that the &lt;CODE&gt;glob&lt;/CODE&gt; function will not fail if
         it encounters directories or files which cannot be handled without the
         LFS interfaces.  The implementation of &lt;CODE&gt;glob&lt;/CODE&gt; is supposed to use
         these functions internally.  This at least is the assumptions made by
         the Unix standard.  The GNU extension of allowing the user to provide
         own directory handling and &lt;CODE&gt;stat&lt;/CODE&gt; functions complicates things a
         bit.  If these callback functions are used and a large file or directory
         is encountered &lt;CODE&gt;glob&lt;/CODE&gt; &lt;EM&gt;can&lt;/EM&gt; fail.
        </synopsis>
    </function>
  </construct>
  <construct id="function-glob64" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *pattern"/>
        <parameter content="int flags"/>
        <parameter content="int (*errfunc) (const char *filename"/>
        <parameter content="int error-code)"/>
        <parameter content="glob64_t *vector-ptr"/>
      </prototype>
      <headers>
        <header filename = "glob.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;glob64&lt;/CODE&gt; function was added as part of the Large File Summit
         extensions but is not part of the original LFS proposal.  The reason for
         this is simple: it is not necessary.  The necessity for a &lt;CODE&gt;glob64&lt;/CODE&gt;
         function is added by the extensions of the GNU &lt;CODE&gt;glob&lt;/CODE&gt;
         implementation which allows the user to provide own directory handling
         and &lt;CODE&gt;stat&lt;/CODE&gt; functions.  The &lt;CODE&gt;readdir&lt;/CODE&gt; and &lt;CODE&gt;stat&lt;/CODE&gt; functions
         do depend on the choice of &lt;CODE&gt;_FILE_OFFSET_BITS&lt;/CODE&gt; since the definition
         of the types &lt;CODE&gt;struct dirent&lt;/CODE&gt; and &lt;CODE&gt;struct stat&lt;/CODE&gt; will change
         depending on the choice.
         &lt;br&gt;&lt;br&gt; Beside this difference the &lt;CODE&gt;glob64&lt;/CODE&gt; works just like &lt;CODE&gt;glob&lt;/CODE&gt; in
         all aspects.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-globfree" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="glob_t *pglob"/>
      </prototype>
      <headers>
        <header filename = "glob.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;globfree&lt;/CODE&gt; function frees all resources allocated by previous
         calls to &lt;CODE&gt;glob&lt;/CODE&gt; associated with the object pointed to by
         &lt;VAR&gt;pglob&lt;/VAR&gt;.  This function should be called whenever the currently used
         &lt;CODE&gt;glob_t&lt;/CODE&gt; typed object isn't used anymore.
        </synopsis>
    </function>
  </construct>
  <construct id="function-globfree64" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="glob64_t *pglob"/>
      </prototype>
      <headers>
        <header filename = "glob.h"/>
      </headers>
        <synopsis>
        This function is equivalent to &lt;CODE&gt;globfree&lt;/CODE&gt; but it frees records of
         type &lt;CODE&gt;glob64_t&lt;/CODE&gt; which were allocated by &lt;CODE&gt;glob64&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-regex_t" type="dtype">
    <structure>
        <synopsis>
        This type of object holds a compiled regular expression.
         It is actually a structure.  It has just one field that your programs
         should look at:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </structure>
  </construct>
  <construct id="function-regcomp" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="regex_t *restrict compiled"/>
        <parameter content="const char *restrict pattern"/>
        <parameter content="int cflags"/>
      </prototype>
      <headers>
        <header filename = "regex.h"/>
      </headers>
        <synopsis>
        The function &lt;CODE&gt;regcomp&lt;/CODE&gt; ``compiles'' a regular expression into a
         data structure that you can use with &lt;CODE&gt;regexec&lt;/CODE&gt; to match against a
         string.  The compiled regular expression format is designed for
         efficient matching.  &lt;CODE&gt;regcomp&lt;/CODE&gt; stores it into &lt;CODE&gt;*&lt;VAR&gt;compiled&lt;/VAR&gt;&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; It's up to you to allocate an object of type &lt;CODE&gt;regex_t&lt;/CODE&gt; and pass its
         address to &lt;CODE&gt;regcomp&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The argument &lt;VAR&gt;cflags&lt;/VAR&gt; lets you specify various options that control
         the syntax and semantics of regular expressions.  .
         &lt;br&gt;&lt;br&gt; If you use the flag &lt;CODE&gt;REG_NOSUB&lt;/CODE&gt;, then &lt;CODE&gt;regcomp&lt;/CODE&gt; omits from
         the compiled regular expression the information necessary to record
         how subexpressions actually match.  In this case, you might as well
         pass &lt;CODE&gt;0&lt;/CODE&gt; for the &lt;VAR&gt;matchptr&lt;/VAR&gt; and &lt;VAR&gt;nmatch&lt;/VAR&gt; arguments when
         you call &lt;CODE&gt;regexec&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; If you don't use &lt;CODE&gt;REG_NOSUB&lt;/CODE&gt;, then the compiled regular expression
         does have the capacity to record how subexpressions match.  Also,
         &lt;CODE&gt;regcomp&lt;/CODE&gt; tells you how many subexpressions &lt;VAR&gt;pattern&lt;/VAR&gt; has, by
         storing the number in &lt;CODE&gt;&lt;VAR&gt;compiled&lt;/VAR&gt;-&gt;re_nsub&lt;/CODE&gt;.  You can use that
         value to decide how long an array to allocate to hold information about
         subexpression matches.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;regcomp&lt;/CODE&gt; returns &lt;CODE&gt;0&lt;/CODE&gt; if it succeeds in compiling the regular
         expression; otherwise, it returns a nonzero error code (see the table
         below).  You can use &lt;CODE&gt;regerror&lt;/CODE&gt; to produce an error message string
         describing the reason for a nonzero value; see Regexp Cleanup.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-regexec" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const regex_t *restrict compiled"/>
        <parameter content="const char *restrict string"/>
        <parameter content="size_t nmatch"/>
        <parameter content="regmatch_t matchptr[restrict]"/>
        <parameter content="int eflags"/>
      </prototype>
      <headers>
        <header filename = "regex.h"/>
      </headers>
        <synopsis>
        This function tries to match the compiled regular expression
         &lt;CODE&gt;*&lt;VAR&gt;compiled&lt;/VAR&gt;&lt;/CODE&gt; against &lt;VAR&gt;string&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;regexec&lt;/CODE&gt; returns &lt;CODE&gt;0&lt;/CODE&gt; if the regular expression matches;
         otherwise, it returns a nonzero value.  See the table below for
         what nonzero values mean.  You can use &lt;CODE&gt;regerror&lt;/CODE&gt; to produce an
         error message string describing the reason for a nonzero value;
         see Regexp Cleanup.
         &lt;br&gt;&lt;br&gt; The argument &lt;VAR&gt;eflags&lt;/VAR&gt; is a word of bit flags that enable various
         options.
         &lt;br&gt;&lt;br&gt; If you want to get information about what part of &lt;VAR&gt;string&lt;/VAR&gt; actually
         matched the regular expression or its subexpressions, use the arguments
         &lt;VAR&gt;matchptr&lt;/VAR&gt; and &lt;VAR&gt;nmatch&lt;/VAR&gt;.  Otherwise, pass &lt;CODE&gt;0&lt;/CODE&gt; for
         &lt;VAR&gt;nmatch&lt;/VAR&gt;, and &lt;CODE&gt;NULL&lt;/CODE&gt; for &lt;VAR&gt;matchptr&lt;/VAR&gt;.  .
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-regmatch_t" type="dtype">
    <structure>
        <synopsis>
        This is the data type of the &lt;VAR&gt;matcharray&lt;/VAR&gt; array that you pass to
         &lt;CODE&gt;regexec&lt;/CODE&gt;.  It contains two structure fields, as follows:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="rm_so">
            <synopsis>
            The offset in &lt;VAR&gt;string&lt;/VAR&gt; of the beginning of a substring.  Add this
             value to &lt;VAR&gt;string&lt;/VAR&gt; to get the address of that part.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="dtype-regoff_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="function-regfree" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="regex_t *compiled"/>
      </prototype>
      <headers>
        <header filename = "regex.h"/>
      </headers>
        <synopsis>
        Calling &lt;CODE&gt;regfree&lt;/CODE&gt; frees all the storage that &lt;CODE&gt;*&lt;VAR&gt;compiled&lt;/VAR&gt;&lt;/CODE&gt;
         points to.  This includes various internal fields of the &lt;CODE&gt;regex_t&lt;/CODE&gt;
         structure that aren't documented in this manual.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;regfree&lt;/CODE&gt; does not free the object &lt;CODE&gt;*&lt;VAR&gt;compiled&lt;/VAR&gt;&lt;/CODE&gt; itself.
        </synopsis>
    </function>
  </construct>
  <construct id="function-regerror" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="int errcode"/>
        <parameter content="const regex_t *restrict compiled"/>
        <parameter content="char *restrict buffer"/>
        <parameter content="size_t length"/>
      </prototype>
      <headers>
        <header filename = "regex.h"/>
      </headers>
        <synopsis>
        This function produces an error message string for the error code
         &lt;VAR&gt;errcode&lt;/VAR&gt;, and stores the string in &lt;VAR&gt;length&lt;/VAR&gt; bytes of memory
         starting at &lt;VAR&gt;buffer&lt;/VAR&gt;.  For the &lt;VAR&gt;compiled&lt;/VAR&gt; argument, supply the
         same compiled regular expression structure that &lt;CODE&gt;regcomp&lt;/CODE&gt; or
         &lt;CODE&gt;regexec&lt;/CODE&gt; was working with when it got the error.  Alternatively,
         you can supply &lt;CODE&gt;NULL&lt;/CODE&gt; for &lt;VAR&gt;compiled&lt;/VAR&gt;; you will still get a
         meaningful error message, but it might not be as detailed.
         &lt;br&gt;&lt;br&gt; If the error message can't fit in &lt;VAR&gt;length&lt;/VAR&gt; bytes (including a
         terminating null character), then &lt;CODE&gt;regerror&lt;/CODE&gt; truncates it.
         The string that &lt;CODE&gt;regerror&lt;/CODE&gt; stores is always null-terminated
         even if it has been truncated.
         &lt;br&gt;&lt;br&gt; The return value of &lt;CODE&gt;regerror&lt;/CODE&gt; is the minimum length needed to
         store the entire error message.  If this is less than &lt;VAR&gt;length&lt;/VAR&gt;, then
         the error message was not truncated, and you can use it.  Otherwise, you
         should call &lt;CODE&gt;regerror&lt;/CODE&gt; again with a larger buffer.
         &lt;br&gt;&lt;br&gt; Here is a function which uses &lt;CODE&gt;regerror&lt;/CODE&gt;, but always dynamically
         allocates a buffer for the error message:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         char *get_regerror (int errcode, regex_t *compiled)&lt;br&gt;
         {&lt;br&gt;
           size_t length = regerror (errcode, compiled, NULL, 0);&lt;br&gt;
           char *buffer = xmalloc (length);&lt;br&gt;
           (void) regerror (errcode, compiled, buffer, length);&lt;br&gt;
           return buffer;&lt;br&gt;
         }&lt;br&gt;
         &lt;/pre&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="type-wordexp_t" type="type">
    <structure>
        <synopsis>
        This data type holds a pointer to a word vector.  More precisely, it
         records both the address of the word vector and its size.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="we_wordc">
            <synopsis>
            The number of elements in the vector.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="we_wordv">
            <synopsis>
            The address of the vector.  This field has type &lt;CODE&gt;char **&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-wordexp" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *words"/>
        <parameter content="wordexp_t *word-vector-ptr"/>
        <parameter content="int flags"/>
      </prototype>
      <headers>
        <header filename = "wordexp.h"/>
      </headers>
        <synopsis>
        Perform word expansion on the string &lt;VAR&gt;words&lt;/VAR&gt;, putting the result in
         a newly allocated vector, and store the size and address of this vector
         into &lt;CODE&gt;*&lt;VAR&gt;word-vector-ptr&lt;/VAR&gt;&lt;/CODE&gt;.  The argument &lt;VAR&gt;flags&lt;/VAR&gt; is a
         combination of bit flags; see Flags for Wordexp, for details of
         the flags.
         &lt;br&gt;&lt;br&gt; You shouldn't use any of the characters &lt;samp&gt;|&amp;;&lt;&gt;&lt;/samp&gt; in the string
         &lt;VAR&gt;words&lt;/VAR&gt; unless they are quoted; likewise for newline.  If you use
         these characters unquoted, you will get the &lt;CODE&gt;WRDE_BADCHAR&lt;/CODE&gt; error
         code.  Don't use parentheses or braces unless they are quoted or part of
         a word expansion construct.  If you use quotation characters &lt;samp&gt;'"`&lt;/samp&gt;,
         they should come in pairs that balance.
         &lt;br&gt;&lt;br&gt; The results of word expansion are a sequence of words.  The function
         &lt;CODE&gt;wordexp&lt;/CODE&gt; allocates a string for each resulting word, then
         allocates a vector of type &lt;CODE&gt;char **&lt;/CODE&gt; to store the addresses of
         these strings.  The last element of the vector is a null pointer.
         This vector is called the word vector.
         &lt;br&gt;&lt;br&gt; To return this vector, &lt;CODE&gt;wordexp&lt;/CODE&gt; stores both its address and its
         length (number of elements, not counting the terminating null pointer)
         into &lt;CODE&gt;*&lt;VAR&gt;word-vector-ptr&lt;/VAR&gt;&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; If &lt;CODE&gt;wordexp&lt;/CODE&gt; succeeds, it returns 0.  Otherwise, it returns one
         of these error codes:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;WRDE_BADCHAR&lt;/CODE&gt;
&lt;DD&gt;
         The input string &lt;VAR&gt;words&lt;/VAR&gt; contains an unquoted invalid character such
         as &lt;samp&gt;|&lt;/samp&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; WRDE_BADVAL
         The input string refers to an undefined shell variable, and you used the flag
         &lt;CODE&gt;WRDE_UNDEF&lt;/CODE&gt; to forbid such references.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; WRDE_CMDSUB
         The input string uses command substitution, and you used the flag
         &lt;CODE&gt;WRDE_NOCMD&lt;/CODE&gt; to forbid command substitution.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; WRDE_NOSPACE
         It was impossible to allocate memory to hold the result.  In this case,
         &lt;CODE&gt;wordexp&lt;/CODE&gt; can store part of the results---as much as it could
         allocate room for.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; WRDE_SYNTAX
         There was a syntax error in the input string.  For example, an unmatched
         quoting character is a syntax error.

        </synopsis>
    </function>
  </construct>
  <construct id="function-wordfree" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="wordexp_t *word-vector-ptr"/>
      </prototype>
      <headers>
        <header filename = "wordexp.h"/>
      </headers>
        <synopsis>
        Free the storage used for the word-strings and vector that
         &lt;CODE&gt;*&lt;VAR&gt;word-vector-ptr&lt;/VAR&gt;&lt;/CODE&gt; points to.  This does not free the
         structure &lt;CODE&gt;*&lt;VAR&gt;word-vector-ptr&lt;/VAR&gt;&lt;/CODE&gt; itself---only the other
         data it points to.
        </synopsis>
    </function>
  </construct>
  <construct id="function-backtrace" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="void **buffer"/>
        <parameter content="int size"/>
      </prototype>
      <headers>
        <header filename = "wordexp.h"/>
        <header filename = "execinfo.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;backtrace&lt;/CODE&gt; function obtains a backtrace for the current
         thread, as a list of pointers, and places the information into
         &lt;VAR&gt;buffer&lt;/VAR&gt;.  The argument &lt;VAR&gt;size&lt;/VAR&gt; should be the number of
         &lt;CODE&gt;void *&lt;/CODE&gt; elements that will fit into &lt;VAR&gt;buffer&lt;/VAR&gt;.  The return
         value is the actual number of entries of &lt;VAR&gt;buffer&lt;/VAR&gt; that are obtained,
         and is at most &lt;VAR&gt;size&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The pointers placed in &lt;VAR&gt;buffer&lt;/VAR&gt; are actually return addresses
         obtained by inspecting the stack, one return address per stack frame.
         &lt;br&gt;&lt;br&gt; Note that certain compiler optimizations may interfere with obtaining a
         valid backtrace.  Function inlining causes the inlined function to not
         have a stack frame; tail call optimization replaces one stack frame with
         another; frame pointer elimination will stop &lt;CODE&gt;backtrace&lt;/CODE&gt; from
         interpreting the stack contents correctly.
        </synopsis>
    </function>
  </construct>
  <construct id="function-backtrace_symbols" type="function">
    <function returntype="char **">
      <prototype>
        <parameter content="void *const *buffer"/>
        <parameter content="int size"/>
      </prototype>
      <headers>
        <header filename = "execinfo.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;backtrace_symbols&lt;/CODE&gt; function translates the information
         obtained from the &lt;CODE&gt;backtrace&lt;/CODE&gt; function into an array of strings.
         The argument &lt;VAR&gt;buffer&lt;/VAR&gt; should be a pointer to an array of addresses
         obtained via the &lt;CODE&gt;backtrace&lt;/CODE&gt; function, and &lt;VAR&gt;size&lt;/VAR&gt; is the number
         of entries in that array (the return value of &lt;CODE&gt;backtrace&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; The return value is a pointer to an array of strings, which has
         &lt;VAR&gt;size&lt;/VAR&gt; entries just like the array &lt;VAR&gt;buffer&lt;/VAR&gt;.  Each string
         contains a printable representation of the corresponding element of
         &lt;VAR&gt;buffer&lt;/VAR&gt;.  It includes the function name (if this can be
         determined), an offset into the function, and the actual return address
         (in hexadecimal).
         &lt;br&gt;&lt;br&gt; Currently, the function name and offset only be obtained on systems that
         use the ELF binary format for programs and libraries.  On other systems,
         only the hexadecimal return address will be present.  Also, you may need
         to pass additional flags to the linker to make the function names
         available to the program.  (For example, on systems using GNU ld, you
         must pass (&lt;CODE&gt;-rdynamic&lt;/CODE&gt;.)
         &lt;br&gt;&lt;br&gt; The return value of &lt;CODE&gt;backtrace_symbols&lt;/CODE&gt; is a pointer obtained via
         the &lt;CODE&gt;malloc&lt;/CODE&gt; function, and it is the responsibility of the caller
         to &lt;CODE&gt;free&lt;/CODE&gt; that pointer.  Note that only the return value need be
         freed, not the individual strings.
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;NULL&lt;/CODE&gt; if sufficient memory for the strings
         cannot be obtained.
        </synopsis>
    </function>
  </construct>
  <construct id="function-backtrace_symbols_fd" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="void *const *buffer"/>
        <parameter content="int size"/>
        <parameter content="int fd"/>
      </prototype>
      <headers>
        <header filename = "execinfo.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;backtrace_symbols_fd&lt;/CODE&gt; function performs the same translation
         as the function &lt;CODE&gt;backtrace_symbols&lt;/CODE&gt; function.  Instead of returning
         the strings to the caller, it writes the strings to the file descriptor
         &lt;VAR&gt;fd&lt;/VAR&gt;, one per line.  It does not use the &lt;CODE&gt;malloc&lt;/CODE&gt; function, and
         can therefore be used in situations where that function might fail.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ctermid" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="char *string"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;ctermid&lt;/CODE&gt; function returns a string containing the file name of
         the controlling terminal for the current process.  If &lt;VAR&gt;string&lt;/VAR&gt; is
         not a null pointer, it should be an array that can hold at least
         &lt;CODE&gt;L_ctermid&lt;/CODE&gt; characters; the string is returned in this array.
         Otherwise, a pointer to a string in a static area is returned, which
         might get overwritten on subsequent calls to this function.
         &lt;br&gt;&lt;br&gt; An empty string is returned if the file name cannot be determined for
         any reason.  Even if a file name is returned, access to the file it
         represents is not guaranteed.
        </synopsis>
    </function>
  </construct>
  <construct id="function-setsid" type="function">
    <function returntype="pid_t">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;setsid&lt;/CODE&gt; function creates a new session.  The calling process
         becomes the session leader, and is put in a new process group whose
         process group ID is the same as the process ID of that process.  There
         are initially no other processes in the new process group, and no other
         process groups in the new session.
         &lt;br&gt;&lt;br&gt; This function also makes the calling process have no controlling terminal.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;setsid&lt;/CODE&gt; function returns the new process group ID of the
         calling process if successful.  A return value of &lt;CODE&gt;-1&lt;/CODE&gt; indicates an
         error.  The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this
         function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EPERM&lt;/CODE&gt;
&lt;DD&gt;
         The calling process is already a process group leader, or there is
         already another process group around that has the same process group ID.

        </synopsis>
    </function>
  </construct>
  <construct id="function-getsid" type="function">
    <function returntype="pid_t">
      <prototype>
        <parameter content="pid_t pid"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;getsid&lt;/CODE&gt; function returns the process group ID of the session
         leader of the specified process.  If a &lt;VAR&gt;pid&lt;/VAR&gt; is &lt;CODE&gt;0&lt;/CODE&gt;, the
         process group ID of the session leader of the current process is
         returned.
         &lt;br&gt;&lt;br&gt; In case of error &lt;CODE&gt;-1&lt;/CODE&gt; is returned and &lt;CODE&gt;errno&lt;/CODE&gt; is set.  The
         following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;ESRCH&lt;/CODE&gt;
&lt;DD&gt;
         There is no process with the given process ID &lt;VAR&gt;pid&lt;/VAR&gt;.
         &lt;LI&gt; EPERM
         The calling process and the process specified by &lt;VAR&gt;pid&lt;/VAR&gt; are in
         different sessions, and the implementation doesn't allow to access the
         process group ID of the session leader of the process with ID &lt;VAR&gt;pid&lt;/VAR&gt;
         from the calling process.

        </synopsis>
    </function>
  </construct>
  <construct id="function-setpgid" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="pid_t pid"/>
        <parameter content="pid_t pgid"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;setpgid&lt;/CODE&gt; function puts the process &lt;VAR&gt;pid&lt;/VAR&gt; into the process
         group &lt;VAR&gt;pgid&lt;/VAR&gt;.  As a special case, either &lt;VAR&gt;pid&lt;/VAR&gt; or &lt;VAR&gt;pgid&lt;/VAR&gt; can
         be zero to indicate the process ID of the calling process.
         &lt;br&gt;&lt;br&gt; This function fails on a system that does not support job control.
         , for more information.
         &lt;br&gt;&lt;br&gt; If the operation is successful, &lt;CODE&gt;setpgid&lt;/CODE&gt; returns zero.  Otherwise
         it returns &lt;CODE&gt;-1&lt;/CODE&gt;.  The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are
         defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EACCES&lt;/CODE&gt;
&lt;DD&gt;
         The child process named by &lt;VAR&gt;pid&lt;/VAR&gt; has executed an &lt;CODE&gt;exec&lt;/CODE&gt;
         function since it was forked.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         The value of the &lt;VAR&gt;pgid&lt;/VAR&gt; is not valid.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOSYS
         The system doesn't support job control.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EPERM
         The process indicated by the &lt;VAR&gt;pid&lt;/VAR&gt; argument is a session leader,
         or is not in the same session as the calling process, or the value of
         the &lt;VAR&gt;pgid&lt;/VAR&gt; argument doesn't match a process group ID in the same
         session as the calling process.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ESRCH
         The process indicated by the &lt;VAR&gt;pid&lt;/VAR&gt; argument is not the calling
         process or a child of the calling process.

        </synopsis>
    </function>
  </construct>
  <construct id="function-setpgrp" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="pid_t pid"/>
        <parameter content="pid_t pgid"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        This is the BSD Unix name for &lt;CODE&gt;setpgid&lt;/CODE&gt;.  Both functions do exactly
         the same thing.
        </synopsis>
    </function>
  </construct>
  <construct id="function-tcgetpgrp" type="function">
    <function returntype="pid_t">
      <prototype>
        <parameter content="int filedes"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        This function returns the process group ID of the foreground process
         group associated with the terminal open on descriptor &lt;VAR&gt;filedes&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If there is no foreground process group, the return value is a number
         greater than &lt;CODE&gt;1&lt;/CODE&gt; that does not match the process group ID of any
         existing process group.  This can happen if all of the processes in the
         job that was formerly the foreground job have terminated, and no other
         job has yet been moved into the foreground.
         &lt;br&gt;&lt;br&gt; In case of an error, a value of &lt;CODE&gt;-1&lt;/CODE&gt; is returned.  The
         following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;filedes&lt;/VAR&gt; argument is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOSYS
         The system doesn't support job control.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOTTY
         The terminal file associated with the &lt;VAR&gt;filedes&lt;/VAR&gt; argument isn't the
         controlling terminal of the calling process.

        </synopsis>
    </function>
  </construct>
  <construct id="function-tcsetpgrp" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="pid_t pgid"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        This function is used to set a terminal's foreground process group ID.
         The argument &lt;VAR&gt;filedes&lt;/VAR&gt; is a descriptor which specifies the terminal;
         &lt;VAR&gt;pgid&lt;/VAR&gt; specifies the process group.  The calling process must be a
         member of the same session as &lt;VAR&gt;pgid&lt;/VAR&gt; and must have the same
         controlling terminal.
         &lt;br&gt;&lt;br&gt; For terminal access purposes, this function is treated as output.  If it
         is called from a background process on its controlling terminal,
         normally all processes in the process group are sent a &lt;CODE&gt;SIGTTOU&lt;/CODE&gt;
         signal.  The exception is if the calling process itself is ignoring or
         blocking &lt;CODE&gt;SIGTTOU&lt;/CODE&gt; signals, in which case the operation is
         performed and no signal is sent.
         &lt;br&gt;&lt;br&gt; If successful, &lt;CODE&gt;tcsetpgrp&lt;/CODE&gt; returns &lt;CODE&gt;0&lt;/CODE&gt;.  A return value of
         &lt;CODE&gt;-1&lt;/CODE&gt; indicates an error.  The following &lt;CODE&gt;errno&lt;/CODE&gt; error
         conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;filedes&lt;/VAR&gt; argument is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         The &lt;VAR&gt;pgid&lt;/VAR&gt; argument is not valid.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOSYS
         The system doesn't support job control.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOTTY
         The &lt;VAR&gt;filedes&lt;/VAR&gt; isn't the controlling terminal of the calling process.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EPERM
         The &lt;VAR&gt;pgid&lt;/VAR&gt; isn't a process group in the same session as the calling
         process.

        </synopsis>
    </function>
  </construct>
  <construct id="function-tcgetsid" type="function">
    <function returntype="pid_t">
      <prototype>
        <parameter content="int fildes"/>
      </prototype>
      <headers>
        <header filename = "termios.h"/>
      </headers>
        <synopsis>
        This function is used to obtain the process group ID of the session
         for which the terminal specified by &lt;VAR&gt;fildes&lt;/VAR&gt; is the controlling terminal.
         If the call is successful the group ID is returned.  Otherwise the
         return value is &lt;CODE&gt;(pid_t) -1&lt;/CODE&gt; and the global variable &lt;VAR&gt;errno&lt;/VAR&gt;
         is set to the following value:
         &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;filedes&lt;/VAR&gt; argument is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOTTY
         The calling process does not have a controlling terminal, or the file
         is not the controlling terminal.

        </synopsis>
    </function>
  </construct>
  <construct id="function-islower" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int c"/>
      </prototype>
      <headers>
        <header filename = "ctype.h"/>
      </headers>
        <synopsis>
        Returns true if &lt;VAR&gt;c&lt;/VAR&gt; is a lower-case letter.  The letter need not be
         from the Latin alphabet, any alphabet representable is valid.
        </synopsis>
    </function>
  </construct>
  <construct id="function-isupper" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int c"/>
      </prototype>
      <headers>
        <header filename = "ctype.h"/>
      </headers>
        <synopsis>
        Returns true if &lt;VAR&gt;c&lt;/VAR&gt; is an upper-case letter.  The letter need not be
         from the Latin alphabet, any alphabet representable is valid.
        </synopsis>
    </function>
  </construct>
  <construct id="function-isalpha" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int c"/>
      </prototype>
      <headers>
        <header filename = "ctype.h"/>
      </headers>
        <synopsis>
        Returns true if &lt;VAR&gt;c&lt;/VAR&gt; is an alphabetic character (a letter).  If
         &lt;CODE&gt;islower&lt;/CODE&gt; or &lt;CODE&gt;isupper&lt;/CODE&gt; is true of a character, then
         &lt;CODE&gt;isalpha&lt;/CODE&gt; is also true.
         &lt;br&gt;&lt;br&gt; In some locales, there may be additional characters for which
         &lt;CODE&gt;isalpha&lt;/CODE&gt; is true---letters which are neither upper case nor lower
         case.  But in the standard &lt;CODE&gt;"C"&lt;/CODE&gt; locale, there are no such
         additional characters.
        </synopsis>
    </function>
  </construct>
  <construct id="function-isdigit" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int c"/>
      </prototype>
      <headers>
        <header filename = "ctype.h"/>
      </headers>
        <synopsis>
        Returns true if &lt;VAR&gt;c&lt;/VAR&gt; is a decimal digit (&lt;samp&gt;0&lt;/samp&gt; through &lt;samp&gt;9&lt;/samp&gt;).
        </synopsis>
    </function>
  </construct>
  <construct id="function-isalnum" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int c"/>
      </prototype>
      <headers>
        <header filename = "ctype.h"/>
      </headers>
        <synopsis>
        Returns true if &lt;VAR&gt;c&lt;/VAR&gt; is an alphanumeric character (a letter or
         number); in other words, if either &lt;CODE&gt;isalpha&lt;/CODE&gt; or &lt;CODE&gt;isdigit&lt;/CODE&gt; is
         true of a character, then &lt;CODE&gt;isalnum&lt;/CODE&gt; is also true.
        </synopsis>
    </function>
  </construct>
  <construct id="function-isxdigit" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int c"/>
      </prototype>
      <headers>
        <header filename = "ctype.h"/>
      </headers>
        <synopsis>
        Returns true if &lt;VAR&gt;c&lt;/VAR&gt; is a hexadecimal digit.
         Hexadecimal digits include the normal decimal digits &lt;samp&gt;0&lt;/samp&gt; through
         &lt;samp&gt;9&lt;/samp&gt; and the letters &lt;samp&gt;A&lt;/samp&gt; through &lt;samp&gt;F&lt;/samp&gt; and
         &lt;samp&gt;a&lt;/samp&gt; through &lt;samp&gt;f&lt;/samp&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ispunct" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int c"/>
      </prototype>
      <headers>
        <header filename = "ctype.h"/>
      </headers>
        <synopsis>
        Returns true if &lt;VAR&gt;c&lt;/VAR&gt; is a punctuation character.
         This means any printing character that is not alphanumeric or a space
         character.
        </synopsis>
    </function>
  </construct>
  <construct id="function-isspace" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int c"/>
      </prototype>
      <headers>
        <header filename = "ctype.h"/>
      </headers>
        <synopsis>
        Returns true if &lt;VAR&gt;c&lt;/VAR&gt; is a whitespace character.  In the standard
         &lt;CODE&gt;"C"&lt;/CODE&gt; locale, &lt;CODE&gt;isspace&lt;/CODE&gt; returns true for only the standard
         whitespace characters:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;' '&lt;/CODE&gt;
&lt;DD&gt;
         space
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; '\f'
         formfeed
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; '\n'
         newline
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; '\r'
         carriage return
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; '\t'
         horizontal tab
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; '\v'
         vertical tab

        </synopsis>
    </function>
  </construct>
  <construct id="function-isblank" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int c"/>
      </prototype>
      <headers>
        <header filename = "ctype.h"/>
      </headers>
        <synopsis>
        Returns true if &lt;VAR&gt;c&lt;/VAR&gt; is a blank character; that is, a space or a tab.
         This function was originally a GNU extension, but was added in ISO C99.
        </synopsis>
    </function>
  </construct>
  <construct id="function-isgraph" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int c"/>
      </prototype>
      <headers>
        <header filename = "ctype.h"/>
      </headers>
        <synopsis>
        Returns true if &lt;VAR&gt;c&lt;/VAR&gt; is a graphic character; that is, a character
         that has a glyph associated with it.  The whitespace characters are not
         considered graphic.
        </synopsis>
    </function>
  </construct>
  <construct id="function-isprint" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int c"/>
      </prototype>
      <headers>
        <header filename = "ctype.h"/>
      </headers>
        <synopsis>
        Returns true if &lt;VAR&gt;c&lt;/VAR&gt; is a printing character.  Printing characters
         include all the graphic characters, plus the space (&lt;samp&gt; &lt;/samp&gt;) character.
        </synopsis>
    </function>
  </construct>
  <construct id="function-iscntrl" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int c"/>
      </prototype>
      <headers>
        <header filename = "ctype.h"/>
      </headers>
        <synopsis>
        Returns true if &lt;VAR&gt;c&lt;/VAR&gt; is a control character (that is, a character that
         is not a printing character).
        </synopsis>
    </function>
  </construct>
  <construct id="function-isascii" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int c"/>
      </prototype>
      <headers>
        <header filename = "ctype.h"/>
      </headers>
        <synopsis>
        Returns true if &lt;VAR&gt;c&lt;/VAR&gt; is a 7-bit &lt;CODE&gt;unsigned char&lt;/CODE&gt; value that fits
         into the US/UK ASCII character set.  This function is a BSD extension
         and is also an SVID extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-tolower" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int c"/>
      </prototype>
      <headers>
        <header filename = "ctype.h"/>
      </headers>
        <synopsis>
        If &lt;VAR&gt;c&lt;/VAR&gt; is an upper-case letter, &lt;CODE&gt;tolower&lt;/CODE&gt; returns the corresponding
         lower-case letter.  If &lt;VAR&gt;c&lt;/VAR&gt; is not an upper-case letter,
         &lt;VAR&gt;c&lt;/VAR&gt; is returned unchanged.
        </synopsis>
    </function>
  </construct>
  <construct id="function-toupper" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int c"/>
      </prototype>
      <headers>
        <header filename = "ctype.h"/>
      </headers>
        <synopsis>
        If &lt;VAR&gt;c&lt;/VAR&gt; is a lower-case letter, &lt;CODE&gt;toupper&lt;/CODE&gt; returns the corresponding
         upper-case letter.  Otherwise &lt;VAR&gt;c&lt;/VAR&gt; is returned unchanged.
        </synopsis>
    </function>
  </construct>
  <construct id="function-toascii" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int c"/>
      </prototype>
      <headers>
        <header filename = "ctype.h"/>
      </headers>
        <synopsis>
        This function converts &lt;VAR&gt;c&lt;/VAR&gt; to a 7-bit &lt;CODE&gt;unsigned char&lt;/CODE&gt; value
         that fits into the US/UK ASCII character set, by clearing the high-order
         bits.  This function is a BSD extension and is also an SVID extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-_tolower" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int c"/>
      </prototype>
      <headers>
        <header filename = "ctype.h"/>
      </headers>
        <synopsis>
        This is identical to &lt;CODE&gt;tolower&lt;/CODE&gt;, and is provided for compatibility
         with the SVID.  .
        </synopsis>
    </function>
  </construct>
  <construct id="function-_toupper" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int c"/>
      </prototype>
      <headers>
        <header filename = "ctype.h"/>
      </headers>
        <synopsis>
        This is identical to &lt;CODE&gt;toupper&lt;/CODE&gt;, and is provided for compatibility
         with the SVID.
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-wctype_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="function-wctype" type="function">
    <function returntype="wctype_t">
      <prototype>
        <parameter content="const char *property"/>
      </prototype>
      <headers>
        <header filename = "wctype.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wctype&lt;/CODE&gt; returns a value representing a class of wide
         characters which is identified by the string &lt;VAR&gt;property&lt;/VAR&gt;.  Beside
         some standard properties each locale can define its own ones.  In case
         no property with the given name is known for the current locale
         selected for the &lt;CODE&gt;LC_CTYPE&lt;/CODE&gt; category, the function returns zero.
         &lt;br&gt;&lt;br&gt;
         The properties known in every locale are:
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;pre&gt;&lt;/pre&gt;
&lt;DD&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; This function is declared in &lt;TT&gt;wctype.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-iswctype" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="wint_t wc"/>
        <parameter content="wctype_t desc"/>
      </prototype>
      <headers>
        <header filename = "wctype.h"/>
      </headers>
        <synopsis>
        This function returns a nonzero value if &lt;VAR&gt;wc&lt;/VAR&gt; is in the character
         class specified by &lt;VAR&gt;desc&lt;/VAR&gt;.  &lt;VAR&gt;desc&lt;/VAR&gt; must previously be returned
         by a successful call to &lt;CODE&gt;wctype&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This function is declared in &lt;TT&gt;wctype.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-iswalnum" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="wint_t wc"/>
      </prototype>
      <headers>
        <header filename = "wctype.h"/>
      </headers>
        <synopsis>
        This function returns a nonzero value if &lt;VAR&gt;wc&lt;/VAR&gt; is an alphanumeric
         character (a letter or number); in other words, if either &lt;CODE&gt;iswalpha&lt;/CODE&gt;
         or &lt;CODE&gt;iswdigit&lt;/CODE&gt; is true of a character, then &lt;CODE&gt;iswalnum&lt;/CODE&gt; is also
         true.
         &lt;br&gt;&lt;br&gt;
         This function can be implemented using
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         iswctype (wc, wctype ("alnum"))&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; It is declared in &lt;TT&gt;wctype.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-iswalpha" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="wint_t wc"/>
      </prototype>
      <headers>
        <header filename = "wctype.h"/>
      </headers>
        <synopsis>
        Returns true if &lt;VAR&gt;wc&lt;/VAR&gt; is an alphabetic character (a letter).  If
         &lt;CODE&gt;iswlower&lt;/CODE&gt; or &lt;CODE&gt;iswupper&lt;/CODE&gt; is true of a character, then
         &lt;CODE&gt;iswalpha&lt;/CODE&gt; is also true.
         &lt;br&gt;&lt;br&gt; In some locales, there may be additional characters for which
         &lt;CODE&gt;iswalpha&lt;/CODE&gt; is true---letters which are neither upper case nor lower
         case.  But in the standard &lt;CODE&gt;"C"&lt;/CODE&gt; locale, there are no such
         additional characters.
         &lt;br&gt;&lt;br&gt;
         This function can be implemented using
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         iswctype (wc, wctype ("alpha"))&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; It is declared in &lt;TT&gt;wctype.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-iswcntrl" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="wint_t wc"/>
      </prototype>
      <headers>
        <header filename = "wctype.h"/>
      </headers>
        <synopsis>
        Returns true if &lt;VAR&gt;wc&lt;/VAR&gt; is a control character (that is, a character that
         is not a printing character).
         &lt;br&gt;&lt;br&gt;
         This function can be implemented using
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         iswctype (wc, wctype ("cntrl"))&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; It is declared in &lt;TT&gt;wctype.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-iswdigit" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="wint_t wc"/>
      </prototype>
      <headers>
        <header filename = "wctype.h"/>
      </headers>
        <synopsis>
        Returns true if &lt;VAR&gt;wc&lt;/VAR&gt; is a digit (e.g., &lt;samp&gt;0&lt;/samp&gt; through &lt;samp&gt;9&lt;/samp&gt;).
         Please note that this function does not only return a nonzero value for
         &lt;EM&gt;decimal&lt;/EM&gt; digits, but for all kinds of digits.  A consequence is
         that code like the following will &lt;h3&gt;not&lt;/h3&gt; work unconditionally for
         wide characters:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         n = 0;&lt;br&gt;
         while (iswdigit (*wc))&lt;br&gt;
           {&lt;br&gt;
             n *= 10;&lt;br&gt;
             n += *wc++ - L'0';&lt;br&gt;
           }&lt;br&gt;
         &lt;/pre&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;br&gt;
         This function can be implemented using&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         iswctype (wc, wctype ("digit"))&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; It is declared in &lt;TT&gt;wctype.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-iswgraph" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="wint_t wc"/>
      </prototype>
      <headers>
        <header filename = "wctype.h"/>
      </headers>
        <synopsis>
        Returns true if &lt;VAR&gt;wc&lt;/VAR&gt; is a graphic character; that is, a character
         that has a glyph associated with it.  The whitespace characters are not
         considered graphic.
         &lt;br&gt;&lt;br&gt;
         This function can be implemented using
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         iswctype (wc, wctype ("graph"))&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; It is declared in &lt;TT&gt;wctype.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-iswlower" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="wint_t wc"/>
      </prototype>
      <headers>
        <header filename = "ctype.h"/>
      </headers>
        <synopsis>
        Returns true if &lt;VAR&gt;wc&lt;/VAR&gt; is a lower-case letter.  The letter need not be
         from the Latin alphabet, any alphabet representable is valid.
         &lt;br&gt;&lt;br&gt;
         This function can be implemented using
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         iswctype (wc, wctype ("lower"))&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; It is declared in &lt;TT&gt;wctype.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-iswprint" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="wint_t wc"/>
      </prototype>
      <headers>
        <header filename = "wctype.h"/>
      </headers>
        <synopsis>
        Returns true if &lt;VAR&gt;wc&lt;/VAR&gt; is a printing character.  Printing characters
         include all the graphic characters, plus the space (&lt;samp&gt; &lt;/samp&gt;) character.
         &lt;br&gt;&lt;br&gt;
         This function can be implemented using
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         iswctype (wc, wctype ("print"))&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; It is declared in &lt;TT&gt;wctype.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-iswpunct" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="wint_t wc"/>
      </prototype>
      <headers>
        <header filename = "wctype.h"/>
      </headers>
        <synopsis>
        Returns true if &lt;VAR&gt;wc&lt;/VAR&gt; is a punctuation character.
         This means any printing character that is not alphanumeric or a space
         character.
         &lt;br&gt;&lt;br&gt;
         This function can be implemented using
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         iswctype (wc, wctype ("punct"))&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; It is declared in &lt;TT&gt;wctype.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-iswspace" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="wint_t wc"/>
      </prototype>
      <headers>
        <header filename = "wctype.h"/>
      </headers>
        <synopsis>
        Returns true if &lt;VAR&gt;wc&lt;/VAR&gt; is a whitespace character.  In the standard
         &lt;CODE&gt;"C"&lt;/CODE&gt; locale, &lt;CODE&gt;iswspace&lt;/CODE&gt; returns true for only the standard
         whitespace characters:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;L' '&lt;/CODE&gt;
&lt;DD&gt;
         space
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; L'\f'
         formfeed
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; L'\n'
         newline
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; L'\r'
         carriage return
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; L'\t'
         horizontal tab
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; L'\v'
         vertical tab

         &lt;br&gt;&lt;br&gt;
         This function can be implemented using
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         iswctype (wc, wctype ("space"))&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; It is declared in &lt;TT&gt;wctype.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-iswupper" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="wint_t wc"/>
      </prototype>
      <headers>
        <header filename = "wctype.h"/>
      </headers>
        <synopsis>
        Returns true if &lt;VAR&gt;wc&lt;/VAR&gt; is an upper-case letter.  The letter need not be
         from the Latin alphabet, any alphabet representable is valid.
         &lt;br&gt;&lt;br&gt;
         This function can be implemented using
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         iswctype (wc, wctype ("upper"))&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; It is declared in &lt;TT&gt;wctype.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-iswxdigit" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="wint_t wc"/>
      </prototype>
      <headers>
        <header filename = "wctype.h"/>
      </headers>
        <synopsis>
        Returns true if &lt;VAR&gt;wc&lt;/VAR&gt; is a hexadecimal digit.
         Hexadecimal digits include the normal decimal digits &lt;samp&gt;0&lt;/samp&gt; through
         &lt;samp&gt;9&lt;/samp&gt; and the letters &lt;samp&gt;A&lt;/samp&gt; through &lt;samp&gt;F&lt;/samp&gt; and
         &lt;samp&gt;a&lt;/samp&gt; through &lt;samp&gt;f&lt;/samp&gt;.
         &lt;br&gt;&lt;br&gt;
         This function can be implemented using
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         iswctype (wc, wctype ("xdigit"))&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; It is declared in &lt;TT&gt;wctype.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-iswblank" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="wint_t wc"/>
      </prototype>
      <headers>
        <header filename = "wctype.h"/>
      </headers>
        <synopsis>
        Returns true if &lt;VAR&gt;wc&lt;/VAR&gt; is a blank character; that is, a space or a tab.
         This function was originally a GNU extension, but was added in ISO C99.
         It is declared in &lt;TT&gt;wchar.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-wctrans_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="function-wctrans" type="function">
    <function returntype="wctrans_t">
      <prototype>
        <parameter content="const char *property"/>
      </prototype>
      <headers>
        <header filename = "wctype.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wctrans&lt;/CODE&gt; function has to be used to find out whether a named
         mapping is defined in the current locale selected for the
         &lt;CODE&gt;LC_CTYPE&lt;/CODE&gt; category.  If the returned value is non-zero, you can use
         it afterwards in calls to &lt;CODE&gt;towctrans&lt;/CODE&gt;.  If the return value is
         zero no such mapping is known in the current locale.
         &lt;br&gt;&lt;br&gt; Beside locale-specific mappings there are two mappings which are
         guaranteed to be available in every locale:
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;pre&gt;&lt;/pre&gt;
&lt;DD&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt;
         These functions are declared in &lt;TT&gt;wctype.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-towctrans" type="function">
    <function returntype="wint_t">
      <prototype>
        <parameter content="wint_t wc"/>
        <parameter content="wctrans_t desc"/>
      </prototype>
      <headers>
        <header filename = "wctype.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;towctrans&lt;/CODE&gt; maps the input character &lt;VAR&gt;wc&lt;/VAR&gt;
         according to the rules of the mapping for which &lt;VAR&gt;desc&lt;/VAR&gt; is a
         descriptor, and returns the value it finds.  &lt;VAR&gt;desc&lt;/VAR&gt; must be
         obtained by a successful call to &lt;CODE&gt;wctrans&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt;
         This function is declared in &lt;TT&gt;wctype.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-towlower" type="function">
    <function returntype="wint_t">
      <prototype>
        <parameter content="wint_t wc"/>
      </prototype>
      <headers>
        <header filename = "wctype.h"/>
      </headers>
        <synopsis>
        If &lt;VAR&gt;wc&lt;/VAR&gt; is an upper-case letter, &lt;CODE&gt;towlower&lt;/CODE&gt; returns the corresponding
         lower-case letter.  If &lt;VAR&gt;wc&lt;/VAR&gt; is not an upper-case letter,
         &lt;VAR&gt;wc&lt;/VAR&gt; is returned unchanged.
         &lt;br&gt;&lt;br&gt;
         &lt;CODE&gt;towlower&lt;/CODE&gt; can be implemented using
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         towctrans (wc, wctrans ("tolower"))&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt;
         This function is declared in &lt;TT&gt;wctype.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-towupper" type="function">
    <function returntype="wint_t">
      <prototype>
        <parameter content="wint_t wc"/>
      </prototype>
      <headers>
        <header filename = "wctype.h"/>
      </headers>
        <synopsis>
        If &lt;VAR&gt;wc&lt;/VAR&gt; is a lower-case letter, &lt;CODE&gt;towupper&lt;/CODE&gt; returns the corresponding
         upper-case letter.  Otherwise &lt;VAR&gt;wc&lt;/VAR&gt; is returned unchanged.
         &lt;br&gt;&lt;br&gt;
         &lt;CODE&gt;towupper&lt;/CODE&gt; can be implemented using
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         towctrans (wc, wctrans ("toupper"))&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt;
         This function is declared in &lt;TT&gt;wctype.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-catopen" type="function">
    <function returntype="nl_catd">
      <prototype>
        <parameter content="const char *cat_name"/>
        <parameter content="int flag"/>
      </prototype>
      <headers>
        <header filename = "nl_types.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;catgets&lt;/CODE&gt; function tries to locate the message data file names
         &lt;VAR&gt;cat_name&lt;/VAR&gt; and loads it when found.  The return value is of an
         opaque type and can be used in calls to the other functions to refer to
         this loaded catalog.
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;(nl_catd) -1&lt;/CODE&gt; in case the function failed and
         no catalog was loaded.  The global variable &lt;VAR&gt;errno&lt;/VAR&gt; contains a code
         for the error causing the failure.  But even if the function call
         succeeded this does not mean that all messages can be translated.
         &lt;br&gt;&lt;br&gt; Locating the catalog file must happen in a way which lets the user of
         the program influence the decision.  It is up to the user to decide
         about the language to use and sometimes it is useful to use alternate
         catalog files.  All this can be specified by the user by setting some
         environment variables.
         &lt;br&gt;&lt;br&gt; The first problem is to find out where all the message catalogs are
         stored.  Every program could have its own place to keep all the
         different files but usually the catalog files are grouped by languages
         and the catalogs for all programs are kept in the same place.
         &lt;br&gt;&lt;br&gt;  environment variable
         To tell the &lt;CODE&gt;catopen&lt;/CODE&gt; function where the catalog for the program
         can be found the user can set the environment variable &lt;CODE&gt;NLSPATH&lt;/CODE&gt; to
         a value which describes her/his choice.  Since this value must be usable
         for different languages and locales it cannot be a simple string.
         Instead it is a format string (similar to &lt;CODE&gt;printf&lt;/CODE&gt;'s).  An example
         is
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         /usr/share/locale/%L/%N:/usr/share/locale/%L/LC_MESSAGES/%N&lt;br&gt;
         &lt;/pre&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; First one can see that more than one directory can be specified (with&lt;br&gt;
         the usual syntax of separating them by colons).  The next things to&lt;br&gt;
         observe are the format string, &lt;CODE&gt;%L&lt;/CODE&gt; and &lt;CODE&gt;%N&lt;/CODE&gt; in this case.&lt;br&gt;
         The &lt;CODE&gt;catopen&lt;/CODE&gt; function knows about several of them and the&lt;br&gt;
         replacement for all of them is of course different.&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;
&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;%N&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         This format element is substituted with the name of the catalog file.&lt;br&gt;
         This is the value of the &lt;VAR&gt;cat_name&lt;/VAR&gt; argument given to&lt;br&gt;
         &lt;CODE&gt;catgets&lt;/CODE&gt;.&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;%L&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         This format element is substituted with the name of the currently&lt;br&gt;
         selected locale for translating messages.  How this is determined is&lt;br&gt;
         explained below.&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %l&lt;br&gt;
         (This is the lowercase ell.) This format element is substituted with the&lt;br&gt;
         language element of the locale name.  The string describing the selected&lt;br&gt;
         locale is expected to have the form&lt;br&gt;
         &lt;CODE&gt;&lt;VAR&gt;lang&lt;/VAR&gt;[_&lt;VAR&gt;terr&lt;/VAR&gt;[.&lt;VAR&gt;codeset&lt;/VAR&gt;]]&lt;/CODE&gt; and this format uses the&lt;br&gt;
         first part &lt;VAR&gt;lang&lt;/VAR&gt;.&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %t&lt;br&gt;
         This format element is substituted by the territory part &lt;VAR&gt;terr&lt;/VAR&gt; of&lt;br&gt;
         the name of the currently selected locale.  See the explanation of the&lt;br&gt;
         format above.&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %c&lt;br&gt;
         This format element is substituted by the codeset part &lt;VAR&gt;codeset&lt;/VAR&gt; of&lt;br&gt;
         the name of the currently selected locale.  See the explanation of the&lt;br&gt;
         format above.&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; %%&lt;br&gt;
         Since &lt;CODE&gt;%&lt;/CODE&gt; is used in a meta character there must be a way to&lt;br&gt;
         express the &lt;CODE&gt;%&lt;/CODE&gt; character in the result itself.  Using &lt;CODE&gt;%%&lt;/CODE&gt;&lt;br&gt;
         does this just like it works for &lt;CODE&gt;printf&lt;/CODE&gt;.&lt;br&gt;
         &lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt; Using &lt;CODE&gt;NLSPATH&lt;/CODE&gt; allows arbitrary directories to be searched for&lt;br&gt;
         message catalogs while still allowing different languages to be used.&lt;br&gt;
         If the &lt;CODE&gt;NLSPATH&lt;/CODE&gt; environment variable is not set, the default value&lt;br&gt;
         is&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         &lt;VAR&gt;prefix&lt;/VAR&gt;/share/locale/%L/%N:&lt;VAR&gt;prefix&lt;/VAR&gt;/share/locale/%L/LC_MESSAGES/%N&lt;br&gt;
         &lt;/pre&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;br&gt;
         where &lt;VAR&gt;prefix&lt;/VAR&gt; is given to &lt;CODE&gt;configure&lt;/CODE&gt; while installing the GNU&lt;br&gt;
         C Library (this value is in many cases &lt;CODE&gt;/usr&lt;/CODE&gt; or the empty string).&lt;br&gt;
         &lt;br&gt;&lt;br&gt; The remaining problem is to decide which must be used.  The value&lt;br&gt;
         decides about the substitution of the format elements mentioned above.&lt;br&gt;
         First of all the user can specify a path in the message catalog name&lt;br&gt;
         (i.e., the name contains a slash character).  In this situation the&lt;br&gt;
         &lt;CODE&gt;NLSPATH&lt;/CODE&gt; environment variable is not used.  The catalog must exist&lt;br&gt;
         as specified in the program, perhaps relative to the current working&lt;br&gt;
         directory.  This situation in not desirable and catalogs names never&lt;br&gt;
         should be written this way.  Beside this, this behavior is not portable&lt;br&gt;
         to all other platforms providing the &lt;CODE&gt;catgets&lt;/CODE&gt; interface.&lt;br&gt;
         &lt;br&gt;&lt;br&gt;  environment variable&lt;br&gt;
          environment variable&lt;br&gt;
          environment variable&lt;br&gt;
         Otherwise the values of environment variables from the standard&lt;br&gt;
         environment are examined. Which&lt;br&gt;
         variables are examined is decided by the &lt;VAR&gt;flag&lt;/VAR&gt; parameter of&lt;br&gt;
         &lt;CODE&gt;catopen&lt;/CODE&gt;.  If the value is &lt;CODE&gt;NL_CAT_LOCALE&lt;/CODE&gt; (which is defined&lt;br&gt;
         in &lt;TT&gt;nl_types.h&lt;/TT&gt;) then the &lt;CODE&gt;catopen&lt;/CODE&gt; function use the name of&lt;br&gt;
         the locale currently selected for the &lt;CODE&gt;LC_MESSAGES&lt;/CODE&gt; category.&lt;br&gt;
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;flag&lt;/VAR&gt; is zero the &lt;CODE&gt;LANG&lt;/CODE&gt; environment variable is examined.&lt;br&gt;
         This is a left-over from the early days where the concept of the locales&lt;br&gt;
         had not even reached the level of POSIX locales.&lt;br&gt;
         &lt;br&gt;&lt;br&gt; The environment variable and the locale name should have a value of the&lt;br&gt;
         form &lt;CODE&gt;&lt;VAR&gt;lang&lt;/VAR&gt;[_&lt;VAR&gt;terr&lt;/VAR&gt;[.&lt;VAR&gt;codeset&lt;/VAR&gt;]]&lt;/CODE&gt; as explained above.&lt;br&gt;
         If no environment variable is set the &lt;CODE&gt;"C"&lt;/CODE&gt; locale is used which&lt;br&gt;
         prevents any translation.&lt;br&gt;
         &lt;br&gt;&lt;br&gt; The return value of the function is in any case a valid string.  Either&lt;br&gt;
         it is a translation from a message catalog or it is the same as the&lt;br&gt;
         &lt;VAR&gt;string&lt;/VAR&gt; parameter.  So a piece of code to decide whether a&lt;br&gt;
         translation actually happened must look like this:&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         {&lt;br&gt;
           char *trans = catgets (desc, set, msg, input_string);&lt;br&gt;
           if (trans == input_string)&lt;br&gt;
             {&lt;br&gt;
               /* Something went wrong.  */&lt;br&gt;
             }&lt;br&gt;
         }&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt;
         When an error occurred the global variable &lt;VAR&gt;errno&lt;/VAR&gt; is set to
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;LI&gt; EBADF
         The catalog does not exist.
         &lt;LI&gt; ENOMSG
         The set/message tuple does not name an existing element in the
         message catalog.

         &lt;br&gt;&lt;br&gt; While it sometimes can be useful to test for errors programs normally
         will avoid any test.  If the translation is not available it is no big
         problem if the original, untranslated message is printed.  Either the
         user understands this as well or s/he will look for the reason why the
         messages are not translated.
        </synopsis>
    </function>
  </construct>
  <construct id="function-catgets" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="nl_catd catalog_desc"/>
        <parameter content="int set"/>
        <parameter content="int message"/>
        <parameter content="const char *string"/>
      </prototype>
        <synopsis>
        The function &lt;CODE&gt;catgets&lt;/CODE&gt; has to be used to access the massage catalog
         previously opened using the &lt;CODE&gt;catopen&lt;/CODE&gt; function.  The
         &lt;VAR&gt;catalog_desc&lt;/VAR&gt; parameter must be a value previously returned by
         &lt;CODE&gt;catopen&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The next two parameters, &lt;VAR&gt;set&lt;/VAR&gt; and &lt;VAR&gt;message&lt;/VAR&gt;, reflect the
         internal organization of the message catalog files.  This will be
         explained in detail below.  For now it is interesting to know that a
         catalog can consists of several set and the messages in each thread are
         individually numbered using numbers.  Neither the set number nor the
         message number must be consecutive.  They can be arbitrarily chosen.
         But each message (unless equal to another one) must have its own unique
         pair of set and message number.
         &lt;br&gt;&lt;br&gt; Since it is not guaranteed that the message catalog for the language
         selected by the user exists the last parameter &lt;VAR&gt;string&lt;/VAR&gt; helps to
         handle this case gracefully.  If no matching string can be found
         &lt;VAR&gt;string&lt;/VAR&gt; is returned.  This means for the programmer that
         &lt;br&gt;&lt;br&gt; &lt;OL&gt;
         &lt;LI&gt;
         the &lt;VAR&gt;string&lt;/VAR&gt; parameters should contain reasonable text (this also
         helps to understand the program seems otherwise there would be no hint
         on the string which is expected to be returned.
         &lt;LI&gt;
         all &lt;VAR&gt;string&lt;/VAR&gt; arguments should be written in the same language.
         &lt;/OL&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-catclose" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="nl_catd catalog_desc"/>
      </prototype>
        <synopsis>
        The &lt;CODE&gt;catclose&lt;/CODE&gt; function can be used to free the resources
         associated with a message catalog which previously was opened by a call
         to &lt;CODE&gt;catopen&lt;/CODE&gt;.  If the resources can be successfully freed the
         function returns &lt;CODE&gt;0&lt;/CODE&gt;.  Otherwise it return &lt;CODE&gt;&lt;/CODE&gt;1 and the
         global variable &lt;VAR&gt;errno&lt;/VAR&gt; is set.  Errors can occur if the catalog
         descriptor &lt;VAR&gt;catalog_desc&lt;/VAR&gt; is not valid in which case &lt;VAR&gt;errno&lt;/VAR&gt; is
         set to &lt;CODE&gt;EBADF&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-gettext" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *msgid"/>
      </prototype>
      <headers>
        <header filename = "libintl.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;gettext&lt;/CODE&gt; function searches the currently selected message
         catalogs for a string which is equal to &lt;VAR&gt;msgid&lt;/VAR&gt;.  If there is such a
         string available it is returned.  Otherwise the argument string
         &lt;VAR&gt;msgid&lt;/VAR&gt; is returned.
         &lt;br&gt;&lt;br&gt; Please note that all though the return value is &lt;CODE&gt;char *&lt;/CODE&gt; the
         returned string must not be changed.  This broken type results from the
         history of the function and does not reflect the way the function should
         be used.
         &lt;br&gt;&lt;br&gt; Please note that above we wrote ``message catalogs'' (plural).  This is
         a specialty of the GNU implementation of these functions and we will
         say more about this when we talk about the ways message catalogs are
         selected .
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;gettext&lt;/CODE&gt; function does not modify the value of the global
         &lt;VAR&gt;errno&lt;/VAR&gt; variable.  This is necessary to make it possible to write
         something like
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
           printf (gettext ("Operation failed: %m\n"));&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; Here the &lt;VAR&gt;errno&lt;/VAR&gt; value is used in the &lt;CODE&gt;printf&lt;/CODE&gt; function while
         processing the &lt;CODE&gt;%m&lt;/CODE&gt; format element and if the &lt;CODE&gt;gettext&lt;/CODE&gt;
         function would change this value (it is called before &lt;CODE&gt;printf&lt;/CODE&gt; is
         called) we would get a wrong message.
         &lt;br&gt;&lt;br&gt; So there is no easy way to detect a missing message catalog beside
         comparing the argument string with the result.  But it is normally the
         task of the user to react on missing catalogs.  The program cannot guess
         when a message catalog is really necessary since for a user who speaks
         the language the program was developed in does not need any translation.
        </synopsis>
    </function>
  </construct>
  <construct id="function-dgettext" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *domainname"/>
        <parameter content="const char *msgid"/>
      </prototype>
      <headers>
        <header filename = "libintl.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;dgettext&lt;/CODE&gt; functions acts just like the &lt;CODE&gt;gettext&lt;/CODE&gt;
         function.  It only takes an additional first argument &lt;VAR&gt;domainname&lt;/VAR&gt;
         which guides the selection of the message catalogs which are searched
         for the translation.  If the &lt;VAR&gt;domainname&lt;/VAR&gt; parameter is the null
         pointer the &lt;CODE&gt;dgettext&lt;/CODE&gt; function is exactly equivalent to
         &lt;CODE&gt;gettext&lt;/CODE&gt; since the default value for the domain name is used.
         &lt;br&gt;&lt;br&gt; As for &lt;CODE&gt;gettext&lt;/CODE&gt; the return value type is &lt;CODE&gt;char *&lt;/CODE&gt; which is an
         anachronism.  The returned string must never be modified.
        </synopsis>
    </function>
  </construct>
  <construct id="function-dcgettext" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *domainname"/>
        <parameter content="const char *msgid"/>
        <parameter content="int category"/>
      </prototype>
      <headers>
        <header filename = "libintl.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;dcgettext&lt;/CODE&gt; adds another argument to those which
         &lt;CODE&gt;dgettext&lt;/CODE&gt; takes.  This argument &lt;VAR&gt;category&lt;/VAR&gt; specifies the last
         piece of information needed to localize the message catalog.  I.e., the
         domain name and the locale category exactly specify which message
         catalog has to be used (relative to a given directory, see below).
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;dgettext&lt;/CODE&gt; function can be expressed in terms of
         &lt;CODE&gt;dcgettext&lt;/CODE&gt; by using
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         dcgettext (domain, string, LC_MESSAGES)&lt;br&gt;
         &lt;/pre&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;br&gt;
         instead of&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         dgettext (domain, string)&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; This also shows which values are expected for the third parameter.  One
         has to use the available selectors for the categories available in
         &lt;TT&gt;locale.h&lt;/TT&gt;.  Normally the available values are &lt;CODE&gt;LC_CTYPE&lt;/CODE&gt;,
         &lt;CODE&gt;LC_COLLATE&lt;/CODE&gt;, &lt;CODE&gt;LC_MESSAGES&lt;/CODE&gt;, &lt;CODE&gt;LC_MONETARY&lt;/CODE&gt;,
         &lt;CODE&gt;LC_NUMERIC&lt;/CODE&gt;, and &lt;CODE&gt;LC_TIME&lt;/CODE&gt;.  Please note that &lt;CODE&gt;LC_ALL&lt;/CODE&gt;
         must not be used and even though the names might suggest this, there is
         no relation to the environments variables of this name.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;dcgettext&lt;/CODE&gt; function is only implemented for compatibility with
         other systems which have &lt;CODE&gt;gettext&lt;/CODE&gt; functions.  There is not really
         any situation where it is necessary (or useful) to use a different value
         but &lt;CODE&gt;LC_MESSAGES&lt;/CODE&gt; in for the &lt;VAR&gt;category&lt;/VAR&gt; parameter.  We are
         dealing with messages here and any other choice can only be irritating.
         &lt;br&gt;&lt;br&gt; As for &lt;CODE&gt;gettext&lt;/CODE&gt; the return value type is &lt;CODE&gt;char *&lt;/CODE&gt; which is an
         anachronism.  The returned string must never be modified.
        </synopsis>
    </function>
  </construct>
  <construct id="function-textdomain" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *domainname"/>
      </prototype>
      <headers>
        <header filename = "libintl.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;textdomain&lt;/CODE&gt; function sets the default domain, which is used in
         all future &lt;CODE&gt;gettext&lt;/CODE&gt; calls, to &lt;VAR&gt;domainname&lt;/VAR&gt;.  Please note that
         &lt;CODE&gt;dgettext&lt;/CODE&gt; and &lt;CODE&gt;dcgettext&lt;/CODE&gt; calls are not influenced if the
         &lt;VAR&gt;domainname&lt;/VAR&gt; parameter of these functions is not the null pointer.
         &lt;br&gt;&lt;br&gt; Before the first call to &lt;CODE&gt;textdomain&lt;/CODE&gt; the default domain is
         &lt;CODE&gt;messages&lt;/CODE&gt;.  This is the name specified in the specification of
         the &lt;CODE&gt;gettext&lt;/CODE&gt; API.  This name is as good as any other name.  No
         program should ever really use a domain with this name since this can
         only lead to problems.
         &lt;br&gt;&lt;br&gt; The function returns the value which is from now on taken as the default
         domain.  If the system went out of memory the returned value is
         &lt;CODE&gt;NULL&lt;/CODE&gt; and the global variable &lt;VAR&gt;errno&lt;/VAR&gt; is set to &lt;CODE&gt;ENOMEM&lt;/CODE&gt;.
         Despite the return value type being &lt;CODE&gt;char *&lt;/CODE&gt; the return string must
         not be changed.  It is allocated internally by the &lt;CODE&gt;textdomain&lt;/CODE&gt;
         function.
         &lt;br&gt;&lt;br&gt; If the &lt;VAR&gt;domainname&lt;/VAR&gt; parameter is the null pointer no new default
         domain is set.  Instead the currently selected default domain is
         returned.
         &lt;br&gt;&lt;br&gt; If the &lt;VAR&gt;domainname&lt;/VAR&gt; parameter is the empty string the default domain
         is reset to its initial value, the domain with the name &lt;CODE&gt;messages&lt;/CODE&gt;.
         This possibility is questionable to use since the domain &lt;CODE&gt;messages&lt;/CODE&gt;
         really never should be used.
        </synopsis>
    </function>
  </construct>
  <construct id="function-bindtextdomain" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *domainname"/>
        <parameter content="const char *dirname"/>
      </prototype>
      <headers>
        <header filename = "libintl.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;bindtextdomain&lt;/CODE&gt; function can be used to specify the directory
         which contains the message catalogs for domain &lt;VAR&gt;domainname&lt;/VAR&gt; for the
         different languages.  To be correct, this is the directory where the
         hierarchy of directories is expected.  Details are explained below.
         &lt;br&gt;&lt;br&gt; For the programmer it is important to note that the translations which
         come with the program have be placed in a directory hierarchy starting
         at, say, &lt;TT&gt;/foo/bar&lt;/TT&gt;.  Then the program should make a
         &lt;CODE&gt;bindtextdomain&lt;/CODE&gt; call to bind the domain for the current program to
         this directory.  So it is made sure the catalogs are found.  A correctly
         running program does not depend on the user setting an environment
         variable.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;bindtextdomain&lt;/CODE&gt; function can be used several times and if the
         &lt;VAR&gt;domainname&lt;/VAR&gt; argument is different the previously bound domains
         will not be overwritten.
         &lt;br&gt;&lt;br&gt; If the program which wish to use &lt;CODE&gt;bindtextdomain&lt;/CODE&gt; at some point of
         time use the &lt;CODE&gt;chdir&lt;/CODE&gt; function to change the current working
         directory it is important that the &lt;VAR&gt;dirname&lt;/VAR&gt; strings ought to be an
         absolute pathname.  Otherwise the addressed directory might vary with
         the time.
         &lt;br&gt;&lt;br&gt; If the &lt;VAR&gt;dirname&lt;/VAR&gt; parameter is the null pointer &lt;CODE&gt;bindtextdomain&lt;/CODE&gt;
         returns the currently selected directory for the domain with the name
         &lt;VAR&gt;domainname&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;bindtextdomain&lt;/CODE&gt; function returns a pointer to a string
         containing the name of the selected directory name.  The string is
         allocated internally in the function and must not be changed by the
         user.  If the system went out of core during the execution of
         &lt;CODE&gt;bindtextdomain&lt;/CODE&gt; the return value is &lt;CODE&gt;NULL&lt;/CODE&gt; and the global
         variable &lt;VAR&gt;errno&lt;/VAR&gt; is set accordingly.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ngettext" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *msgid1"/>
        <parameter content="const char *msgid2"/>
        <parameter content="unsigned long int n"/>
      </prototype>
      <headers>
        <header filename = "libintl.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;ngettext&lt;/CODE&gt; function is similar to the &lt;CODE&gt;gettext&lt;/CODE&gt; function
         as it finds the message catalogs in the same way.  But it takes two
         extra arguments.  The &lt;VAR&gt;msgid1&lt;/VAR&gt; parameter must contain the singular
         form of the string to be converted.  It is also used as the key for the
         search in the catalog.  The &lt;VAR&gt;msgid2&lt;/VAR&gt; parameter is the plural form.
         The parameter &lt;VAR&gt;n&lt;/VAR&gt; is used to determine the plural form.  If no
         message catalog is found &lt;VAR&gt;msgid1&lt;/VAR&gt; is returned if &lt;CODE&gt;n == 1&lt;/CODE&gt;,
         otherwise &lt;CODE&gt;msgid2&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; An example for the us of this function is:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
           printf (ngettext ("%d file removed", "%d files removed", n), n);&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; Please note that the numeric value &lt;VAR&gt;n&lt;/VAR&gt; has to be passed to the
         &lt;CODE&gt;printf&lt;/CODE&gt; function as well.  It is not sufficient to pass it only to
         &lt;CODE&gt;ngettext&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-dngettext" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *domain"/>
        <parameter content="const char *msgid1"/>
        <parameter content="const char *msgid2"/>
        <parameter content="unsigned long int n"/>
      </prototype>
      <headers>
        <header filename = "libintl.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;dngettext&lt;/CODE&gt; is similar to the &lt;CODE&gt;dgettext&lt;/CODE&gt; function in the
         way the message catalog is selected.  The difference is that it takes
         two extra parameter to provide the correct plural form.  These two
         parameters are handled in the same way &lt;CODE&gt;ngettext&lt;/CODE&gt; handles them.
        </synopsis>
    </function>
  </construct>
  <construct id="function-dcngettext" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *domain"/>
        <parameter content="const char *msgid1"/>
        <parameter content="const char *msgid2"/>
        <parameter content="unsigned long int n"/>
        <parameter content="int category"/>
      </prototype>
      <headers>
        <header filename = "libintl.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;dcngettext&lt;/CODE&gt; is similar to the &lt;CODE&gt;dcgettext&lt;/CODE&gt; function in the
         way the message catalog is selected.  The difference is that it takes
         two extra parameter to provide the correct plural form.  These two
         parameters are handled in the same way &lt;CODE&gt;ngettext&lt;/CODE&gt; handles them.
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-jmp_buf" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="function-longjmp" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="jmp_buf state"/>
        <parameter content="int value"/>
      </prototype>
      <headers>
        <header filename = "setjmp.h"/>
      </headers>
        <synopsis>
        This function restores current execution to the state saved in
         &lt;VAR&gt;state&lt;/VAR&gt;, and continues execution from the call to &lt;CODE&gt;setjmp&lt;/CODE&gt; that
         established that return point.  Returning from &lt;CODE&gt;setjmp&lt;/CODE&gt; by means of
         &lt;CODE&gt;longjmp&lt;/CODE&gt; returns the &lt;VAR&gt;value&lt;/VAR&gt; argument that was passed to
         &lt;CODE&gt;longjmp&lt;/CODE&gt;, rather than &lt;CODE&gt;0&lt;/CODE&gt;.  (But if &lt;VAR&gt;value&lt;/VAR&gt; is given as
         &lt;CODE&gt;0&lt;/CODE&gt;, &lt;CODE&gt;setjmp&lt;/CODE&gt; returns &lt;CODE&gt;1&lt;/CODE&gt;).
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-sigjmp_buf" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="function-sigsetjmp" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="sigjmp_buf state"/>
        <parameter content="int savesigs"/>
      </prototype>
      <headers>
        <header filename = "setjmp.h"/>
      </headers>
        <synopsis>
        This is similar to &lt;CODE&gt;setjmp&lt;/CODE&gt;.  If &lt;VAR&gt;savesigs&lt;/VAR&gt; is nonzero, the set
         of blocked signals is saved in &lt;VAR&gt;state&lt;/VAR&gt; and will be restored if a
         &lt;CODE&gt;siglongjmp&lt;/CODE&gt; is later performed with this &lt;VAR&gt;state&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-siglongjmp" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="sigjmp_buf state"/>
        <parameter content="int value"/>
      </prototype>
      <headers>
        <header filename = "setjmp.h"/>
      </headers>
        <synopsis>
        This is similar to &lt;CODE&gt;longjmp&lt;/CODE&gt; except for the type of its &lt;VAR&gt;state&lt;/VAR&gt;
         argument.  If the &lt;CODE&gt;sigsetjmp&lt;/CODE&gt; call that set this &lt;VAR&gt;state&lt;/VAR&gt; used a
         nonzero &lt;VAR&gt;savesigs&lt;/VAR&gt; flag, &lt;CODE&gt;siglongjmp&lt;/CODE&gt; also restores the set of
         blocked signals.
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-ucontext_t" type="dtype">
    <structure>
        <synopsis>
        &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;ucontext_t&lt;/CODE&gt; type is defined as a structure with as least the
         following elements:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="ucontext_t *uc_link">
            <synopsis>
            This is a pointer to the next context structure which is used if the
             context described in the current structure returns.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="sigset_t uc_sigmask">
            <synopsis>
            Set of signals which are blocked when this context is used.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="stack_t uc_stack">
            <synopsis>
            Stack used for this context.  The value need not be (and normally is
             not) the stack pointer.  .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-getcontext" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="ucontext_t *ucp"/>
      </prototype>
      <headers>
        <header filename = "ucontext.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getcontext&lt;/CODE&gt; function initializes the variable pointed to by
         &lt;VAR&gt;ucp&lt;/VAR&gt; with the context of the calling thread.  The context contains
         the content of the registers, the signal mask, and the current stack.
         Executing the contents would start at the point where the
         &lt;CODE&gt;getcontext&lt;/CODE&gt; call just returned.
         &lt;br&gt;&lt;br&gt; The function returns &lt;CODE&gt;0&lt;/CODE&gt; if successful.  Otherwise it returns
         &lt;CODE&gt;-1&lt;/CODE&gt; and sets &lt;VAR&gt;errno&lt;/VAR&gt; accordingly.
        </synopsis>
    </function>
  </construct>
  <construct id="function-makecontext" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="ucontext_t *ucp"/>
        <parameter content="void (*func) (void)"/>
        <parameter content="int argc"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "ucontext.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;ucp&lt;/VAR&gt; parameter passed to the &lt;CODE&gt;makecontext&lt;/CODE&gt; shall be
         initialized by a call to &lt;CODE&gt;getcontext&lt;/CODE&gt;.  The context will be
         modified to in a way so that if the context is resumed it will start by
         calling the function &lt;CODE&gt;func&lt;/CODE&gt; which gets &lt;VAR&gt;argc&lt;/VAR&gt; integer arguments
         passed.  The integer arguments which are to be passed should follow the
         &lt;VAR&gt;argc&lt;/VAR&gt; parameter in the call to &lt;CODE&gt;makecontext&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; Before the call to this function the &lt;CODE&gt;uc_stack&lt;/CODE&gt; and &lt;CODE&gt;uc_link&lt;/CODE&gt;
         element of the &lt;VAR&gt;ucp&lt;/VAR&gt; structure should be initialized.  The
         &lt;CODE&gt;uc_stack&lt;/CODE&gt; element describes the stack which is used for this
         context.  No two contexts which are used at the same time should use the
         same memory region for a stack.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;uc_link&lt;/CODE&gt; element of the object pointed to by &lt;VAR&gt;ucp&lt;/VAR&gt; should
         be a pointer to the context to be executed when the function &lt;VAR&gt;func&lt;/VAR&gt;
         returns or it should be a null pointer.  See &lt;CODE&gt;setcontext&lt;/CODE&gt; for more
         information about the exact use.
        </synopsis>
    </function>
  </construct>
  <construct id="function-setcontext" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const ucontext_t *ucp"/>
      </prototype>
      <headers>
        <header filename = "ucontext.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;setcontext&lt;/CODE&gt; function restores the context described by
         &lt;VAR&gt;ucp&lt;/VAR&gt;.  The context is not modified and can be reused as often as
         wanted.
         &lt;br&gt;&lt;br&gt; If the context was created by &lt;CODE&gt;getcontext&lt;/CODE&gt; execution resumes with
         the registers filled with the same values and the same stack as if the
         &lt;CODE&gt;getcontext&lt;/CODE&gt; call just returned.
         &lt;br&gt;&lt;br&gt; If the context was modified with a call to &lt;CODE&gt;makecontext&lt;/CODE&gt; execution
         continues with the function passed to &lt;CODE&gt;makecontext&lt;/CODE&gt; which gets the
         specified parameters passed.  If this function returns execution is
         resumed in the context which was referenced by the &lt;CODE&gt;uc_link&lt;/CODE&gt;
         element of the context structure passed to &lt;CODE&gt;makecontext&lt;/CODE&gt; at the
         time of the call.  If &lt;CODE&gt;uc_link&lt;/CODE&gt; was a null pointer the application
         terminates in this case.
         &lt;br&gt;&lt;br&gt; Since the context contains information about the stack no two threads
         should use the same context at the same time.  The result in most cases
         would be disastrous.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;setcontext&lt;/CODE&gt; function does not return unless an error occurred
         in which case it returns &lt;CODE&gt;-1&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-swapcontext" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="ucontext_t *restrict oucp"/>
        <parameter content="const ucontext_t *restrict ucp"/>
      </prototype>
      <headers>
        <header filename = "ucontext.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;swapcontext&lt;/CODE&gt; function is similar to &lt;CODE&gt;setcontext&lt;/CODE&gt; but
         instead of just replacing the current context the latter is first saved
         in the object pointed to by &lt;VAR&gt;oucp&lt;/VAR&gt; as if this was a call to
         &lt;CODE&gt;getcontext&lt;/CODE&gt;.  The saved context would resume after the call to
         &lt;CODE&gt;swapcontext&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; Once the current context is saved the context described in &lt;VAR&gt;ucp&lt;/VAR&gt; is
         installed and execution continues as described in this context.
         &lt;br&gt;&lt;br&gt; If &lt;CODE&gt;swapcontext&lt;/CODE&gt; succeeds the function does not return unless the
         context &lt;VAR&gt;oucp&lt;/VAR&gt; is used without prior modification by
         &lt;CODE&gt;makecontext&lt;/CODE&gt;.  The return value in this case is &lt;CODE&gt;0&lt;/CODE&gt;.  If the
         function fails it returns &lt;CODE&gt;-1&lt;/CODE&gt; and set &lt;VAR&gt;errno&lt;/VAR&gt; accordingly.
        </synopsis>
    </function>
  </construct>
  <construct id="function-open" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="int flags["/>
        <parameter content="mode_t mode]"/>
      </prototype>
      <headers>
        <header filename = "fcntl.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;open&lt;/CODE&gt; function creates and returns a new file descriptor
         for the file named by &lt;VAR&gt;filename&lt;/VAR&gt;.  Initially, the file position
         indicator for the file is at the beginning of the file.  The argument
         &lt;VAR&gt;mode&lt;/VAR&gt; is used only when a file is created, but it doesn't hurt
         to supply the argument in any case.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;flags&lt;/VAR&gt; argument controls how the file is to be opened.  This is
         a bit mask; you create the value by the bitwise OR of the appropriate
         parameters (using the &lt;samp&gt;|&lt;/samp&gt; operator in C).
         , for the parameters available.
         &lt;br&gt;&lt;br&gt; The normal return value from &lt;CODE&gt;open&lt;/CODE&gt; is a non-negative integer file
         descriptor.  In the case of an error, a value of -1 is returned
         instead.  In addition to the usual file name errors , the following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined
         for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EACCES&lt;/CODE&gt;
&lt;DD&gt;
         The file exists but is not readable/writable as requested by the &lt;VAR&gt;flags&lt;/VAR&gt;
         argument, the file does not exist and the directory is unwritable so
         it cannot be created.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EEXIST
         Both &lt;CODE&gt;O_CREAT&lt;/CODE&gt; and &lt;CODE&gt;O_EXCL&lt;/CODE&gt; are set, and the named file already
         exists.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINTR
         The &lt;CODE&gt;open&lt;/CODE&gt; operation was interrupted by a signal.
         .
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EISDIR
         The &lt;VAR&gt;flags&lt;/VAR&gt; argument specified write access, and the file is a directory.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EMFILE
         The process has too many files open.
         The maximum number of file descriptors is controlled by the
         &lt;CODE&gt;RLIMIT_NOFILE&lt;/CODE&gt; resource limit; .
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENFILE
         The entire system, or perhaps the file system which contains the
         directory, cannot support any additional open files at the moment.
         (This problem cannot happen on the GNU system.)
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOENT
         The named file does not exist, and &lt;CODE&gt;O_CREAT&lt;/CODE&gt; is not specified.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOSPC
         The directory or file system that would contain the new file cannot be
         extended, because there is no disk space left.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENXIO
         &lt;CODE&gt;O_NONBLOCK&lt;/CODE&gt; and &lt;CODE&gt;O_WRONLY&lt;/CODE&gt; are both set in the &lt;VAR&gt;flags&lt;/VAR&gt;
         argument, the file named by &lt;VAR&gt;filename&lt;/VAR&gt; is a FIFO , and no process has the file open for reading.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EROFS
         The file resides on a read-only file system and any of &lt;CODE&gt;O_WRONLY&lt;/CODE&gt;,
         &lt;CODE&gt;O_RDWR&lt;/CODE&gt;, and &lt;CODE&gt;O_TRUNC&lt;/CODE&gt; are set in the &lt;VAR&gt;flags&lt;/VAR&gt; argument,
         or &lt;CODE&gt;O_CREAT&lt;/CODE&gt; is set and the file does not already exist.

         &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt; If on a 32 bit machine the sources are translated with
         &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; the function &lt;CODE&gt;open&lt;/CODE&gt; returns a file
         descriptor opened in the large file mode which enables the file handling
         functions to use files up to 2^63 bytes in size and offset from
         -2^63 to 2^63.  This happens transparently for the user
         since all of the lowlevel file handling functions are equally replaced.
         &lt;br&gt;&lt;br&gt; This function is a cancellation point in multi-threaded programs.  This
         is a problem if the thread allocates some resources (like memory, file
         descriptors, semaphores or whatever) at the time &lt;CODE&gt;open&lt;/CODE&gt; is
         called.  If the thread gets canceled these resources stay allocated
         until the program ends.  To avoid this calls to &lt;CODE&gt;open&lt;/CODE&gt; should be
         protected using cancellation handlers.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;open&lt;/CODE&gt; function is the underlying primitive for the &lt;CODE&gt;fopen&lt;/CODE&gt;
         and &lt;CODE&gt;freopen&lt;/CODE&gt; functions, that create streams.
        </synopsis>
    </function>
  </construct>
  <construct id="function-open64" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="int flags["/>
        <parameter content="mode_t mode]"/>
      </prototype>
      <headers>
        <header filename = "fcntl.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;open&lt;/CODE&gt;.  It returns a file descriptor
         which can be used to access the file named by &lt;VAR&gt;filename&lt;/VAR&gt;.  The only
         difference is that on 32 bit systems the file is opened in the
         large file mode.  I.e., file length and file offsets can exceed 31 bits.
         &lt;br&gt;&lt;br&gt; When the sources are translated with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; this
         function is actually available under the name &lt;CODE&gt;open&lt;/CODE&gt;.  I.e., the
         new, extended API using 64 bit file sizes and offsets transparently
         replaces the old API.
        </synopsis>
    </function>
  </construct>
  <construct id="function-close" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int filedes"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The function &lt;CODE&gt;close&lt;/CODE&gt; closes the file descriptor &lt;VAR&gt;filedes&lt;/VAR&gt;.
         Closing a file has the following consequences:
         &lt;br&gt;&lt;br&gt; &lt;OL&gt;
         &lt;LI&gt;
         The file descriptor is deallocated.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         Any record locks owned by the process on the file are unlocked.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         When all file descriptors associated with a pipe or FIFO have been closed,
         any unread data is discarded.
         &lt;/OL&gt;
         &lt;br&gt;&lt;br&gt; This function is a cancellation point in multi-threaded programs.  This
         is a problem if the thread allocates some resources (like memory, file
         descriptors, semaphores or whatever) at the time &lt;CODE&gt;close&lt;/CODE&gt; is
         called.  If the thread gets canceled these resources stay allocated
         until the program ends.  To avoid this, calls to &lt;CODE&gt;close&lt;/CODE&gt; should be
         protected using cancellation handlers.
         &lt;br&gt;&lt;br&gt; The normal return value from &lt;CODE&gt;close&lt;/CODE&gt; is 0; a value of -1
         is returned in case of failure.  The following &lt;CODE&gt;errno&lt;/CODE&gt; error
         conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;filedes&lt;/VAR&gt; argument is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINTR
         The &lt;CODE&gt;close&lt;/CODE&gt; call was interrupted by a signal.
         .
         Here is an example of how to handle &lt;CODE&gt;EINTR&lt;/CODE&gt; properly:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         TEMP_FAILURE_RETRY (close (desc));&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOSPC
         &lt;LI&gt;x EIO
         &lt;LI&gt;x EDQUOT
         When the file is accessed by NFS, these errors from &lt;CODE&gt;write&lt;/CODE&gt; can sometimes
         not be detected until &lt;CODE&gt;close&lt;/CODE&gt;.  , for details
         on their meaning.

         &lt;br&gt;&lt;br&gt; Please note that there is &lt;EM&gt;no&lt;/EM&gt; separate &lt;CODE&gt;close64&lt;/CODE&gt; function.
         This is not necessary since this function does not determine nor depend
         on the mode of the file.  The kernel which performs the &lt;CODE&gt;close&lt;/CODE&gt;
         operation knows which mode the descriptor is used for and can handle
         this situation.
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-ssize_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="function-read" type="function">
    <function returntype="ssize_t">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="void *buffer"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;read&lt;/CODE&gt; function reads up to &lt;VAR&gt;size&lt;/VAR&gt; bytes from the file
         with descriptor &lt;VAR&gt;filedes&lt;/VAR&gt;, storing the results in the &lt;VAR&gt;buffer&lt;/VAR&gt;.
         (This is not necessarily a character string, and no terminating null
         character is added.)
         &lt;br&gt;&lt;br&gt; -of-file, on a file descriptor
         The return value is the number of bytes actually read.  This might be
         less than &lt;VAR&gt;size&lt;/VAR&gt;; for example, if there aren't that many bytes left
         in the file or if there aren't that many bytes immediately available.
         The exact behavior depends on what kind of file it is.  Note that
         reading less than &lt;VAR&gt;size&lt;/VAR&gt; bytes is not an error.
         &lt;br&gt;&lt;br&gt; A value of zero indicates end-of-file (except if the value of the
         &lt;VAR&gt;size&lt;/VAR&gt; argument is also zero).  This is not considered an error.
         If you keep calling &lt;CODE&gt;read&lt;/CODE&gt; while at end-of-file, it will keep
         returning zero and doing nothing else.
         &lt;br&gt;&lt;br&gt; If &lt;CODE&gt;read&lt;/CODE&gt; returns at least one character, there is no way you can
         tell whether end-of-file was reached.  But if you did reach the end, the
         next read will return zero.
         &lt;br&gt;&lt;br&gt; In case of an error, &lt;CODE&gt;read&lt;/CODE&gt; returns -1.  The following
         &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EAGAIN&lt;/CODE&gt;
&lt;DD&gt;
         Normally, when no input is immediately available, &lt;CODE&gt;read&lt;/CODE&gt; waits for
         some input.  But if the &lt;CODE&gt;O_NONBLOCK&lt;/CODE&gt; flag is set for the file
         , &lt;CODE&gt;read&lt;/CODE&gt; returns immediately without
         reading any data, and reports this error.
         &lt;br&gt;&lt;br&gt; Compatibility Note: Most versions of BSD Unix use a different
         error code for this: &lt;CODE&gt;EWOULDBLOCK&lt;/CODE&gt;.  In the GNU library,
         &lt;CODE&gt;EWOULDBLOCK&lt;/CODE&gt; is an alias for &lt;CODE&gt;EAGAIN&lt;/CODE&gt;, so it doesn't matter
         which name you use.
         &lt;br&gt;&lt;br&gt; On some systems, reading a large amount of data from a character special
         file can also fail with &lt;CODE&gt;EAGAIN&lt;/CODE&gt; if the kernel cannot find enough
         physical memory to lock down the user's pages.  This is limited to
         devices that transfer with direct memory access into the user's memory,
         which means it does not include terminals, since they always use
         separate buffers inside the kernel.  This problem never happens in the
         GNU system.
         &lt;br&gt;&lt;br&gt; Any condition that could result in &lt;CODE&gt;EAGAIN&lt;/CODE&gt; can instead result in a
         successful &lt;CODE&gt;read&lt;/CODE&gt; which returns fewer bytes than requested.
         Calling &lt;CODE&gt;read&lt;/CODE&gt; again immediately would result in &lt;CODE&gt;EAGAIN&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EBADF
         The &lt;VAR&gt;filedes&lt;/VAR&gt; argument is not a valid file descriptor,
         or is not open for reading.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINTR
         &lt;CODE&gt;read&lt;/CODE&gt; was interrupted by a signal while it was waiting for input.
         .  A signal will not necessary cause
         &lt;CODE&gt;read&lt;/CODE&gt; to return &lt;CODE&gt;EINTR&lt;/CODE&gt;; it may instead result in a
         successful &lt;CODE&gt;read&lt;/CODE&gt; which returns fewer bytes than requested.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EIO
         For many devices, and for disk files, this error code indicates
         a hardware error.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;EIO&lt;/CODE&gt; also occurs when a background process tries to read from the
         controlling terminal, and the normal action of stopping the process by
         sending it a &lt;CODE&gt;SIGTTIN&lt;/CODE&gt; signal isn't working.  This might happen if
         the signal is being blocked or ignored, or because the process group is
         orphaned.  , for more information about job control,
         and Signal Handling, for information about signals.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         In some systems, when reading from a character or block device, position
         and size offsets must be aligned to a particular block size.  This error
         indicates that the offsets were not properly aligned.

         &lt;br&gt;&lt;br&gt; Please note that there is no function named &lt;CODE&gt;read64&lt;/CODE&gt;.  This is not
         necessary since this function does not directly modify or handle the
         possibly wide file offset.  Since the kernel handles this state
         internally, the &lt;CODE&gt;read&lt;/CODE&gt; function can be used for all cases.
         &lt;br&gt;&lt;br&gt; This function is a cancellation point in multi-threaded programs.  This
         is a problem if the thread allocates some resources (like memory, file
         descriptors, semaphores or whatever) at the time &lt;CODE&gt;read&lt;/CODE&gt; is
         called.  If the thread gets canceled these resources stay allocated
         until the program ends.  To avoid this, calls to &lt;CODE&gt;read&lt;/CODE&gt; should be
         protected using cancellation handlers.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;read&lt;/CODE&gt; function is the underlying primitive for all of the
         functions that read from streams, such as &lt;CODE&gt;fgetc&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-pread" type="function">
    <function returntype="ssize_t">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="void *buffer"/>
        <parameter content="size_t size"/>
        <parameter content="off_t offset"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;pread&lt;/CODE&gt; function is similar to the &lt;CODE&gt;read&lt;/CODE&gt; function.  The
         first three arguments are identical, and the return values and error
         codes also correspond.
         &lt;br&gt;&lt;br&gt; The difference is the fourth argument and its handling.  The data block
         is not read from the current position of the file descriptor
         &lt;CODE&gt;filedes&lt;/CODE&gt;.  Instead the data is read from the file starting at
         position &lt;VAR&gt;offset&lt;/VAR&gt;.  The position of the file descriptor itself is
         not affected by the operation.  The value is the same as before the call.
         &lt;br&gt;&lt;br&gt; When the source file is compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; the
         &lt;CODE&gt;pread&lt;/CODE&gt; function is in fact &lt;CODE&gt;pread64&lt;/CODE&gt; and the type
         &lt;CODE&gt;off_t&lt;/CODE&gt; has 64 bits, which makes it possible to handle files up to
         2^63 bytes in length.
         &lt;br&gt;&lt;br&gt; The return value of &lt;CODE&gt;pread&lt;/CODE&gt; describes the number of bytes read.
         In the error case it returns -1 like &lt;CODE&gt;read&lt;/CODE&gt; does and the
         error codes are also the same, with these additions:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EINVAL&lt;/CODE&gt;
&lt;DD&gt;
         The value given for &lt;VAR&gt;offset&lt;/VAR&gt; is negative and therefore illegal.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ESPIPE
         The file descriptor &lt;VAR&gt;filedes&lt;/VAR&gt; is associate with a pipe or a FIFO and
         this device does not allow positioning of the file pointer.

         &lt;br&gt;&lt;br&gt; The function is an extension defined in the Unix Single Specification
         version 2.
        </synopsis>
    </function>
  </construct>
  <construct id="function-pread64" type="function">
    <function returntype="ssize_t">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="void *buffer"/>
        <parameter content="size_t size"/>
        <parameter content="off64_t offset"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        This function is similar to the &lt;CODE&gt;pread&lt;/CODE&gt; function.  The difference
         is that the &lt;VAR&gt;offset&lt;/VAR&gt; parameter is of type &lt;CODE&gt;off64_t&lt;/CODE&gt; instead of
         &lt;CODE&gt;off_t&lt;/CODE&gt; which makes it possible on 32 bit machines to address
         files larger than 2^31 bytes and up to 2^63 bytes.  The
         file descriptor &lt;CODE&gt;filedes&lt;/CODE&gt; must be opened using &lt;CODE&gt;open64&lt;/CODE&gt; since
         otherwise the large offsets possible with &lt;CODE&gt;off64_t&lt;/CODE&gt; will lead to
         errors with a descriptor in small file mode.
         &lt;br&gt;&lt;br&gt; When the source file is compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; on a
         32 bit machine this function is actually available under the name
         &lt;CODE&gt;pread&lt;/CODE&gt; and so transparently replaces the 32 bit interface.
        </synopsis>
    </function>
  </construct>
  <construct id="function-write" type="function">
    <function returntype="ssize_t">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="const void *buffer"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;write&lt;/CODE&gt; function writes up to &lt;VAR&gt;size&lt;/VAR&gt; bytes from
         &lt;VAR&gt;buffer&lt;/VAR&gt; to the file with descriptor &lt;VAR&gt;filedes&lt;/VAR&gt;.  The data in
         &lt;VAR&gt;buffer&lt;/VAR&gt; is not necessarily a character string and a null character is
         output like any other character.
         &lt;br&gt;&lt;br&gt; The return value is the number of bytes actually written.  This may be
         &lt;VAR&gt;size&lt;/VAR&gt;, but can always be smaller.  Your program should always call
         &lt;CODE&gt;write&lt;/CODE&gt; in a loop, iterating until all the data is written.
         &lt;br&gt;&lt;br&gt; Once &lt;CODE&gt;write&lt;/CODE&gt; returns, the data is enqueued to be written and can be
         read back right away, but it is not necessarily written out to permanent
         storage immediately.  You can use &lt;CODE&gt;fsync&lt;/CODE&gt; when you need to be sure
         your data has been permanently stored before continuing.  (It is more
         efficient for the system to batch up consecutive writes and do them all
         at once when convenient.  Normally they will always be written to disk
         within a minute or less.)  Modern systems provide another function
         &lt;CODE&gt;fdatasync&lt;/CODE&gt; which guarantees integrity only for the file data and
         is therefore faster.
         You can use the &lt;CODE&gt;O_FSYNC&lt;/CODE&gt; open mode to make &lt;CODE&gt;write&lt;/CODE&gt; always
         store the data to disk before returning; .
         &lt;br&gt;&lt;br&gt; In the case of an error, &lt;CODE&gt;write&lt;/CODE&gt; returns -1.  The following
         &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EAGAIN&lt;/CODE&gt;
&lt;DD&gt;
         Normally, &lt;CODE&gt;write&lt;/CODE&gt; blocks until the write operation is complete.
         But if the &lt;CODE&gt;O_NONBLOCK&lt;/CODE&gt; flag is set for the file , it returns immediately without writing any data and
         reports this error.  An example of a situation that might cause the
         process to block on output is writing to a terminal device that supports
         flow control, where output has been suspended by receipt of a STOP
         character.
         &lt;br&gt;&lt;br&gt; Compatibility Note: Most versions of BSD Unix use a different
         error code for this: &lt;CODE&gt;EWOULDBLOCK&lt;/CODE&gt;.  In the GNU library,
         &lt;CODE&gt;EWOULDBLOCK&lt;/CODE&gt; is an alias for &lt;CODE&gt;EAGAIN&lt;/CODE&gt;, so it doesn't matter
         which name you use.
         &lt;br&gt;&lt;br&gt; On some systems, writing a large amount of data from a character special
         file can also fail with &lt;CODE&gt;EAGAIN&lt;/CODE&gt; if the kernel cannot find enough
         physical memory to lock down the user's pages.  This is limited to
         devices that transfer with direct memory access into the user's memory,
         which means it does not include terminals, since they always use
         separate buffers inside the kernel.  This problem does not arise in the
         GNU system.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EBADF
         The &lt;VAR&gt;filedes&lt;/VAR&gt; argument is not a valid file descriptor,
         or is not open for writing.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EFBIG
         The size of the file would become larger than the implementation can support.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINTR
         The &lt;CODE&gt;write&lt;/CODE&gt; operation was interrupted by a signal while it was
         blocked waiting for completion.  A signal will not necessarily cause
         &lt;CODE&gt;write&lt;/CODE&gt; to return &lt;CODE&gt;EINTR&lt;/CODE&gt;; it may instead result in a
         successful &lt;CODE&gt;write&lt;/CODE&gt; which writes fewer bytes than requested.
         .
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EIO
         For many devices, and for disk files, this error code indicates
         a hardware error.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOSPC
         The device containing the file is full.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EPIPE
         This error is returned when you try to write to a pipe or FIFO that
         isn't open for reading by any process.  When this happens, a &lt;CODE&gt;SIGPIPE&lt;/CODE&gt;
         signal is also sent to the process; see Signal Handling.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         In some systems, when writing to a character or block device, position
         and size offsets must be aligned to a particular block size.  This error
         indicates that the offsets were not properly aligned.

         &lt;br&gt;&lt;br&gt; Unless you have arranged to prevent &lt;CODE&gt;EINTR&lt;/CODE&gt; failures, you should
         check &lt;CODE&gt;errno&lt;/CODE&gt; after each failing call to &lt;CODE&gt;write&lt;/CODE&gt;, and if the
         error was &lt;CODE&gt;EINTR&lt;/CODE&gt;, you should simply repeat the call.
         .  The easy way to do this is with the
         macro &lt;CODE&gt;TEMP_FAILURE_RETRY&lt;/CODE&gt;, as follows:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         nbytes = TEMP_FAILURE_RETRY (write (desc, buffer, count));&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; Please note that there is no function named &lt;CODE&gt;write64&lt;/CODE&gt;.  This is not
         necessary since this function does not directly modify or handle the
         possibly wide file offset.  Since the kernel handles this state
         internally the &lt;CODE&gt;write&lt;/CODE&gt; function can be used for all cases.
         &lt;br&gt;&lt;br&gt; This function is a cancellation point in multi-threaded programs.  This
         is a problem if the thread allocates some resources (like memory, file
         descriptors, semaphores or whatever) at the time &lt;CODE&gt;write&lt;/CODE&gt; is
         called.  If the thread gets canceled these resources stay allocated
         until the program ends.  To avoid this, calls to &lt;CODE&gt;write&lt;/CODE&gt; should be
         protected using cancellation handlers.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;write&lt;/CODE&gt; function is the underlying primitive for all of the
         functions that write to streams, such as &lt;CODE&gt;fputc&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-pwrite" type="function">
    <function returntype="ssize_t">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="const void *buffer"/>
        <parameter content="size_t size"/>
        <parameter content="off_t offset"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;pwrite&lt;/CODE&gt; function is similar to the &lt;CODE&gt;write&lt;/CODE&gt; function.  The
         first three arguments are identical, and the return values and error codes
         also correspond.
         &lt;br&gt;&lt;br&gt; The difference is the fourth argument and its handling.  The data block
         is not written to the current position of the file descriptor
         &lt;CODE&gt;filedes&lt;/CODE&gt;.  Instead the data is written to the file starting at
         position &lt;VAR&gt;offset&lt;/VAR&gt;.  The position of the file descriptor itself is
         not affected by the operation.  The value is the same as before the call.
         &lt;br&gt;&lt;br&gt; When the source file is compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; the
         &lt;CODE&gt;pwrite&lt;/CODE&gt; function is in fact &lt;CODE&gt;pwrite64&lt;/CODE&gt; and the type
         &lt;CODE&gt;off_t&lt;/CODE&gt; has 64 bits, which makes it possible to handle files up to
         2^63 bytes in length.
         &lt;br&gt;&lt;br&gt; The return value of &lt;CODE&gt;pwrite&lt;/CODE&gt; describes the number of written bytes.
         In the error case it returns -1 like &lt;CODE&gt;write&lt;/CODE&gt; does and the
         error codes are also the same, with these additions:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EINVAL&lt;/CODE&gt;
&lt;DD&gt;
         The value given for &lt;VAR&gt;offset&lt;/VAR&gt; is negative and therefore illegal.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ESPIPE
         The file descriptor &lt;VAR&gt;filedes&lt;/VAR&gt; is associated with a pipe or a FIFO and
         this device does not allow positioning of the file pointer.

         &lt;br&gt;&lt;br&gt; The function is an extension defined in the Unix Single Specification
         version 2.
        </synopsis>
    </function>
  </construct>
  <construct id="function-pwrite64" type="function">
    <function returntype="ssize_t">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="const void *buffer"/>
        <parameter content="size_t size"/>
        <parameter content="off64_t offset"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        This function is similar to the &lt;CODE&gt;pwrite&lt;/CODE&gt; function.  The difference
         is that the &lt;VAR&gt;offset&lt;/VAR&gt; parameter is of type &lt;CODE&gt;off64_t&lt;/CODE&gt; instead of
         &lt;CODE&gt;off_t&lt;/CODE&gt; which makes it possible on 32 bit machines to address
         files larger than 2^31 bytes and up to 2^63 bytes.  The
         file descriptor &lt;CODE&gt;filedes&lt;/CODE&gt; must be opened using &lt;CODE&gt;open64&lt;/CODE&gt; since
         otherwise the large offsets possible with &lt;CODE&gt;off64_t&lt;/CODE&gt; will lead to
         errors with a descriptor in small file mode.
         &lt;br&gt;&lt;br&gt; When the source file is compiled using &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; on a
         32 bit machine this function is actually available under the name
         &lt;CODE&gt;pwrite&lt;/CODE&gt; and so transparently replaces the 32 bit interface.
        </synopsis>
    </function>
  </construct>
  <construct id="function-lseek" type="function">
    <function returntype="off_t">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="off_t offset"/>
        <parameter content="int whence"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;lseek&lt;/CODE&gt; function is used to change the file position of the
         file with descriptor &lt;VAR&gt;filedes&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;whence&lt;/VAR&gt; argument specifies how the &lt;VAR&gt;offset&lt;/VAR&gt; should be
         interpreted, in the same way as for the &lt;CODE&gt;fseek&lt;/CODE&gt; function, and it must
         be one of the symbolic constants &lt;CODE&gt;SEEK_SET&lt;/CODE&gt;, &lt;CODE&gt;SEEK_CUR&lt;/CODE&gt;, or
         &lt;CODE&gt;SEEK_END&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;SEEK_SET&lt;/CODE&gt;
&lt;DD&gt;
         Specifies that &lt;VAR&gt;whence&lt;/VAR&gt; is a count of characters from the beginning
         of the file.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;SEEK_CUR&lt;/CODE&gt;
&lt;DD&gt;
         Specifies that &lt;VAR&gt;whence&lt;/VAR&gt; is a count of characters from the current
         file position.  This count may be positive or negative.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; SEEK_END
         Specifies that &lt;VAR&gt;whence&lt;/VAR&gt; is a count of characters from the end of
         the file.  A negative count specifies a position within the current
         extent of the file; a positive count specifies a position past the
         current end.  If you set the position past the current end, and
         actually write data, you will extend the file with zeros up to that
         position.

         &lt;br&gt;&lt;br&gt; The return value from &lt;CODE&gt;lseek&lt;/CODE&gt; is normally the resulting file
         position, measured in bytes from the beginning of the file.
         You can use this feature together with &lt;CODE&gt;SEEK_CUR&lt;/CODE&gt; to read the
         current file position.
         &lt;br&gt;&lt;br&gt; If you want to append to the file, setting the file position to the
         current end of file with &lt;CODE&gt;SEEK_END&lt;/CODE&gt; is not sufficient.  Another
         process may write more data after you seek but before you write,
         extending the file so the position you write onto clobbers their data.
         Instead, use the &lt;CODE&gt;O_APPEND&lt;/CODE&gt; operating mode; .
         &lt;br&gt;&lt;br&gt; You can set the file position past the current end of the file.  This
         does not by itself make the file longer; &lt;CODE&gt;lseek&lt;/CODE&gt; never changes the
         file.  But subsequent output at that position will extend the file.
         Characters between the previous end of file and the new position are
         filled with zeros.  Extending the file in this way can create a
         ``hole'': the blocks of zeros are not actually allocated on disk, so the
         file takes up less space than it appears to; it is then called a
         ``sparse file''.
          files
          in files
         &lt;br&gt;&lt;br&gt; If the file position cannot be changed, or the operation is in some way
         invalid, &lt;CODE&gt;lseek&lt;/CODE&gt; returns a value of -1.  The following
         &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;LI&gt; EBADF
         The &lt;VAR&gt;filedes&lt;/VAR&gt; is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         The &lt;VAR&gt;whence&lt;/VAR&gt; argument value is not valid, or the resulting
         file offset is not valid.  A file offset is invalid.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ESPIPE
         The &lt;VAR&gt;filedes&lt;/VAR&gt; corresponds to an object that cannot be positioned,
         such as a pipe, FIFO or terminal device.  (POSIX.1 specifies this error
         only for pipes and FIFOs, but in the GNU system, you always get
         &lt;CODE&gt;ESPIPE&lt;/CODE&gt; if the object is not seekable.)

         &lt;br&gt;&lt;br&gt; When the source file is compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; the
         &lt;CODE&gt;lseek&lt;/CODE&gt; function is in fact &lt;CODE&gt;lseek64&lt;/CODE&gt; and the type
         &lt;CODE&gt;off_t&lt;/CODE&gt; has 64 bits which makes it possible to handle files up to
         2^63 bytes in length.
         &lt;br&gt;&lt;br&gt; This function is a cancellation point in multi-threaded programs.  This
         is a problem if the thread allocates some resources (like memory, file
         descriptors, semaphores or whatever) at the time &lt;CODE&gt;lseek&lt;/CODE&gt; is
         called.  If the thread gets canceled these resources stay allocated
         until the program ends.  To avoid this calls to &lt;CODE&gt;lseek&lt;/CODE&gt; should be
         protected using cancellation handlers.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;lseek&lt;/CODE&gt; function is the underlying primitive for the
         &lt;CODE&gt;fseek&lt;/CODE&gt;, &lt;CODE&gt;fseeko&lt;/CODE&gt;, &lt;CODE&gt;ftell&lt;/CODE&gt;, &lt;CODE&gt;ftello&lt;/CODE&gt; and
         &lt;CODE&gt;rewind&lt;/CODE&gt; functions, which operate on streams instead of file
         descriptors.
        </synopsis>
    </function>
  </construct>
  <construct id="function-lseek64" type="function">
    <function returntype="off64_t">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="off64_t offset"/>
        <parameter content="int whence"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        This function is similar to the &lt;CODE&gt;lseek&lt;/CODE&gt; function.  The difference
         is that the &lt;VAR&gt;offset&lt;/VAR&gt; parameter is of type &lt;CODE&gt;off64_t&lt;/CODE&gt; instead of
         &lt;CODE&gt;off_t&lt;/CODE&gt; which makes it possible on 32 bit machines to address
         files larger than 2^31 bytes and up to 2^63 bytes.  The
         file descriptor &lt;CODE&gt;filedes&lt;/CODE&gt; must be opened using &lt;CODE&gt;open64&lt;/CODE&gt; since
         otherwise the large offsets possible with &lt;CODE&gt;off64_t&lt;/CODE&gt; will lead to
         errors with a descriptor in small file mode.
         &lt;br&gt;&lt;br&gt; When the source file is compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; on a
         32 bits machine this function is actually available under the name
         &lt;CODE&gt;lseek&lt;/CODE&gt; and so transparently replaces the 32 bit interface.
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-off_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="dtype-off64_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="function-fdopen" type="function">
    <function returntype="FILE *">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="const char *opentype"/>
      </prototype>
      <headers>
        <header filename = "sys/types.h"/>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fdopen&lt;/CODE&gt; function returns a new stream for the file descriptor
         &lt;VAR&gt;filedes&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;opentype&lt;/VAR&gt; argument is interpreted in the same way as for the
         &lt;CODE&gt;fopen&lt;/CODE&gt; function , except that
         the &lt;samp&gt;b&lt;/samp&gt; option is not permitted; this is because GNU makes no
         distinction between text and binary files.  Also, &lt;CODE&gt;"w"&lt;/CODE&gt; and
         &lt;CODE&gt;"w+"&lt;/CODE&gt; do not cause truncation of the file; these have an effect only
         when opening a file, and in this case the file has already been opened.
         You must make sure that the &lt;VAR&gt;opentype&lt;/VAR&gt; argument matches the actual
         mode of the open file descriptor.
         &lt;br&gt;&lt;br&gt; The return value is the new stream.  If the stream cannot be created
         (for example, if the modes for the file indicated by the file descriptor
         do not permit the access specified by the &lt;VAR&gt;opentype&lt;/VAR&gt; argument), a
         null pointer is returned instead.
         &lt;br&gt;&lt;br&gt; In some other systems, &lt;CODE&gt;fdopen&lt;/CODE&gt; may fail to detect that the modes
         for file descriptor do not permit the access specified by
         &lt;CODE&gt;opentype&lt;/CODE&gt;.  The GNU C library always checks for this.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fileno" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function returns the file descriptor associated with the stream
         &lt;VAR&gt;stream&lt;/VAR&gt;.  If an error is detected (for example, if the &lt;VAR&gt;stream&lt;/VAR&gt;
         is not valid) or if &lt;VAR&gt;stream&lt;/VAR&gt; does not do I/O to a file,
         &lt;CODE&gt;fileno&lt;/CODE&gt; returns -1.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fileno_unlocked" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fileno_unlocked&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;fileno&lt;/CODE&gt;
         function except that it does not implicitly lock the stream if the state
         is &lt;CODE&gt;FSETLOCKING_INTERNAL&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fclean" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        Clean up the stream &lt;VAR&gt;stream&lt;/VAR&gt; so that its buffer is empty.  If
         &lt;VAR&gt;stream&lt;/VAR&gt; is doing output, force it out.  If &lt;VAR&gt;stream&lt;/VAR&gt; is doing
         input, give the data in the buffer back to the system, arranging to
         reread it.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-iovec" type="struct">
    <structure>
        <synopsis>
        &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;iovec&lt;/CODE&gt; structure describes a buffer. It contains two fields:
         &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="void *iov_base">
            <synopsis>
            Contains the address of a buffer.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-readv" type="function">
    <function returntype="ssize_t">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="const struct iovec *vector"/>
        <parameter content="int count"/>
      </prototype>
      <headers>
        <header filename = "sys/uio.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;readv&lt;/CODE&gt; function reads data from &lt;VAR&gt;filedes&lt;/VAR&gt; and scatters it
         into the buffers described in &lt;VAR&gt;vector&lt;/VAR&gt;, which is taken to be
         &lt;VAR&gt;count&lt;/VAR&gt; structures long.  As each buffer is filled, data is sent to the
         next.
         &lt;br&gt;&lt;br&gt; Note that &lt;CODE&gt;readv&lt;/CODE&gt; is not guaranteed to fill all the buffers.
         It may stop at any point, for the same reasons &lt;CODE&gt;read&lt;/CODE&gt; would.
         &lt;br&gt;&lt;br&gt; The return value is a count of bytes (&lt;EM&gt;not&lt;/EM&gt; buffers) read, 0
         indicating end-of-file, or -1 indicating an error.  The possible
         errors are the same as in &lt;CODE&gt;read&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-writev" type="function">
    <function returntype="ssize_t">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="const struct iovec *vector"/>
        <parameter content="int count"/>
      </prototype>
      <headers>
        <header filename = "sys/uio.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;writev&lt;/CODE&gt; function gathers data from the buffers described in
         &lt;VAR&gt;vector&lt;/VAR&gt;, which is taken to be &lt;VAR&gt;count&lt;/VAR&gt; structures long, and writes
         them to &lt;CODE&gt;filedes&lt;/CODE&gt;.  As each buffer is written, it moves on to the
         next.
         &lt;br&gt;&lt;br&gt; Like &lt;CODE&gt;readv&lt;/CODE&gt;, &lt;CODE&gt;writev&lt;/CODE&gt; may stop midstream under the same
         conditions &lt;CODE&gt;write&lt;/CODE&gt; would.
         &lt;br&gt;&lt;br&gt; The return value is a count of bytes written, or -1 indicating an
         error.  The possible errors are the same as in &lt;CODE&gt;write&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-mmap" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="void *address"/>
        <parameter content="size_t length,int protect"/>
        <parameter content="int flags"/>
        <parameter content="int filedes"/>
        <parameter content="off_t offset"/>
      </prototype>
      <headers>
        <header filename = "sys/mman.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;mmap&lt;/CODE&gt; function creates a new mapping, connected to bytes
         (&lt;VAR&gt;offset&lt;/VAR&gt;) to (&lt;VAR&gt;offset&lt;/VAR&gt; + &lt;VAR&gt;length&lt;/VAR&gt; - 1) in the file open on
         &lt;VAR&gt;filedes&lt;/VAR&gt;.  A new reference for the file specified by &lt;VAR&gt;filedes&lt;/VAR&gt;
         is created, which is not removed by closing the file.
         &lt;br&gt;&lt;br&gt; &lt;VAR&gt;address&lt;/VAR&gt; gives a preferred starting address for the mapping.
         &lt;CODE&gt;NULL&lt;/CODE&gt; expresses no preference. Any previous mapping at that
         address is automatically removed. The address you give may still be
         changed, unless you use the &lt;CODE&gt;MAP_FIXED&lt;/CODE&gt; flag.
         &lt;br&gt;&lt;br&gt;


         &lt;VAR&gt;protect&lt;/VAR&gt; contains flags that control what kind of access is
         permitted.  They include &lt;CODE&gt;PROT_READ&lt;/CODE&gt;, &lt;CODE&gt;PROT_WRITE&lt;/CODE&gt;, and
         &lt;CODE&gt;PROT_EXEC&lt;/CODE&gt;, which permit reading, writing, and execution,
         respectively.  Inappropriate access will cause a segfault .
         &lt;br&gt;&lt;br&gt; Note that most hardware designs cannot support write permission without
         read permission, and many do not distinguish read and execute permission.
         Thus, you may receive wider permissions than you ask for, and mappings of
         write-only files may be denied even if you do not use &lt;CODE&gt;PROT_READ&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;VAR&gt;flags&lt;/VAR&gt; contains flags that control the nature of the map.
         One of &lt;CODE&gt;MAP_SHARED&lt;/CODE&gt; or &lt;CODE&gt;MAP_PRIVATE&lt;/CODE&gt; must be specified.
         &lt;br&gt;&lt;br&gt; They include:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;MAP_PRIVATE&lt;/CODE&gt;
&lt;DD&gt;
         This specifies that writes to the region should never be written back
         to the attached file.  Instead, a copy is made for the process, and the
         region will be swapped normally if memory runs low.  No other process will
         see the changes.
         &lt;br&gt;&lt;br&gt; Since private mappings effectively revert to ordinary memory
         when written to, you must have enough virtual memory for a copy of
         the entire mmapped region if you use this mode with &lt;CODE&gt;PROT_WRITE&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;MAP_SHARED&lt;/CODE&gt;
&lt;DD&gt;
         This specifies that writes to the region will be written back to the
         file.  Changes made will be shared immediately with other processes
         mmaping the same file.
         &lt;br&gt;&lt;br&gt; Note that actual writing may take place at any time.  You need to use
         &lt;CODE&gt;msync&lt;/CODE&gt;, described below, if it is important that other processes
         using conventional I/O get a consistent view of the file.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;MAP_FIXED&lt;/CODE&gt;
&lt;DD&gt;
         This forces the system to use the exact mapping address specified in
         &lt;VAR&gt;address&lt;/VAR&gt; and fail if it can't.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;MAP_ANONYMOUS&lt;/CODE&gt;
&lt;DD&gt;
         &lt;LI&gt;x MAP_ANON
         This flag tells the system to create an anonymous mapping, not connected
         to a file.  &lt;VAR&gt;filedes&lt;/VAR&gt; and &lt;VAR&gt;off&lt;/VAR&gt; are ignored, and the region is
         initialized with zeros.
         &lt;br&gt;&lt;br&gt; Anonymous maps are used as the basic primitive to extend the heap on some
         systems.  They are also useful to share data between multiple tasks
         without creating a file.
         &lt;br&gt;&lt;br&gt; On some systems using private anonymous mmaps is more efficient than using
         &lt;CODE&gt;malloc&lt;/CODE&gt; for large blocks.  This is not an issue with the GNU C library,
         as the included &lt;CODE&gt;malloc&lt;/CODE&gt; automatically uses &lt;CODE&gt;mmap&lt;/CODE&gt; where appropriate.
         &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt; &lt;/DL&gt;
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;mmap&lt;/CODE&gt; returns the address of the new mapping, or -1 for an
         error.
         &lt;br&gt;&lt;br&gt; Possible errors include:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;EINVAL&lt;/CODE&gt;
&lt;DD&gt;
         &lt;br&gt;&lt;br&gt; Either &lt;VAR&gt;address&lt;/VAR&gt; was unusable, or inconsistent &lt;VAR&gt;flags&lt;/VAR&gt; were
         given.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EACCES
         &lt;br&gt;&lt;br&gt; &lt;VAR&gt;filedes&lt;/VAR&gt; was not open for the type of access specified in &lt;VAR&gt;protect&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOMEM
         &lt;br&gt;&lt;br&gt; Either there is not enough memory for the operation, or the process is
         out of address space.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENODEV
         &lt;br&gt;&lt;br&gt; This file is of a type that doesn't support mapping.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOEXEC
         &lt;br&gt;&lt;br&gt; The file is on a filesystem that doesn't support mapping.
         &lt;br&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-mmap64" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="void *address"/>
        <parameter content="size_t length,int protect"/>
        <parameter content="int flags"/>
        <parameter content="int filedes"/>
        <parameter content="off64_t offset"/>
      </prototype>
      <headers>
        <header filename = "sys/mman.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;mmap64&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;mmap&lt;/CODE&gt; function but
         the &lt;VAR&gt;offset&lt;/VAR&gt; parameter is of type &lt;CODE&gt;off64_t&lt;/CODE&gt;.  On 32-bit systems
         this allows the file associated with the &lt;VAR&gt;filedes&lt;/VAR&gt; descriptor to be
         larger than 2GB.  &lt;VAR&gt;filedes&lt;/VAR&gt; must be a descriptor returned from a
         call to &lt;CODE&gt;open64&lt;/CODE&gt; or &lt;CODE&gt;fopen64&lt;/CODE&gt; and &lt;CODE&gt;freopen64&lt;/CODE&gt; where the
         descriptor is retrieved with &lt;CODE&gt;fileno&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; When the sources are translated with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; this
         function is actually available under the name &lt;CODE&gt;mmap&lt;/CODE&gt;.  I.e., the
         new, extended API using 64 bit file sizes and offsets transparently
         replaces the old API.
        </synopsis>
    </function>
  </construct>
  <construct id="function-munmap" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="void *addr"/>
        <parameter content="size_t length"/>
      </prototype>
      <headers>
        <header filename = "sys/mman.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; &lt;CODE&gt;munmap&lt;/CODE&gt; removes any memory maps from (&lt;VAR&gt;addr&lt;/VAR&gt;) to (&lt;VAR&gt;addr&lt;/VAR&gt; +
         &lt;VAR&gt;length&lt;/VAR&gt;).  &lt;VAR&gt;length&lt;/VAR&gt; should be the length of the mapping.
         &lt;br&gt;&lt;br&gt; It is safe to unmap multiple mappings in one command, or include unmapped
         space in the range.  It is also possible to unmap only part of an existing
         mapping.  However, only entire pages can be removed.  If &lt;VAR&gt;length&lt;/VAR&gt; is not
         an even number of pages, it will be rounded up.
         &lt;br&gt;&lt;br&gt; It returns 0 for success and -1 for an error.
         &lt;br&gt;&lt;br&gt; One error is possible:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;EINVAL&lt;/CODE&gt;
&lt;DD&gt;
         The memory range given was outside the user mmap range or wasn't page
         aligned.
         &lt;br&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-msync" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="void *address"/>
        <parameter content="size_t length"/>
        <parameter content="int flags"/>
      </prototype>
      <headers>
        <header filename = "sys/mman.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; When using shared mappings, the kernel can write the file at any time
         before the mapping is removed.  To be certain data has actually been
         written to the file and will be accessible to non-memory-mapped I/O, it
         is necessary to use this function.
         &lt;br&gt;&lt;br&gt; It operates on the region &lt;VAR&gt;address&lt;/VAR&gt; to (&lt;VAR&gt;address&lt;/VAR&gt; + &lt;VAR&gt;length&lt;/VAR&gt;).
         It may be used on part of a mapping or multiple mappings, however the
         region given should not contain any unmapped space.
         &lt;br&gt;&lt;br&gt; &lt;VAR&gt;flags&lt;/VAR&gt; can contain some options:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;MS_SYNC&lt;/CODE&gt;
&lt;DD&gt;
         &lt;br&gt;&lt;br&gt; This flag makes sure the data is actually written &lt;EM&gt;to disk&lt;/EM&gt;.
         Normally &lt;CODE&gt;msync&lt;/CODE&gt; only makes sure that accesses to a file with
         conventional I/O reflect the recent changes.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;MS_ASYNC&lt;/CODE&gt;
&lt;DD&gt;
         &lt;br&gt;&lt;br&gt; This tells &lt;CODE&gt;msync&lt;/CODE&gt; to begin the synchronization, but not to wait for
         it to complete.
         &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt; &lt;/DL&gt;
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;msync&lt;/CODE&gt; returns 0 for success and -1 for
         error.  Errors include:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;EINVAL&lt;/CODE&gt;
&lt;DD&gt;
         An invalid region was given, or the &lt;VAR&gt;flags&lt;/VAR&gt; were invalid.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EFAULT
         There is no existing mapping in at least part of the given region.
         &lt;br&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-mremap" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="void *address"/>
        <parameter content="size_t length"/>
        <parameter content="size_t new_length"/>
        <parameter content="int flag"/>
      </prototype>
      <headers>
        <header filename = "sys/mman.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; This function can be used to change the size of an existing memory
         area. &lt;VAR&gt;address&lt;/VAR&gt; and &lt;VAR&gt;length&lt;/VAR&gt; must cover a region entirely mapped
         in the same &lt;CODE&gt;mmap&lt;/CODE&gt; statement. A new mapping with the same
         characteristics will be returned with the length &lt;VAR&gt;new_length&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; One option is possible, &lt;CODE&gt;MREMAP_MAYMOVE&lt;/CODE&gt;. If it is given in
         &lt;VAR&gt;flags&lt;/VAR&gt;, the system may remove the existing mapping and create a new
         one of the desired length in another location.
         &lt;br&gt;&lt;br&gt; The address of the resulting mapping is returned, or -1. Possible
         error codes include:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;EFAULT&lt;/CODE&gt;
&lt;DD&gt;
         There is no existing mapping in at least part of the original region, or
         the region covers two or more distinct mappings.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         The address given is misaligned or inappropriate.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EAGAIN
         The region has pages locked, and if extended it would exceed the
         process's resource limit for locked pages.  .
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOMEM
         The region is private writable, and insufficient virtual memory is
         available to extend it.  Also, this error will occur if
         &lt;CODE&gt;MREMAP_MAYMOVE&lt;/CODE&gt; is not given and the extension would collide with
         another mapped region.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-madvise" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="void *addr"/>
        <parameter content="size_t length"/>
        <parameter content="int advice"/>
      </prototype>
      <headers>
        <header filename = "sys/mman.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; This function can be used to provide the system with &lt;VAR&gt;advice&lt;/VAR&gt; about
         the intended usage patterns of the memory region starting at &lt;VAR&gt;addr&lt;/VAR&gt;
         and extending &lt;VAR&gt;length&lt;/VAR&gt; bytes.
         &lt;br&gt;&lt;br&gt; The valid BSD values for &lt;VAR&gt;advice&lt;/VAR&gt; are:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;MADV_NORMAL&lt;/CODE&gt;
&lt;DD&gt;
         The region should receive no further special treatment.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;MADV_RANDOM&lt;/CODE&gt;
&lt;DD&gt;
         The region will be accessed via random page references. The kernel
         should page-in the minimal number of pages for each page fault.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;MADV_SEQUENTIAL&lt;/CODE&gt;
&lt;DD&gt;
         The region will be accessed via sequential page references. This
         may cause the kernel to aggressively read-ahead, expecting further
         sequential references after any page fault within this region.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; MADV_WILLNEED
         The region will be needed.  The pages within this region may
         be pre-faulted in by the kernel.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; MADV_DONTNEED
         The region is no longer needed.  The kernel may free these pages,
         causing any changes to the pages to be lost, as well as swapped
         out pages to be discarded.
         &lt;br&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; The POSIX names are slightly different, but with the same meanings:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;br&gt;&lt;br&gt; &lt;LI&gt; POSIX_MADV_NORMAL
         This corresponds with BSD's &lt;CODE&gt;MADV_NORMAL&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; POSIX_MADV_RANDOM
         This corresponds with BSD's &lt;CODE&gt;MADV_RANDOM&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; POSIX_MADV_SEQUENTIAL
         This corresponds with BSD's &lt;CODE&gt;MADV_SEQUENTIAL&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; POSIX_MADV_WILLNEED
         This corresponds with BSD's &lt;CODE&gt;MADV_WILLNEED&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; POSIX_MADV_DONTNEED
         This corresponds with BSD's &lt;CODE&gt;MADV_DONTNEED&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;msync&lt;/CODE&gt; returns 0 for success and -1 for
         error.  Errors include:
         &lt;DL&gt;

         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         An invalid region was given, or the &lt;VAR&gt;advice&lt;/VAR&gt; was invalid.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EFAULT
         There is no existing mapping in at least part of the given region.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-fd_set" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="function-select" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int nfds"/>
        <parameter content="fd_set *read-fds"/>
        <parameter content="fd_set *write-fds"/>
        <parameter content="fd_set *except-fds"/>
        <parameter content="struct timeval *timeout"/>
      </prototype>
      <headers>
        <header filename = "sys/types.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;select&lt;/CODE&gt; function blocks the calling process until there is
         activity on any of the specified sets of file descriptors, or until the
         timeout period has expired.
         &lt;br&gt;&lt;br&gt; The file descriptors specified by the &lt;VAR&gt;read-fds&lt;/VAR&gt; argument are
         checked to see if they are ready for reading; the &lt;VAR&gt;write-fds&lt;/VAR&gt; file
         descriptors are checked to see if they are ready for writing; and the
         &lt;VAR&gt;except-fds&lt;/VAR&gt; file descriptors are checked for exceptional
         conditions.  You can pass a null pointer for any of these arguments if
         you are not interested in checking for that kind of condition.
         &lt;br&gt;&lt;br&gt; A file descriptor is considered ready for reading if a &lt;CODE&gt;read&lt;/CODE&gt;
         call will not block.  This usually includes the read offset being at
         the end of the file or there is an error to report.  A server socket
         is considered ready for reading if there is a pending connection which
         can be accepted with &lt;CODE&gt;accept&lt;/CODE&gt;; .  A
         client socket is ready for writing when its connection is fully
         established; .
         &lt;br&gt;&lt;br&gt; ``Exceptional conditions'' does not mean errors---errors are reported
         immediately when an erroneous system call is executed, and do not
         constitute a state of the descriptor.  Rather, they include conditions
         such as the presence of an urgent message on a socket.  (,
         for information on urgent messages.)
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;select&lt;/CODE&gt; function checks only the first &lt;VAR&gt;nfds&lt;/VAR&gt; file
         descriptors.  The usual thing is to pass &lt;CODE&gt;FD_SETSIZE&lt;/CODE&gt; as the value
         of this argument.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;timeout&lt;/VAR&gt; specifies the maximum time to wait.  If you pass a
         null pointer for this argument, it means to block indefinitely until one
         of the file descriptors is ready.  Otherwise, you should provide the
         time in &lt;CODE&gt;struct timeval&lt;/CODE&gt; format; see High-Resolution
         Calendar.  Specify zero as the time (a &lt;CODE&gt;struct timeval&lt;/CODE&gt; containing
         all zeros) if you want to find out which descriptors are ready without
         waiting if none are ready.
         &lt;br&gt;&lt;br&gt; The normal return value from &lt;CODE&gt;select&lt;/CODE&gt; is the total number of ready file
         descriptors in all of the sets.  Each of the argument sets is overwritten
         with information about the descriptors that are ready for the corresponding
         operation.  Thus, to see if a particular descriptor &lt;VAR&gt;desc&lt;/VAR&gt; has input,
         use &lt;CODE&gt;FD_ISSET (&lt;VAR&gt;desc&lt;/VAR&gt;, &lt;VAR&gt;read-fds&lt;/VAR&gt;)&lt;/CODE&gt; after &lt;CODE&gt;select&lt;/CODE&gt; returns.
         &lt;br&gt;&lt;br&gt; If &lt;CODE&gt;select&lt;/CODE&gt; returns because the timeout period expires, it returns
         a value of zero.
         &lt;br&gt;&lt;br&gt; Any signal will cause &lt;CODE&gt;select&lt;/CODE&gt; to return immediately.  So if your
         program uses signals, you can't rely on &lt;CODE&gt;select&lt;/CODE&gt; to keep waiting
         for the full time specified.  If you want to be sure of waiting for a
         particular amount of time, you must check for &lt;CODE&gt;EINTR&lt;/CODE&gt; and repeat
         the &lt;CODE&gt;select&lt;/CODE&gt; with a newly calculated timeout based on the current
         time.  See the example below.  See also Interrupted Primitives.
         &lt;br&gt;&lt;br&gt; If an error occurs, &lt;CODE&gt;select&lt;/CODE&gt; returns &lt;CODE&gt;-1&lt;/CODE&gt; and does not modify
         the argument file descriptor sets.  The following &lt;CODE&gt;errno&lt;/CODE&gt; error
         conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         One of the file descriptor sets specified an invalid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINTR
         The operation was interrupted by a signal.  .
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         The &lt;VAR&gt;timeout&lt;/VAR&gt; argument is invalid; one of the components is negative
         or too large.

        </synopsis>
    </function>
  </construct>
  <construct id="function-sync" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        A call to this function will not return as long as there is data which
         has not been written to the device.  All dirty buffers in the kernel will
         be written and so an overall consistent system can be achieved (if no
         other process in parallel writes data).
         &lt;br&gt;&lt;br&gt; A prototype for &lt;CODE&gt;sync&lt;/CODE&gt; can be found in &lt;TT&gt;unistd.h&lt;/TT&gt;.
         &lt;br&gt;&lt;br&gt; The return value is zero to indicate no error.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fsync" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int fildes"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fsync&lt;/CODE&gt; function can be used to make sure all data associated with
         the open file &lt;VAR&gt;fildes&lt;/VAR&gt; is written to the device associated with the
         descriptor.  The function call does not return unless all actions have
         finished.
         &lt;br&gt;&lt;br&gt; A prototype for &lt;CODE&gt;fsync&lt;/CODE&gt; can be found in &lt;TT&gt;unistd.h&lt;/TT&gt;.
         &lt;br&gt;&lt;br&gt; This function is a cancellation point in multi-threaded programs.  This
         is a problem if the thread allocates some resources (like memory, file
         descriptors, semaphores or whatever) at the time &lt;CODE&gt;fsync&lt;/CODE&gt; is
         called.  If the thread gets canceled these resources stay allocated
         until the program ends.  To avoid this, calls to &lt;CODE&gt;fsync&lt;/CODE&gt; should be
         protected using cancellation handlers.
         &lt;br&gt;&lt;br&gt; The return value of the function is zero if no error occurred.  Otherwise
         it is -1 and the global variable &lt;VAR&gt;errno&lt;/VAR&gt; is set to the
         following values:
         &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The descriptor &lt;VAR&gt;fildes&lt;/VAR&gt; is not valid.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         No synchronization is possible since the system does not implement this.

        </synopsis>
    </function>
  </construct>
  <construct id="function-fdatasync" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int fildes"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        When a call to the &lt;CODE&gt;fdatasync&lt;/CODE&gt; function returns, it is ensured
         that all of the file data is written to the device.  For all pending I/O
         operations, the parts guaranteeing data integrity finished.
         &lt;br&gt;&lt;br&gt; Not all systems implement the &lt;CODE&gt;fdatasync&lt;/CODE&gt; operation.  On systems
         missing this functionality &lt;CODE&gt;fdatasync&lt;/CODE&gt; is emulated by a call to
         &lt;CODE&gt;fsync&lt;/CODE&gt; since the performed actions are a superset of those
         required by &lt;CODE&gt;fdatasync&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The prototype for &lt;CODE&gt;fdatasync&lt;/CODE&gt; is in &lt;TT&gt;unistd.h&lt;/TT&gt;.
         &lt;br&gt;&lt;br&gt; The return value of the function is zero if no error occurred.  Otherwise
         it is -1 and the global variable &lt;VAR&gt;errno&lt;/VAR&gt; is set to the
         following values:
         &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The descriptor &lt;VAR&gt;fildes&lt;/VAR&gt; is not valid.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         No synchronization is possible since the system does not implement this.

        </synopsis>
    </function>
  </construct>
  <construct id="struct-aiocb" type="struct">
    <structure>
        <synopsis>
        The POSIX.1b standard mandates that the &lt;CODE&gt;struct aiocb&lt;/CODE&gt; structure
         contains at least the members described in the following table.  There
         might be more elements which are used by the implementation, but
         depending upon these elements is not portable and is highly deprecated.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="int aio_fildes">
            <synopsis>
            This element specifies the file descriptor to be used for the
             operation.  It must be a legal descriptor, otherwise the operation will
             fail.
             &lt;br&gt;&lt;br&gt; The device on which the file is opened must allow the seek operation.
             I.e., it is not possible to use any of the AIO operations on devices
             like terminals where an &lt;CODE&gt;lseek&lt;/CODE&gt; call would lead to an error.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="off_t aio_offset">
            <synopsis>
            This element specifies the offset in the file at which the operation (input
             or output) is performed.  Since the operations are carried out in arbitrary
             order and more than one operation for one file descriptor can be
             started, one cannot expect a current read/write position of the file
             descriptor.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="volatile void *aio_buf">
            <synopsis>
            This is a pointer to the buffer with the data to be written or the place
             where the read data is stored.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="size_t aio_nbytes">
            <synopsis>
            This element specifies the length of the buffer pointed to by &lt;CODE&gt;aio_buf&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int aio_reqprio">
            <synopsis>
            If the platform has defined &lt;CODE&gt;_POSIX_PRIORITIZED_IO&lt;/CODE&gt; and
             &lt;CODE&gt;_POSIX_PRIORITY_SCHEDULING&lt;/CODE&gt;, the AIO requests are
             processed based on the current scheduling priority.  The
             &lt;CODE&gt;aio_reqprio&lt;/CODE&gt; element can then be used to lower the priority of the
             AIO operation.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="struct sigevent aio_sigevent">
            <synopsis>
            This element specifies how the calling process is notified once the
             operation terminates.  If the &lt;CODE&gt;sigev_notify&lt;/CODE&gt; element is
             &lt;CODE&gt;SIGEV_NONE&lt;/CODE&gt;, no notification is sent.  If it is &lt;CODE&gt;SIGEV_SIGNAL&lt;/CODE&gt;,
             the signal determined by &lt;CODE&gt;sigev_signo&lt;/CODE&gt; is sent.  Otherwise,
             &lt;CODE&gt;sigev_notify&lt;/CODE&gt; must be &lt;CODE&gt;SIGEV_THREAD&lt;/CODE&gt;.  In this case, a thread
             is created which starts executing the function pointed to by
             &lt;CODE&gt;sigev_notify_function&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int aio_lio_opcode">
            <synopsis>
            This element is only used by the &lt;CODE&gt;lio_listio&lt;/CODE&gt; and
             &lt;CODE&gt;lio_listio64&lt;/CODE&gt; functions.  Since these functions allow an
             arbitrary number of operations to start at once, and each operation can be
             input or output (or nothing), the information must be stored in the
             control block.  The possible values are:
             &lt;br&gt;&lt;br&gt; &lt;DL&gt;

            </synopsis>
        </element>
        <element content="LIO_READ">
            <synopsis>
            Start a read operation.  Read from the file at position
             &lt;CODE&gt;aio_offset&lt;/CODE&gt; and store the next &lt;CODE&gt;aio_nbytes&lt;/CODE&gt; bytes in the
             buffer pointed to by &lt;CODE&gt;aio_buf&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="LIO_WRITE">
            <synopsis>
            Start a write operation.  Write &lt;CODE&gt;aio_nbytes&lt;/CODE&gt; bytes starting at
             &lt;CODE&gt;aio_buf&lt;/CODE&gt; into the file starting at position &lt;CODE&gt;aio_offset&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="struct-aiocb64" type="struct">
    <structure>
      <elements>
        <element content="int aio_fildes">
            <synopsis>
            This element specifies the file descriptor which is used for the
             operation.  It must be a legal descriptor since otherwise the operation
             fails for obvious reasons.
             &lt;br&gt;&lt;br&gt; The device on which the file is opened must allow the seek operation.
             I.e., it is not possible to use any of the AIO operations on devices
             like terminals where an &lt;CODE&gt;lseek&lt;/CODE&gt; call would lead to an error.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="off64_t aio_offset">
            <synopsis>
            This element specifies at which offset in the file the operation (input
             or output) is performed.  Since the operation are carried in arbitrary
             order and more than one operation for one file descriptor can be
             started, one cannot expect a current read/write position of the file
             descriptor.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="volatile void *aio_buf">
            <synopsis>
            This is a pointer to the buffer with the data to be written or the place
             where the read data is stored.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="size_t aio_nbytes">
            <synopsis>
            This element specifies the length of the buffer pointed to by &lt;CODE&gt;aio_buf&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int aio_reqprio">
            <synopsis>
            If for the platform &lt;CODE&gt;_POSIX_PRIORITIZED_IO&lt;/CODE&gt; and
             &lt;CODE&gt;_POSIX_PRIORITY_SCHEDULING&lt;/CODE&gt; are defined the AIO requests are
             processed based on the current scheduling priority.  The
             &lt;CODE&gt;aio_reqprio&lt;/CODE&gt; element can then be used to lower the priority of the
             AIO operation.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="struct sigevent aio_sigevent">
            <synopsis>
            This element specifies how the calling process is notified once the
             operation terminates.  If the &lt;CODE&gt;sigev_notify&lt;/CODE&gt;, element is
             &lt;CODE&gt;SIGEV_NONE&lt;/CODE&gt; no notification is sent.  If it is &lt;CODE&gt;SIGEV_SIGNAL&lt;/CODE&gt;,
             the signal determined by &lt;CODE&gt;sigev_signo&lt;/CODE&gt; is sent.  Otherwise,
             &lt;CODE&gt;sigev_notify&lt;/CODE&gt; must be &lt;CODE&gt;SIGEV_THREAD&lt;/CODE&gt; in which case a thread
             which starts executing the function pointed to by
             &lt;CODE&gt;sigev_notify_function&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-aio_read" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="struct aiocb *aiocbp"/>
      </prototype>
      <headers>
        <header filename = "aio.h"/>
      </headers>
        <synopsis>
        This function initiates an asynchronous read operation.  It
         immediately returns after the operation was enqueued or when an
         error was encountered.
         &lt;br&gt;&lt;br&gt; The first &lt;CODE&gt;aiocbp-&gt;aio_nbytes&lt;/CODE&gt; bytes of the file for which
         &lt;CODE&gt;aiocbp-&gt;aio_fildes&lt;/CODE&gt; is a descriptor are written to the buffer
         starting at &lt;CODE&gt;aiocbp-&gt;aio_buf&lt;/CODE&gt;.  Reading starts at the absolute
         position &lt;CODE&gt;aiocbp-&gt;aio_offset&lt;/CODE&gt; in the file.
         &lt;br&gt;&lt;br&gt; If prioritized I/O is supported by the platform the
         &lt;CODE&gt;aiocbp-&gt;aio_reqprio&lt;/CODE&gt; value is used to adjust the priority before
         the request is actually enqueued.
         &lt;br&gt;&lt;br&gt; The calling process is notified about the termination of the read
         request according to the &lt;CODE&gt;aiocbp-&gt;aio_sigevent&lt;/CODE&gt; value.
         &lt;br&gt;&lt;br&gt; When &lt;CODE&gt;aio_read&lt;/CODE&gt; returns, the return value is zero if no error
         occurred that can be found before the process is enqueued.  If such an
         early error is found, the function returns -1 and sets
         &lt;CODE&gt;errno&lt;/CODE&gt; to one of the following values:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EAGAIN&lt;/CODE&gt;
&lt;DD&gt;
         The request was not enqueued due to (temporarily) exceeded resource
         limitations.
         &lt;DT&gt;&lt;CODE&gt;ENOSYS&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;CODE&gt;aio_read&lt;/CODE&gt; function is not implemented.
         &lt;LI&gt; EBADF
         The &lt;CODE&gt;aiocbp-&gt;aio_fildes&lt;/CODE&gt; descriptor is not valid.  This condition
         need not be recognized before enqueueing the request and so this error
         might also be signaled asynchronously.
         &lt;LI&gt; EINVAL
         The &lt;CODE&gt;aiocbp-&gt;aio_offset&lt;/CODE&gt; or &lt;CODE&gt;aiocbp-&gt;aio_reqpiro&lt;/CODE&gt; value is
         invalid.  This condition need not be recognized before enqueueing the
         request and so this error might also be signaled asynchronously.

         &lt;br&gt;&lt;br&gt; If &lt;CODE&gt;aio_read&lt;/CODE&gt; returns zero, the current status of the request
         can be queried using &lt;CODE&gt;aio_error&lt;/CODE&gt; and &lt;CODE&gt;aio_return&lt;/CODE&gt; functions.
         As long as the value returned by &lt;CODE&gt;aio_error&lt;/CODE&gt; is &lt;CODE&gt;EINPROGRESS&lt;/CODE&gt;
         the operation has not yet completed.  If &lt;CODE&gt;aio_error&lt;/CODE&gt; returns zero,
         the operation successfully terminated, otherwise the value is to be
         interpreted as an error code.  If the function terminated, the result of
         the operation can be obtained using a call to &lt;CODE&gt;aio_return&lt;/CODE&gt;.  The
         returned value is the same as an equivalent call to &lt;CODE&gt;read&lt;/CODE&gt; would
         have returned.  Possible error codes returned by &lt;CODE&gt;aio_error&lt;/CODE&gt; are:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;LI&gt; EBADF
         The &lt;CODE&gt;aiocbp-&gt;aio_fildes&lt;/CODE&gt; descriptor is not valid.
         &lt;LI&gt; ECANCELED
         The operation was canceled before the operation was finished

         &lt;LI&gt; EINVAL
         The &lt;CODE&gt;aiocbp-&gt;aio_offset&lt;/CODE&gt; value is invalid.

         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; this
         function is in fact &lt;CODE&gt;aio_read64&lt;/CODE&gt; since the LFS interface transparently
         replaces the normal implementation.
        </synopsis>
    </function>
  </construct>
  <construct id="function-aio_read64" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="struct aiocb *aiocbp"/>
      </prototype>
      <headers>
        <header filename = "aio.h"/>
      </headers>
        <synopsis>
        This function is similar to the &lt;CODE&gt;aio_read&lt;/CODE&gt; function.  The only
         difference is that on 32 bit machines, the file descriptor should
         be opened in the large file mode.  Internally, &lt;CODE&gt;aio_read64&lt;/CODE&gt; uses
         functionality equivalent to &lt;CODE&gt;lseek64&lt;/CODE&gt;  to position the file descriptor correctly for the reading,
         as opposed to &lt;CODE&gt;lseek&lt;/CODE&gt; functionality used in &lt;CODE&gt;aio_read&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt;, this
         function is available under the name &lt;CODE&gt;aio_read&lt;/CODE&gt; and so transparently
         replaces the interface for small files on 32 bit machines.
        </synopsis>
    </function>
  </construct>
  <construct id="function-aio_write" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="struct aiocb *aiocbp"/>
      </prototype>
      <headers>
        <header filename = "aio.h"/>
      </headers>
        <synopsis>
        This function initiates an asynchronous write operation.  The function
         call immediately returns after the operation was enqueued or if before
         this happens an error was encountered.
         &lt;br&gt;&lt;br&gt; The first &lt;CODE&gt;aiocbp-&gt;aio_nbytes&lt;/CODE&gt; bytes from the buffer starting at
         &lt;CODE&gt;aiocbp-&gt;aio_buf&lt;/CODE&gt; are written to the file for which
         &lt;CODE&gt;aiocbp-&gt;aio_fildes&lt;/CODE&gt; is an descriptor, starting at the absolute
         position &lt;CODE&gt;aiocbp-&gt;aio_offset&lt;/CODE&gt; in the file.
         &lt;br&gt;&lt;br&gt; If prioritized I/O is supported by the platform, the
         &lt;CODE&gt;aiocbp-&gt;aio_reqprio&lt;/CODE&gt; value is used to adjust the priority before
         the request is actually enqueued.
         &lt;br&gt;&lt;br&gt; The calling process is notified about the termination of the read
         request according to the &lt;CODE&gt;aiocbp-&gt;aio_sigevent&lt;/CODE&gt; value.
         &lt;br&gt;&lt;br&gt; When &lt;CODE&gt;aio_write&lt;/CODE&gt; returns, the return value is zero if no error
         occurred that can be found before the process is enqueued.  If such an
         early error is found the function returns -1 and sets
         &lt;CODE&gt;errno&lt;/CODE&gt; to one of the following values.
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EAGAIN&lt;/CODE&gt;
&lt;DD&gt;
         The request was not enqueued due to (temporarily) exceeded resource
         limitations.
         &lt;DT&gt;&lt;CODE&gt;ENOSYS&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;CODE&gt;aio_write&lt;/CODE&gt; function is not implemented.
         &lt;LI&gt; EBADF
         The &lt;CODE&gt;aiocbp-&gt;aio_fildes&lt;/CODE&gt; descriptor is not valid.  This condition
         may not be recognized before enqueueing the request, and so this error
         might also be signaled asynchronously.
         &lt;LI&gt; EINVAL
         The &lt;CODE&gt;aiocbp-&gt;aio_offset&lt;/CODE&gt; or &lt;CODE&gt;aiocbp-&gt;aio_reqprio&lt;/CODE&gt; value is
         invalid.  This condition may not be recognized before enqueueing the
         request and so this error might also be signaled asynchronously.

         &lt;br&gt;&lt;br&gt; In the case &lt;CODE&gt;aio_write&lt;/CODE&gt; returns zero, the current status of the
         request can be queried using &lt;CODE&gt;aio_error&lt;/CODE&gt; and &lt;CODE&gt;aio_return&lt;/CODE&gt;
         functions.  As long as the value returned by &lt;CODE&gt;aio_error&lt;/CODE&gt; is
         &lt;CODE&gt;EINPROGRESS&lt;/CODE&gt; the operation has not yet completed.  If
         &lt;CODE&gt;aio_error&lt;/CODE&gt; returns zero, the operation successfully terminated,
         otherwise the value is to be interpreted as an error code.  If the
         function terminated, the result of the operation can be get using a call
         to &lt;CODE&gt;aio_return&lt;/CODE&gt;.  The returned value is the same as an equivalent
         call to &lt;CODE&gt;read&lt;/CODE&gt; would have returned.  Possible error codes returned
         by &lt;CODE&gt;aio_error&lt;/CODE&gt; are:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;LI&gt; EBADF
         The &lt;CODE&gt;aiocbp-&gt;aio_fildes&lt;/CODE&gt; descriptor is not valid.
         &lt;LI&gt; ECANCELED
         The operation was canceled before the operation was finished.

         &lt;LI&gt; EINVAL
         The &lt;CODE&gt;aiocbp-&gt;aio_offset&lt;/CODE&gt; value is invalid.

         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt;, this
         function is in fact &lt;CODE&gt;aio_write64&lt;/CODE&gt; since the LFS interface transparently
         replaces the normal implementation.
        </synopsis>
    </function>
  </construct>
  <construct id="function-aio_write64" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="struct aiocb *aiocbp"/>
      </prototype>
      <headers>
        <header filename = "aio.h"/>
      </headers>
        <synopsis>
        This function is similar to the &lt;CODE&gt;aio_write&lt;/CODE&gt; function.  The only
         difference is that on 32 bit machines the file descriptor should
         be opened in the large file mode.  Internally &lt;CODE&gt;aio_write64&lt;/CODE&gt; uses
         functionality equivalent to &lt;CODE&gt;lseek64&lt;/CODE&gt;  to position the file descriptor correctly for the writing,
         as opposed to &lt;CODE&gt;lseek&lt;/CODE&gt; functionality used in &lt;CODE&gt;aio_write&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt;, this
         function is available under the name &lt;CODE&gt;aio_write&lt;/CODE&gt; and so transparently
         replaces the interface for small files on 32 bit machines.
        </synopsis>
    </function>
  </construct>
  <construct id="function-lio_listio" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int mode"/>
        <parameter content="struct aiocb *const list[]"/>
        <parameter content="int nent"/>
        <parameter content="struct sigevent *sig"/>
      </prototype>
      <headers>
        <header filename = "aio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;lio_listio&lt;/CODE&gt; function can be used to enqueue an arbitrary
         number of read and write requests at one time.  The requests can all be
         meant for the same file, all for different files or every solution in
         between.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;lio_listio&lt;/CODE&gt; gets the &lt;VAR&gt;nent&lt;/VAR&gt; requests from the array pointed to
         by &lt;VAR&gt;list&lt;/VAR&gt;.  The operation to be performed is determined by the
         &lt;CODE&gt;aio_lio_opcode&lt;/CODE&gt; member in each element of &lt;VAR&gt;list&lt;/VAR&gt;.  If this
         field is &lt;CODE&gt;LIO_READ&lt;/CODE&gt; a read operation is enqueued, similar to a call
         of &lt;CODE&gt;aio_read&lt;/CODE&gt; for this element of the array (except that the way
         the termination is signalled is different, as we will see below).  If
         the &lt;CODE&gt;aio_lio_opcode&lt;/CODE&gt; member is &lt;CODE&gt;LIO_WRITE&lt;/CODE&gt; a write operation
         is enqueued.  Otherwise the &lt;CODE&gt;aio_lio_opcode&lt;/CODE&gt; must be &lt;CODE&gt;LIO_NOP&lt;/CODE&gt;
         in which case this element of &lt;VAR&gt;list&lt;/VAR&gt; is simply ignored.  This
         ``operation'' is useful in situations where one has a fixed array of
         &lt;CODE&gt;struct aiocb&lt;/CODE&gt; elements from which only a few need to be handled at
         a time.  Another situation is where the &lt;CODE&gt;lio_listio&lt;/CODE&gt; call was
         canceled before all requests are processed  and the remaining requests have to be reissued.
         &lt;br&gt;&lt;br&gt; The other members of each element of the array pointed to by
         &lt;CODE&gt;list&lt;/CODE&gt; must have values suitable for the operation as described in
         the documentation for &lt;CODE&gt;aio_read&lt;/CODE&gt; and &lt;CODE&gt;aio_write&lt;/CODE&gt; above.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;mode&lt;/VAR&gt; argument determines how &lt;CODE&gt;lio_listio&lt;/CODE&gt; behaves after
         having enqueued all the requests.  If &lt;VAR&gt;mode&lt;/VAR&gt; is &lt;CODE&gt;LIO_WAIT&lt;/CODE&gt; it
         waits until all requests terminated.  Otherwise &lt;VAR&gt;mode&lt;/VAR&gt; must be
         &lt;CODE&gt;LIO_NOWAIT&lt;/CODE&gt; and in this case the function returns immediately after
         having enqueued all the requests.  In this case the caller gets a
         notification of the termination of all requests according to the
         &lt;VAR&gt;sig&lt;/VAR&gt; parameter.  If &lt;VAR&gt;sig&lt;/VAR&gt; is &lt;CODE&gt;NULL&lt;/CODE&gt; no notification is
         send.  Otherwise a signal is sent or a thread is started, just as
         described in the description for &lt;CODE&gt;aio_read&lt;/CODE&gt; or &lt;CODE&gt;aio_write&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;mode&lt;/VAR&gt; is &lt;CODE&gt;LIO_WAIT&lt;/CODE&gt;, the return value of &lt;CODE&gt;lio_listio&lt;/CODE&gt;
         is 0 when all requests completed successfully.  Otherwise the
         function return -1 and &lt;CODE&gt;errno&lt;/CODE&gt; is set accordingly.  To find
         out which request or requests failed one has to use the &lt;CODE&gt;aio_error&lt;/CODE&gt;
         function on all the elements of the array &lt;VAR&gt;list&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; In case &lt;VAR&gt;mode&lt;/VAR&gt; is &lt;CODE&gt;LIO_NOWAIT&lt;/CODE&gt;, the function returns 0 if
         all requests were enqueued correctly.  The current state of the requests
         can be found using &lt;CODE&gt;aio_error&lt;/CODE&gt; and &lt;CODE&gt;aio_return&lt;/CODE&gt; as described
         above.  If &lt;CODE&gt;lio_listio&lt;/CODE&gt; returns -1 in this mode, the
         global variable &lt;CODE&gt;errno&lt;/CODE&gt; is set accordingly.  If a request did not
         yet terminate, a call to &lt;CODE&gt;aio_error&lt;/CODE&gt; returns &lt;CODE&gt;EINPROGRESS&lt;/CODE&gt;.  If
         the value is different, the request is finished and the error value (or
         0) is returned and the result of the operation can be retrieved
         using &lt;CODE&gt;aio_return&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; Possible values for &lt;CODE&gt;errno&lt;/CODE&gt; are:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EAGAIN&lt;/CODE&gt;
&lt;DD&gt;
         The resources necessary to queue all the requests are not available at
         the moment.  The error status for each element of &lt;VAR&gt;list&lt;/VAR&gt; must be
         checked to determine which request failed.
         &lt;br&gt;&lt;br&gt; Another reason could be that the system wide limit of AIO requests is
         exceeded.  This cannot be the case for the implementation on GNU systems
         since no arbitrary limits exist.
         &lt;LI&gt; EINVAL
         The &lt;VAR&gt;mode&lt;/VAR&gt; parameter is invalid or &lt;VAR&gt;nent&lt;/VAR&gt; is larger than
         &lt;CODE&gt;AIO_LISTIO_MAX&lt;/CODE&gt;.
         &lt;LI&gt; EIO
         One or more of the request's I/O operations failed.  The error status of
         each request should be checked to determine which one failed.
         &lt;LI&gt; ENOSYS
         The &lt;CODE&gt;lio_listio&lt;/CODE&gt; function is not supported.

         &lt;br&gt;&lt;br&gt; If the &lt;VAR&gt;mode&lt;/VAR&gt; parameter is &lt;CODE&gt;LIO_NOWAIT&lt;/CODE&gt; and the caller cancels
         a request, the error status for this request returned by
         &lt;CODE&gt;aio_error&lt;/CODE&gt; is &lt;CODE&gt;ECANCELED&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt;, this
         function is in fact &lt;CODE&gt;lio_listio64&lt;/CODE&gt; since the LFS interface
         transparently replaces the normal implementation.
        </synopsis>
    </function>
  </construct>
  <construct id="function-lio_listio64" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int mode"/>
        <parameter content="struct aiocb *const list"/>
        <parameter content="int nent"/>
        <parameter content="struct sigevent *sig"/>
      </prototype>
      <headers>
        <header filename = "aio.h"/>
      </headers>
        <synopsis>
        This function is similar to the &lt;CODE&gt;lio_listio&lt;/CODE&gt; function.  The only
         difference is that on 32 bit machines, the file descriptor should
         be opened in the large file mode.  Internally, &lt;CODE&gt;lio_listio64&lt;/CODE&gt; uses
         functionality equivalent to &lt;CODE&gt;lseek64&lt;/CODE&gt;  to position the file descriptor correctly for the reading or
         writing, as opposed to &lt;CODE&gt;lseek&lt;/CODE&gt; functionality used in
         &lt;CODE&gt;lio_listio&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt;, this
         function is available under the name &lt;CODE&gt;lio_listio&lt;/CODE&gt; and so
         transparently replaces the interface for small files on 32 bit
         machines.
        </synopsis>
    </function>
  </construct>
  <construct id="function-aio_error" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const struct aiocb *aiocbp"/>
      </prototype>
      <headers>
        <header filename = "aio.h"/>
      </headers>
        <synopsis>
        This function determines the error state of the request described by the
         &lt;CODE&gt;struct aiocb&lt;/CODE&gt; variable pointed to by &lt;VAR&gt;aiocbp&lt;/VAR&gt;.  If the
         request has not yet terminated the value returned is always
         &lt;CODE&gt;EINPROGRESS&lt;/CODE&gt;.  Once the request has terminated the value
         &lt;CODE&gt;aio_error&lt;/CODE&gt; returns is either 0 if the request completed
         successfully or it returns the value which would be stored in the
         &lt;CODE&gt;errno&lt;/CODE&gt; variable if the request would have been done using
         &lt;CODE&gt;read&lt;/CODE&gt;, &lt;CODE&gt;write&lt;/CODE&gt;, or &lt;CODE&gt;fsync&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The function can return &lt;CODE&gt;ENOSYS&lt;/CODE&gt; if it is not implemented.  It
         could also return &lt;CODE&gt;EINVAL&lt;/CODE&gt; if the &lt;VAR&gt;aiocbp&lt;/VAR&gt; parameter does not
         refer to an asynchronous operation whose return status is not yet known.
         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; this
         function is in fact &lt;CODE&gt;aio_error64&lt;/CODE&gt; since the LFS interface
         transparently replaces the normal implementation.
        </synopsis>
    </function>
  </construct>
  <construct id="function-aio_error64" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const struct aiocb64 *aiocbp"/>
      </prototype>
      <headers>
        <header filename = "aio.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;aio_error&lt;/CODE&gt; with the only difference
         that the argument is a reference to a variable of type &lt;CODE&gt;struct
         aiocb64&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; this
         function is available under the name &lt;CODE&gt;aio_error&lt;/CODE&gt; and so
         transparently replaces the interface for small files on 32 bit
         machines.
        </synopsis>
    </function>
  </construct>
  <construct id="function-aio_return" type="function">
    <function returntype="ssize_t">
      <prototype>
        <parameter content="const struct aiocb *aiocbp"/>
      </prototype>
      <headers>
        <header filename = "aio.h"/>
      </headers>
        <synopsis>
        This function can be used to retrieve the return status of the operation
         carried out by the request described in the variable pointed to by
         &lt;VAR&gt;aiocbp&lt;/VAR&gt;.  As long as the error status of this request as returned
         by &lt;CODE&gt;aio_error&lt;/CODE&gt; is &lt;CODE&gt;EINPROGRESS&lt;/CODE&gt; the return of this function is
         undefined.
         &lt;br&gt;&lt;br&gt; Once the request is finished this function can be used exactly once to
         retrieve the return value.  Following calls might lead to undefined
         behavior.  The return value itself is the value which would have been
         returned by the &lt;CODE&gt;read&lt;/CODE&gt;, &lt;CODE&gt;write&lt;/CODE&gt;, or &lt;CODE&gt;fsync&lt;/CODE&gt; call.
         &lt;br&gt;&lt;br&gt; The function can return &lt;CODE&gt;ENOSYS&lt;/CODE&gt; if it is not implemented.  It
         could also return &lt;CODE&gt;EINVAL&lt;/CODE&gt; if the &lt;VAR&gt;aiocbp&lt;/VAR&gt; parameter does not
         refer to an asynchronous operation whose return status is not yet known.
         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; this
         function is in fact &lt;CODE&gt;aio_return64&lt;/CODE&gt; since the LFS interface
         transparently replaces the normal implementation.
        </synopsis>
    </function>
  </construct>
  <construct id="function-aio_return64" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const struct aiocb64 *aiocbp"/>
      </prototype>
      <headers>
        <header filename = "aio.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;aio_return&lt;/CODE&gt; with the only difference
         that the argument is a reference to a variable of type &lt;CODE&gt;struct
         aiocb64&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; this
         function is available under the name &lt;CODE&gt;aio_return&lt;/CODE&gt; and so
         transparently replaces the interface for small files on 32 bit
         machines.
        </synopsis>
    </function>
  </construct>
  <construct id="function-aio_fsync" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int op"/>
        <parameter content="struct aiocb *aiocbp"/>
      </prototype>
      <headers>
        <header filename = "aio.h"/>
      </headers>
        <synopsis>
        Calling this function forces all I/O operations operating queued at the
         time of the function call operating on the file descriptor
         &lt;CODE&gt;aiocbp-&gt;aio_fildes&lt;/CODE&gt; into the synchronized I/O completion state
         .  The &lt;CODE&gt;aio_fsync&lt;/CODE&gt; function returns
         immediately but the notification through the method described in
         &lt;CODE&gt;aiocbp-&gt;aio_sigevent&lt;/CODE&gt; will happen only after all requests for this
         file descriptor have terminated and the file is synchronized.  This also
         means that requests for this very same file descriptor which are queued
         after the synchronization request are not affected.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;op&lt;/VAR&gt; is &lt;CODE&gt;O_DSYNC&lt;/CODE&gt; the synchronization happens as with a call
         to &lt;CODE&gt;fdatasync&lt;/CODE&gt;.  Otherwise &lt;VAR&gt;op&lt;/VAR&gt; should be &lt;CODE&gt;O_SYNC&lt;/CODE&gt; and
         the synchronization happens as with &lt;CODE&gt;fsync&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; As long as the synchronization has not happened, a call to
         &lt;CODE&gt;aio_error&lt;/CODE&gt; with the reference to the object pointed to by
         &lt;VAR&gt;aiocbp&lt;/VAR&gt; returns &lt;CODE&gt;EINPROGRESS&lt;/CODE&gt;.  Once the synchronization is
         done &lt;CODE&gt;aio_error&lt;/CODE&gt; return 0 if the synchronization was not
         successful.  Otherwise the value returned is the value to which the
         &lt;CODE&gt;fsync&lt;/CODE&gt; or &lt;CODE&gt;fdatasync&lt;/CODE&gt; function would have set the
         &lt;CODE&gt;errno&lt;/CODE&gt; variable.  In this case nothing can be assumed about the
         consistency for the data written to this file descriptor.
         &lt;br&gt;&lt;br&gt; The return value of this function is 0 if the request was
         successfully enqueued.  Otherwise the return value is -1 and
         &lt;CODE&gt;errno&lt;/CODE&gt; is set to one of the following values:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EAGAIN&lt;/CODE&gt;
&lt;DD&gt;
         The request could not be enqueued due to temporary lack of resources.
         &lt;LI&gt; EBADF
         The file descriptor &lt;CODE&gt;aiocbp-&gt;aio_fildes&lt;/CODE&gt; is not valid or not open
         for writing.
         &lt;LI&gt; EINVAL
         The implementation does not support I/O synchronization or the &lt;VAR&gt;op&lt;/VAR&gt;
         parameter is other than &lt;CODE&gt;O_DSYNC&lt;/CODE&gt; and &lt;CODE&gt;O_SYNC&lt;/CODE&gt;.
         &lt;LI&gt; ENOSYS
         This function is not implemented.

         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; this
         function is in fact &lt;CODE&gt;aio_fsync64&lt;/CODE&gt; since the LFS interface
         transparently replaces the normal implementation.
        </synopsis>
    </function>
  </construct>
  <construct id="function-aio_fsync64" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int op"/>
        <parameter content="struct aiocb64 *aiocbp"/>
      </prototype>
      <headers>
        <header filename = "aio.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;aio_fsync&lt;/CODE&gt; with the only difference
         that the argument is a reference to a variable of type &lt;CODE&gt;struct
         aiocb64&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; this
         function is available under the name &lt;CODE&gt;aio_fsync&lt;/CODE&gt; and so
         transparently replaces the interface for small files on 32 bit
         machines.
        </synopsis>
    </function>
  </construct>
  <construct id="function-aio_suspend" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const struct aiocb *const list[]"/>
        <parameter content="int nent"/>
        <parameter content="const struct timespec *timeout"/>
      </prototype>
      <headers>
        <header filename = "aio.h"/>
      </headers>
        <synopsis>
        When calling this function, the calling thread is suspended until at
         least one of the requests pointed to by the &lt;VAR&gt;nent&lt;/VAR&gt; elements of the
         array &lt;VAR&gt;list&lt;/VAR&gt; has completed.  If any of the requests has already
         completed at the time &lt;CODE&gt;aio_suspend&lt;/CODE&gt; is called, the function returns
         immediately.  Whether a request has terminated or not is determined by
         comparing the error status of the request with &lt;CODE&gt;EINPROGRESS&lt;/CODE&gt;.  If
         an element of &lt;VAR&gt;list&lt;/VAR&gt; is &lt;CODE&gt;NULL&lt;/CODE&gt;, the entry is simply ignored.
         &lt;br&gt;&lt;br&gt; If no request has finished, the calling process is suspended.  If
         &lt;VAR&gt;timeout&lt;/VAR&gt; is &lt;CODE&gt;NULL&lt;/CODE&gt;, the process is not woken until a request
         has finished.  If &lt;VAR&gt;timeout&lt;/VAR&gt; is not &lt;CODE&gt;NULL&lt;/CODE&gt;, the process remains
         suspended at least as long as specified in &lt;VAR&gt;timeout&lt;/VAR&gt;.  In this case,
         &lt;CODE&gt;aio_suspend&lt;/CODE&gt; returns with an error.
         &lt;br&gt;&lt;br&gt; The return value of the function is 0 if one or more requests
         from the &lt;VAR&gt;list&lt;/VAR&gt; have terminated.  Otherwise the function returns
         -1 and &lt;CODE&gt;errno&lt;/CODE&gt; is set to one of the following values:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EAGAIN&lt;/CODE&gt;
&lt;DD&gt;
         None of the requests from the &lt;VAR&gt;list&lt;/VAR&gt; completed in the time specified
         by &lt;VAR&gt;timeout&lt;/VAR&gt;.
         &lt;LI&gt; EINTR
         A signal interrupted the &lt;CODE&gt;aio_suspend&lt;/CODE&gt; function.  This signal might
         also be sent by the AIO implementation while signalling the termination
         of one of the requests.
         &lt;LI&gt; ENOSYS
         The &lt;CODE&gt;aio_suspend&lt;/CODE&gt; function is not implemented.

         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; this
         function is in fact &lt;CODE&gt;aio_suspend64&lt;/CODE&gt; since the LFS interface
         transparently replaces the normal implementation.
        </synopsis>
    </function>
  </construct>
  <construct id="function-aio_suspend64" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const struct aiocb64 *const list[]"/>
        <parameter content="int nent"/>
        <parameter content="const struct timespec *timeout"/>
      </prototype>
      <headers>
        <header filename = "aio.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;aio_suspend&lt;/CODE&gt; with the only difference
         that the argument is a reference to a variable of type &lt;CODE&gt;struct
         aiocb64&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; this
         function is available under the name &lt;CODE&gt;aio_suspend&lt;/CODE&gt; and so
         transparently replaces the interface for small files on 32 bit
         machines.
        </synopsis>
    </function>
  </construct>
  <construct id="function-aio_cancel" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int fildes"/>
        <parameter content="struct aiocb *aiocbp"/>
      </prototype>
      <headers>
        <header filename = "aio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;aio_cancel&lt;/CODE&gt; function can be used to cancel one or more
         outstanding requests.  If the &lt;VAR&gt;aiocbp&lt;/VAR&gt; parameter is &lt;CODE&gt;NULL&lt;/CODE&gt;, the
         function tries to cancel all of the outstanding requests which would process
         the file descriptor &lt;VAR&gt;fildes&lt;/VAR&gt; (i.e., whose &lt;CODE&gt;aio_fildes&lt;/CODE&gt; member
         is &lt;VAR&gt;fildes&lt;/VAR&gt;).  If &lt;VAR&gt;aiocbp&lt;/VAR&gt; is not &lt;CODE&gt;NULL&lt;/CODE&gt;, &lt;CODE&gt;aio_cancel&lt;/CODE&gt;
         attempts to cancel the specific request pointed to by &lt;VAR&gt;aiocbp&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; For requests which were successfully canceled, the normal notification
         about the termination of the request should take place.  I.e., depending
         on the &lt;CODE&gt;struct sigevent&lt;/CODE&gt; object which controls this, nothing
         happens, a signal is sent or a thread is started.  If the request cannot
         be canceled, it terminates the usual way after performing the operation.
         &lt;br&gt;&lt;br&gt; After a request is successfully canceled, a call to &lt;CODE&gt;aio_error&lt;/CODE&gt; with
         a reference to this request as the parameter will return
         &lt;CODE&gt;ECANCELED&lt;/CODE&gt; and a call to &lt;CODE&gt;aio_return&lt;/CODE&gt; will return -1.
         If the request wasn't canceled and is still running the error status is
         still &lt;CODE&gt;EINPROGRESS&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The return value of the function is &lt;CODE&gt;AIO_CANCELED&lt;/CODE&gt; if there were
         requests which haven't terminated and which were successfully canceled.
         If there is one or more requests left which couldn't be canceled, the
         return value is &lt;CODE&gt;AIO_NOTCANCELED&lt;/CODE&gt;.  In this case &lt;CODE&gt;aio_error&lt;/CODE&gt;
         must be used to find out which of the, perhaps multiple, requests (in
         &lt;VAR&gt;aiocbp&lt;/VAR&gt; is &lt;CODE&gt;NULL&lt;/CODE&gt;) weren't successfully canceled.  If all
         requests already terminated at the time &lt;CODE&gt;aio_cancel&lt;/CODE&gt; is called the
         return value is &lt;CODE&gt;AIO_ALLDONE&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; If an error occurred during the execution of &lt;CODE&gt;aio_cancel&lt;/CODE&gt; the
         function returns -1 and sets &lt;CODE&gt;errno&lt;/CODE&gt; to one of the following
         values.
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The file descriptor &lt;VAR&gt;fildes&lt;/VAR&gt; is not valid.
         &lt;LI&gt; ENOSYS
         &lt;CODE&gt;aio_cancel&lt;/CODE&gt; is not implemented.

         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt;, this
         function is in fact &lt;CODE&gt;aio_cancel64&lt;/CODE&gt; since the LFS interface
         transparently replaces the normal implementation.
        </synopsis>
    </function>
  </construct>
  <construct id="function-aio_cancel64" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int fildes"/>
        <parameter content="struct aiocb64 *aiocbp"/>
      </prototype>
      <headers>
        <header filename = "aio.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;aio_cancel&lt;/CODE&gt; with the only difference
         that the argument is a reference to a variable of type &lt;CODE&gt;struct
         aiocb64&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt;, this
         function is available under the name &lt;CODE&gt;aio_cancel&lt;/CODE&gt; and so
         transparently replaces the interface for small files on 32 bit
         machines.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-aioinit" type="struct">
    <structure>
        <synopsis>
        This data type is used to pass the configuration or tunable parameters
         to the implementation.  The program has to initialize the members of
         this struct and pass it to the implementation using the &lt;CODE&gt;aio_init&lt;/CODE&gt;
         function.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="int aio_threads">
            <synopsis>
            This member specifies the maximal number of threads which may be used
             at any one time.
            </synopsis>
        </element>
        <element content="int aio_num">
            <synopsis>
            This number provides an estimate on the maximal number of simultaneously
             enqueued requests.
            </synopsis>
        </element>
        <element content="int aio_locks">
            <synopsis>
            Unused.
            </synopsis>
        </element>
        <element content="int aio_usedba">
            <synopsis>
            Unused.
            </synopsis>
        </element>
        <element content="int aio_debug">
            <synopsis>
            Unused.
            </synopsis>
        </element>
        <element content="int aio_numusers">
            <synopsis>
            Unused.
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-aio_init" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="const struct aioinit *init"/>
      </prototype>
      <headers>
        <header filename = "aio.h"/>
      </headers>
        <synopsis>
        This function must be called before any other AIO function.  Calling it
         is completely voluntary, as it is only meant to help the AIO
         implementation perform better.
         &lt;br&gt;&lt;br&gt; Before calling the &lt;CODE&gt;aio_init&lt;/CODE&gt;, function the members of a variable of
         type &lt;CODE&gt;struct aioinit&lt;/CODE&gt; must be initialized.  Then a reference to
         this variable is passed as the parameter to &lt;CODE&gt;aio_init&lt;/CODE&gt; which itself
         may or may not pay attention to the hints.
         &lt;br&gt;&lt;br&gt; The function has no return value and no error cases are defined.  It is
         a extension which follows a proposal from the SGI implementation in
         Irix 6.  It is not covered by POSIX.1b or Unix98.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fcntl" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="int command"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "fcntl.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fcntl&lt;/CODE&gt; function performs the operation specified by
         &lt;VAR&gt;command&lt;/VAR&gt; on the file descriptor &lt;VAR&gt;filedes&lt;/VAR&gt;.  Some commands
         require additional arguments to be supplied.  These additional arguments
         and the return value and error conditions are given in the detailed
         descriptions of the individual commands.
         &lt;br&gt;&lt;br&gt; Briefly, here is a list of what the various commands are.
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;F_DUPFD&lt;/CODE&gt;
&lt;DD&gt;
         Duplicate the file descriptor (return another file descriptor pointing
         to the same open file).  .
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; F_GETFD
         Get flags associated with the file descriptor.  .
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; F_SETFD
         Set flags associated with the file descriptor.  .
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; F_GETFL
         Get flags associated with the open file.  .
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; F_SETFL
         Set flags associated with the open file.  .
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; F_GETLK
         Get a file lock.  .
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; F_SETLK
         Set or clear a file lock.  .
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; F_SETLKW
         Like &lt;CODE&gt;F_SETLK&lt;/CODE&gt;, but wait for completion.  .
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; F_GETOWN
         Get process or process group ID to receive &lt;CODE&gt;SIGIO&lt;/CODE&gt; signals.
         .
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; F_SETOWN
         Set process or process group ID to receive &lt;CODE&gt;SIGIO&lt;/CODE&gt; signals.
         .

         &lt;br&gt;&lt;br&gt; This function is a cancellation point in multi-threaded programs.  This
         is a problem if the thread allocates some resources (like memory, file
         descriptors, semaphores or whatever) at the time &lt;CODE&gt;fcntl&lt;/CODE&gt; is
         called.  If the thread gets canceled these resources stay allocated
         until the program ends.  To avoid this calls to &lt;CODE&gt;fcntl&lt;/CODE&gt; should be
         protected using cancellation handlers.
        </synopsis>
    </function>
  </construct>
  <construct id="function-dup" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int old"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        This function copies descriptor &lt;VAR&gt;old&lt;/VAR&gt; to the first available
         descriptor number (the first number not currently open).  It is
         equivalent to &lt;CODE&gt;fcntl (&lt;VAR&gt;old&lt;/VAR&gt;, F_DUPFD, 0)&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-dup2" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int old"/>
        <parameter content="int new"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        This function copies the descriptor &lt;VAR&gt;old&lt;/VAR&gt; to descriptor number
         &lt;VAR&gt;new&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;old&lt;/VAR&gt; is an invalid descriptor, then &lt;CODE&gt;dup2&lt;/CODE&gt; does nothing; it
         does not close &lt;VAR&gt;new&lt;/VAR&gt;.  Otherwise, the new duplicate of &lt;VAR&gt;old&lt;/VAR&gt;
         replaces any previous meaning of descriptor &lt;VAR&gt;new&lt;/VAR&gt;, as if &lt;VAR&gt;new&lt;/VAR&gt;
         were closed first.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;old&lt;/VAR&gt; and &lt;VAR&gt;new&lt;/VAR&gt; are different numbers, and &lt;VAR&gt;old&lt;/VAR&gt; is a
         valid descriptor number, then &lt;CODE&gt;dup2&lt;/CODE&gt; is equivalent to:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         close (&lt;VAR&gt;new&lt;/VAR&gt;);&lt;br&gt;
         fcntl (&lt;VAR&gt;old&lt;/VAR&gt;, F_DUPFD, &lt;VAR&gt;new&lt;/VAR&gt;)&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; However, &lt;CODE&gt;dup2&lt;/CODE&gt; does this atomically; there is no instant in the
         middle of calling &lt;CODE&gt;dup2&lt;/CODE&gt; at which &lt;VAR&gt;new&lt;/VAR&gt; is closed and not yet a
         duplicate of &lt;VAR&gt;old&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-flock" type="struct">
    <structure>
        <synopsis>
        This structure is used with the &lt;CODE&gt;fcntl&lt;/CODE&gt; function to describe a file
         lock.  It has these members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="short int l_type">
            <synopsis>
            Specifies the type of the lock; one of &lt;CODE&gt;F_RDLCK&lt;/CODE&gt;, &lt;CODE&gt;F_WRLCK&lt;/CODE&gt;, or
             &lt;CODE&gt;F_UNLCK&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="short int l_whence">
            <synopsis>
            This corresponds to the &lt;VAR&gt;whence&lt;/VAR&gt; argument to &lt;CODE&gt;fseek&lt;/CODE&gt; or
             &lt;CODE&gt;lseek&lt;/CODE&gt;, and specifies what the offset is relative to.  Its value
             can be one of &lt;CODE&gt;SEEK_SET&lt;/CODE&gt;, &lt;CODE&gt;SEEK_CUR&lt;/CODE&gt;, or &lt;CODE&gt;SEEK_END&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="off_t l_start">
            <synopsis>
            This specifies the offset of the start of the region to which the lock
             applies, and is given in bytes relative to the point specified by
             &lt;CODE&gt;l_whence&lt;/CODE&gt; member.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="off_t l_len">
            <synopsis>
            This specifies the length of the region to be locked.  A value of
             &lt;CODE&gt;0&lt;/CODE&gt; is treated specially; it means the region extends to the end of
             the file.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-ioctl" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="int command"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "fcntl.h"/>
        <header filename = "sys/ioctl.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;ioctl&lt;/CODE&gt; function performs the generic I/O operation
         &lt;VAR&gt;command&lt;/VAR&gt; on &lt;VAR&gt;filedes&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; A third argument is usually present, either a single number or a pointer
         to a structure.  The meaning of this argument, the returned value, and
         any error codes depends upon the command used.  Often -1 is
         returned for a failure.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-strlen" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="const char *s"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;strlen&lt;/CODE&gt; function returns the length of the null-terminated
         string &lt;VAR&gt;s&lt;/VAR&gt; in bytes.  (In other words, it returns the offset of the
         terminating null character within the array.)
         &lt;br&gt;&lt;br&gt; For example,
         &lt;pre&gt;&lt;br&gt;
         strlen ("hello, world")&lt;br&gt;
              12&lt;br&gt;
         &lt;/pre&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; When applied to a character array, the &lt;CODE&gt;strlen&lt;/CODE&gt; function returns&lt;br&gt;
         the length of the string stored there, not its allocated size.  You can&lt;br&gt;
         get the allocated size of the character array that holds a string using&lt;br&gt;
         the &lt;CODE&gt;sizeof&lt;/CODE&gt; operator:&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         char string[32] = "hello, world";&lt;br&gt;
         sizeof (string)&lt;br&gt;
              32&lt;br&gt;
         strlen (string)&lt;br&gt;
              12&lt;br&gt;
         &lt;/pre&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; But beware, this will not work unless &lt;VAR&gt;string&lt;/VAR&gt; is the character&lt;br&gt;
         array itself, not a pointer to it.  For example:&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         char string[32] = "hello, world";&lt;br&gt;
         char *ptr = string;&lt;br&gt;
         sizeof (string)&lt;br&gt;
              32&lt;br&gt;
         sizeof (ptr)&lt;br&gt;
              4  /* (on a machine with 4 byte pointers) */&lt;br&gt;
         &lt;/pre&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; This is an easy mistake to make when you are working with functions that&lt;br&gt;
         take string arguments; those arguments are always pointers, not arrays.&lt;br&gt;
         &lt;br&gt;&lt;br&gt; It must also be noted that for multibyte encoded strings the return&lt;br&gt;
         value does not have to correspond to the number of characters in the&lt;br&gt;
         string.  To get this value the string can be converted to wide&lt;br&gt;
         characters and &lt;CODE&gt;wcslen&lt;/CODE&gt; can be used or something like the following&lt;br&gt;
         code can be used:&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         /* The input is in &lt;CODE&gt;string&lt;/CODE&gt;.&lt;br&gt;
            The length is expected in &lt;CODE&gt;n&lt;/CODE&gt;.  */&lt;br&gt;
         {&lt;br&gt;
           mbstate_t t;&lt;br&gt;
           char *scopy = string;&lt;br&gt;
           /* In initial state.  */&lt;br&gt;
           memset (&amp;t, '\0', sizeof (t));&lt;br&gt;
           /* Determine number of characters.  */&lt;br&gt;
           n = mbsrtowcs (NULL, &amp;scopy, strlen (scopy), &amp;t);&lt;br&gt;
         }&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; This is cumbersome to do so if the number of characters (as opposed to
         bytes) is needed often it is better to work with wide characters.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcslen" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="const wchar_t *ws"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wcslen&lt;/CODE&gt; function is the wide character equivalent to
         &lt;CODE&gt;strlen&lt;/CODE&gt;.  The return value is the number of wide characters in the
         wide character string pointed to by &lt;VAR&gt;ws&lt;/VAR&gt; (this is also the offset of
         the terminating null wide character of &lt;VAR&gt;ws&lt;/VAR&gt;).
         &lt;br&gt;&lt;br&gt; Since there are no multi wide character sequences making up one
         character the return value is not only the offset in the array, it is
         also the number of wide characters.
         &lt;br&gt;&lt;br&gt; This function was introduced in Amendment 1 to ISO C90.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strnlen" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="const char *s"/>
        <parameter content="size_t maxlen"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;strnlen&lt;/CODE&gt; function returns the length of the string &lt;VAR&gt;s&lt;/VAR&gt; in
         bytes if this length is smaller than &lt;VAR&gt;maxlen&lt;/VAR&gt; bytes.  Otherwise it
         returns &lt;VAR&gt;maxlen&lt;/VAR&gt;.  Therefore this function is equivalent to
         &lt;CODE&gt;(strlen (&lt;VAR&gt;s&lt;/VAR&gt;) &lt; n ? strlen (&lt;VAR&gt;s&lt;/VAR&gt;) : &lt;VAR&gt;maxlen&lt;/VAR&gt;)&lt;/CODE&gt; but it
         is more efficient and works even if the string &lt;VAR&gt;s&lt;/VAR&gt; is not
         null-terminated.
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         char string[32] = "hello, world";&lt;br&gt;
         strnlen (string, 32)&lt;br&gt;
              12&lt;br&gt;
         strnlen (string, 5)&lt;br&gt;
              5&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; This function is a GNU extension and is declared in &lt;TT&gt;string.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcsnlen" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="const wchar_t *ws"/>
        <parameter content="size_t maxlen"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;wcsnlen&lt;/CODE&gt; is the wide character equivalent to &lt;CODE&gt;strnlen&lt;/CODE&gt;.  The
         &lt;VAR&gt;maxlen&lt;/VAR&gt; parameter specifies the maximum number of wide characters.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension and is declared in &lt;TT&gt;wchar.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-memcpy" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="void *restrict to"/>
        <parameter content="const void *restrict from"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;memcpy&lt;/CODE&gt; function copies &lt;VAR&gt;size&lt;/VAR&gt; bytes from the object
         beginning at &lt;VAR&gt;from&lt;/VAR&gt; into the object beginning at &lt;VAR&gt;to&lt;/VAR&gt;.  The
         behavior of this function is undefined if the two arrays &lt;VAR&gt;to&lt;/VAR&gt; and
         &lt;VAR&gt;from&lt;/VAR&gt; overlap; use &lt;CODE&gt;memmove&lt;/CODE&gt; instead if overlapping is possible.
         &lt;br&gt;&lt;br&gt; The value returned by &lt;CODE&gt;memcpy&lt;/CODE&gt; is the value of &lt;VAR&gt;to&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; Here is an example of how you might use &lt;CODE&gt;memcpy&lt;/CODE&gt; to copy the
         contents of an array:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         struct foo *oldarray, *newarray;&lt;br&gt;
         int arraysize;&lt;br&gt;
         &lt;small&gt;...&lt;/small&gt;&lt;br&gt;
         memcpy (new, old, arraysize * sizeof (struct foo));&lt;br&gt;
         &lt;/pre&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-wmemcpy" type="function">
    <function returntype="wchar_t *">
      <prototype>
        <parameter content="wchar_t *restrict wto"/>
        <parameter content="const wchar_t *restrict wfrom"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wmemcpy&lt;/CODE&gt; function copies &lt;VAR&gt;size&lt;/VAR&gt; wide characters from the object
         beginning at &lt;VAR&gt;wfrom&lt;/VAR&gt; into the object beginning at &lt;VAR&gt;wto&lt;/VAR&gt;.  The
         behavior of this function is undefined if the two arrays &lt;VAR&gt;wto&lt;/VAR&gt; and
         &lt;VAR&gt;wfrom&lt;/VAR&gt; overlap; use &lt;CODE&gt;wmemmove&lt;/CODE&gt; instead if overlapping is possible.
         &lt;br&gt;&lt;br&gt; The following is a possible implementation of &lt;CODE&gt;wmemcpy&lt;/CODE&gt; but there
         are more optimizations possible.
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         wchar_t *&lt;br&gt;
         wmemcpy (wchar_t *restrict wto, const wchar_t *restrict wfrom,&lt;br&gt;
                  size_t size)&lt;br&gt;
         {&lt;br&gt;
           return (wchar_t *) memcpy (wto, wfrom, size * sizeof (wchar_t));&lt;br&gt;
         }&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; The value returned by &lt;CODE&gt;wmemcpy&lt;/CODE&gt; is the value of &lt;VAR&gt;wto&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; This function was introduced in Amendment 1 to ISO C90.
        </synopsis>
    </function>
  </construct>
  <construct id="function-mempcpy" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="void *restrict to"/>
        <parameter content="const void *restrict from"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;mempcpy&lt;/CODE&gt; function is nearly identical to the &lt;CODE&gt;memcpy&lt;/CODE&gt;
         function.  It copies &lt;VAR&gt;size&lt;/VAR&gt; bytes from the object beginning at
         &lt;CODE&gt;from&lt;/CODE&gt; into the object pointed to by &lt;VAR&gt;to&lt;/VAR&gt;.  But instead of
         returning the value of &lt;VAR&gt;to&lt;/VAR&gt; it returns a pointer to the byte
         following the last written byte in the object beginning at &lt;VAR&gt;to&lt;/VAR&gt;.
         I.e., the value is &lt;CODE&gt;((void *) ((char *) &lt;VAR&gt;to&lt;/VAR&gt; + &lt;VAR&gt;size&lt;/VAR&gt;))&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This function is useful in situations where a number of objects shall be
         copied to consecutive memory positions.
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         void *&lt;br&gt;
         combine (void *o1, size_t s1, void *o2, size_t s2)&lt;br&gt;
         {&lt;br&gt;
           void *result = malloc (s1 + s2);&lt;br&gt;
           if (result != NULL)&lt;br&gt;
             mempcpy (mempcpy (result, o1, s1), o2, s2);&lt;br&gt;
           return result;&lt;br&gt;
         }&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wmempcpy" type="function">
    <function returntype="wchar_t *">
      <prototype>
        <parameter content="wchar_t *restrict wto"/>
        <parameter content="const wchar_t *restrict wfrom"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wmempcpy&lt;/CODE&gt; function is nearly identical to the &lt;CODE&gt;wmemcpy&lt;/CODE&gt;
         function.  It copies &lt;VAR&gt;size&lt;/VAR&gt; wide characters from the object
         beginning at &lt;CODE&gt;wfrom&lt;/CODE&gt; into the object pointed to by &lt;VAR&gt;wto&lt;/VAR&gt;.  But
         instead of returning the value of &lt;VAR&gt;wto&lt;/VAR&gt; it returns a pointer to the
         wide character following the last written wide character in the object
         beginning at &lt;VAR&gt;wto&lt;/VAR&gt;.  I.e., the value is &lt;CODE&gt;&lt;VAR&gt;wto&lt;/VAR&gt; + &lt;VAR&gt;size&lt;/VAR&gt;&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This function is useful in situations where a number of objects shall be
         copied to consecutive memory positions.
         &lt;br&gt;&lt;br&gt; The following is a possible implementation of &lt;CODE&gt;wmemcpy&lt;/CODE&gt; but there
         are more optimizations possible.
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         wchar_t *&lt;br&gt;
         wmempcpy (wchar_t *restrict wto, const wchar_t *restrict wfrom,&lt;br&gt;
                   size_t size)&lt;br&gt;
         {&lt;br&gt;
           return (wchar_t *) mempcpy (wto, wfrom, size * sizeof (wchar_t));&lt;br&gt;
         }&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-memmove" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="void *to"/>
        <parameter content="const void *from"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;memmove&lt;/CODE&gt; copies the &lt;VAR&gt;size&lt;/VAR&gt; bytes at &lt;VAR&gt;from&lt;/VAR&gt; into the
         &lt;VAR&gt;size&lt;/VAR&gt; bytes at &lt;VAR&gt;to&lt;/VAR&gt;, even if those two blocks of space
         overlap.  In the case of overlap, &lt;CODE&gt;memmove&lt;/CODE&gt; is careful to copy the
         original values of the bytes in the block at &lt;VAR&gt;from&lt;/VAR&gt;, including those
         bytes which also belong to the block at &lt;VAR&gt;to&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The value returned by &lt;CODE&gt;memmove&lt;/CODE&gt; is the value of &lt;VAR&gt;to&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wmemmove" type="function">
    <function returntype="wchar_t *">
      <prototype>
        <parameter content="wchar *wto"/>
        <parameter content="const wchar_t *wfrom"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;wmemmove&lt;/CODE&gt; copies the &lt;VAR&gt;size&lt;/VAR&gt; wide characters at &lt;VAR&gt;wfrom&lt;/VAR&gt;
         into the &lt;VAR&gt;size&lt;/VAR&gt; wide characters at &lt;VAR&gt;wto&lt;/VAR&gt;, even if those two
         blocks of space overlap.  In the case of overlap, &lt;CODE&gt;memmove&lt;/CODE&gt; is
         careful to copy the original values of the wide characters in the block
         at &lt;VAR&gt;wfrom&lt;/VAR&gt;, including those wide characters which also belong to the
         block at &lt;VAR&gt;wto&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The following is a possible implementation of &lt;CODE&gt;wmemcpy&lt;/CODE&gt; but there
         are more optimizations possible.
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         wchar_t *&lt;br&gt;
         wmempcpy (wchar_t *restrict wto, const wchar_t *restrict wfrom,&lt;br&gt;
                   size_t size)&lt;br&gt;
         {&lt;br&gt;
           return (wchar_t *) mempcpy (wto, wfrom, size * sizeof (wchar_t));&lt;br&gt;
         }&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; The value returned by &lt;CODE&gt;wmemmove&lt;/CODE&gt; is the value of &lt;VAR&gt;wto&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-memccpy" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="void *restrict to"/>
        <parameter content="const void *restrict from"/>
        <parameter content="int c"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        This function copies no more than &lt;VAR&gt;size&lt;/VAR&gt; bytes from &lt;VAR&gt;from&lt;/VAR&gt; to
         &lt;VAR&gt;to&lt;/VAR&gt;, stopping if a byte matching &lt;VAR&gt;c&lt;/VAR&gt; is found.  The return
         value is a pointer into &lt;VAR&gt;to&lt;/VAR&gt; one byte past where &lt;VAR&gt;c&lt;/VAR&gt; was copied,
         or a null pointer if no byte matching &lt;VAR&gt;c&lt;/VAR&gt; appeared in the first
         &lt;VAR&gt;size&lt;/VAR&gt; bytes of &lt;VAR&gt;from&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-memset" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="void *block"/>
        <parameter content="int c"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        This function copies the value of &lt;VAR&gt;c&lt;/VAR&gt; (converted to an
         &lt;CODE&gt;unsigned char&lt;/CODE&gt;) into each of the first &lt;VAR&gt;size&lt;/VAR&gt; bytes of the
         object beginning at &lt;VAR&gt;block&lt;/VAR&gt;.  It returns the value of &lt;VAR&gt;block&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wmemset" type="function">
    <function returntype="wchar_t *">
      <prototype>
        <parameter content="wchar_t *block"/>
        <parameter content="wchar_t wc"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        This function copies the value of &lt;VAR&gt;wc&lt;/VAR&gt; into each of the first
         &lt;VAR&gt;size&lt;/VAR&gt; wide characters of the object beginning at &lt;VAR&gt;block&lt;/VAR&gt;.  It
         returns the value of &lt;VAR&gt;block&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strcpy" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="char *restrict to"/>
        <parameter content="const char *restrict from"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        This copies characters from the string &lt;VAR&gt;from&lt;/VAR&gt; (up to and including
         the terminating null character) into the string &lt;VAR&gt;to&lt;/VAR&gt;.  Like
         &lt;CODE&gt;memcpy&lt;/CODE&gt;, this function has undefined results if the strings
         overlap.  The return value is the value of &lt;VAR&gt;to&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcscpy" type="function">
    <function returntype="wchar_t *">
      <prototype>
        <parameter content="wchar_t *restrict wto"/>
        <parameter content="const wchar_t *restrict wfrom"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        This copies wide characters from the string &lt;VAR&gt;wfrom&lt;/VAR&gt; (up to and
         including the terminating null wide character) into the string
         &lt;VAR&gt;wto&lt;/VAR&gt;.  Like &lt;CODE&gt;wmemcpy&lt;/CODE&gt;, this function has undefined results if
         the strings overlap.  The return value is the value of &lt;VAR&gt;wto&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strncpy" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="char *restrict to"/>
        <parameter content="const char *restrict from"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;strcpy&lt;/CODE&gt; but always copies exactly
         &lt;VAR&gt;size&lt;/VAR&gt; characters into &lt;VAR&gt;to&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If the length of &lt;VAR&gt;from&lt;/VAR&gt; is more than &lt;VAR&gt;size&lt;/VAR&gt;, then &lt;CODE&gt;strncpy&lt;/CODE&gt;
         copies just the first &lt;VAR&gt;size&lt;/VAR&gt; characters.  Note that in this case
         there is no null terminator written into &lt;VAR&gt;to&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If the length of &lt;VAR&gt;from&lt;/VAR&gt; is less than &lt;VAR&gt;size&lt;/VAR&gt;, then &lt;CODE&gt;strncpy&lt;/CODE&gt;
         copies all of &lt;VAR&gt;from&lt;/VAR&gt;, followed by enough null characters to add up
         to &lt;VAR&gt;size&lt;/VAR&gt; characters in all.  This behavior is rarely useful, but it
         is specified by the ISO C standard.
         &lt;br&gt;&lt;br&gt; The behavior of &lt;CODE&gt;strncpy&lt;/CODE&gt; is undefined if the strings overlap.
         &lt;br&gt;&lt;br&gt; Using &lt;CODE&gt;strncpy&lt;/CODE&gt; as opposed to &lt;CODE&gt;strcpy&lt;/CODE&gt; is a way to avoid bugs
         relating to writing past the end of the allocated space for &lt;VAR&gt;to&lt;/VAR&gt;.
         However, it can also make your program much slower in one common case:
         copying a string which is probably small into a potentially large buffer.
         In this case, &lt;VAR&gt;size&lt;/VAR&gt; may be large, and when it is, &lt;CODE&gt;strncpy&lt;/CODE&gt; will
         waste a considerable amount of time copying null characters.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcsncpy" type="function">
    <function returntype="wchar_t *">
      <prototype>
        <parameter content="wchar_t *restrict wto"/>
        <parameter content="const wchar_t *restrict wfrom"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;wcscpy&lt;/CODE&gt; but always copies exactly
         &lt;VAR&gt;size&lt;/VAR&gt; wide characters into &lt;VAR&gt;wto&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If the length of &lt;VAR&gt;wfrom&lt;/VAR&gt; is more than &lt;VAR&gt;size&lt;/VAR&gt;, then
         &lt;CODE&gt;wcsncpy&lt;/CODE&gt; copies just the first &lt;VAR&gt;size&lt;/VAR&gt; wide characters.  Note
         that in this case there is no null terminator written into &lt;VAR&gt;wto&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If the length of &lt;VAR&gt;wfrom&lt;/VAR&gt; is less than &lt;VAR&gt;size&lt;/VAR&gt;, then
         &lt;CODE&gt;wcsncpy&lt;/CODE&gt; copies all of &lt;VAR&gt;wfrom&lt;/VAR&gt;, followed by enough null wide
         characters to add up to &lt;VAR&gt;size&lt;/VAR&gt; wide characters in all.  This
         behavior is rarely useful, but it is specified by the ISO C
         standard.
         &lt;br&gt;&lt;br&gt; The behavior of &lt;CODE&gt;wcsncpy&lt;/CODE&gt; is undefined if the strings overlap.
         &lt;br&gt;&lt;br&gt; Using &lt;CODE&gt;wcsncpy&lt;/CODE&gt; as opposed to &lt;CODE&gt;wcscpy&lt;/CODE&gt; is a way to avoid bugs
         relating to writing past the end of the allocated space for &lt;VAR&gt;wto&lt;/VAR&gt;.
         However, it can also make your program much slower in one common case:
         copying a string which is probably small into a potentially large buffer.
         In this case, &lt;VAR&gt;size&lt;/VAR&gt; may be large, and when it is, &lt;CODE&gt;wcsncpy&lt;/CODE&gt; will
         waste a considerable amount of time copying null wide characters.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strdup" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *s"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        This function copies the null-terminated string &lt;VAR&gt;s&lt;/VAR&gt; into a newly
         allocated string.  The string is allocated using &lt;CODE&gt;malloc&lt;/CODE&gt;; see
         Unconstrained Allocation.  If &lt;CODE&gt;malloc&lt;/CODE&gt; cannot allocate space
         for the new string, &lt;CODE&gt;strdup&lt;/CODE&gt; returns a null pointer.  Otherwise it
         returns a pointer to the new string.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcsdup" type="function">
    <function returntype="wchar_t *">
      <prototype>
        <parameter content="const wchar_t *ws"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        This function copies the null-terminated wide character string &lt;VAR&gt;ws&lt;/VAR&gt;
         into a newly allocated string.  The string is allocated using
         &lt;CODE&gt;malloc&lt;/CODE&gt;; see Unconstrained Allocation.  If &lt;CODE&gt;malloc&lt;/CODE&gt;
         cannot allocate space for the new string, &lt;CODE&gt;wcsdup&lt;/CODE&gt; returns a null
         pointer.  Otherwise it returns a pointer to the new wide character
         string.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strndup" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *s"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;strdup&lt;/CODE&gt; but always copies at most
         &lt;VAR&gt;size&lt;/VAR&gt; characters into the newly allocated string.
         &lt;br&gt;&lt;br&gt; If the length of &lt;VAR&gt;s&lt;/VAR&gt; is more than &lt;VAR&gt;size&lt;/VAR&gt;, then &lt;CODE&gt;strndup&lt;/CODE&gt;
         copies just the first &lt;VAR&gt;size&lt;/VAR&gt; characters and adds a closing null
         terminator.  Otherwise all characters are copied and the string is
         terminated.
         &lt;br&gt;&lt;br&gt; This function is different to &lt;CODE&gt;strncpy&lt;/CODE&gt; in that it always
         terminates the destination string.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;strndup&lt;/CODE&gt; is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-stpcpy" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="char *restrict to"/>
        <parameter content="const char *restrict from"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        This function is like &lt;CODE&gt;strcpy&lt;/CODE&gt;, except that it returns a pointer to
         the end of the string &lt;VAR&gt;to&lt;/VAR&gt; (that is, the address of the terminating
         null character &lt;CODE&gt;to + strlen (from)&lt;/CODE&gt;) rather than the beginning.
         &lt;br&gt;&lt;br&gt; For example, this program uses &lt;CODE&gt;stpcpy&lt;/CODE&gt; to concatenate &lt;samp&gt;foo&lt;/samp&gt;
         and &lt;samp&gt;bar&lt;/samp&gt; to produce &lt;samp&gt;foobar&lt;/samp&gt;, which it then prints.
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         #include &amp;lt;string.h&amp;gt;&lt;br&gt;
         #include &amp;lt;stdio.h&amp;gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; int&lt;br&gt;
         main (void)&lt;br&gt;
         {&lt;br&gt;
           char buffer[10];&lt;br&gt;
           char *to = buffer;&lt;br&gt;
           to = stpcpy (to, "foo");&lt;br&gt;
           to = stpcpy (to, "bar");&lt;br&gt;
           puts (buffer);&lt;br&gt;
           return 0;&lt;br&gt;
         }&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; This function is not part of the ISO or POSIX standards, and is not
         customary on Unix systems, but we did not invent it either.  Perhaps it
         comes from MS-DOG.
         &lt;br&gt;&lt;br&gt; Its behavior is undefined if the strings overlap.  The function is
         declared in &lt;TT&gt;string.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcpcpy" type="function">
    <function returntype="wchar_t *">
      <prototype>
        <parameter content="wchar_t *restrict wto"/>
        <parameter content="const wchar_t *restrict wfrom"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        This function is like &lt;CODE&gt;wcscpy&lt;/CODE&gt;, except that it returns a pointer to
         the end of the string &lt;VAR&gt;wto&lt;/VAR&gt; (that is, the address of the terminating
         null character &lt;CODE&gt;wto + strlen (wfrom)&lt;/CODE&gt;) rather than the beginning.
         &lt;br&gt;&lt;br&gt; This function is not part of ISO or POSIX but was found useful while
         developing the GNU C Library itself.
         &lt;br&gt;&lt;br&gt; The behavior of &lt;CODE&gt;wcpcpy&lt;/CODE&gt; is undefined if the strings overlap.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;wcpcpy&lt;/CODE&gt; is a GNU extension and is declared in &lt;TT&gt;wchar.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-stpncpy" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="char *restrict to"/>
        <parameter content="const char *restrict from"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;stpcpy&lt;/CODE&gt; but copies always exactly
         &lt;VAR&gt;size&lt;/VAR&gt; characters into &lt;VAR&gt;to&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If the length of &lt;VAR&gt;from&lt;/VAR&gt; is more then &lt;VAR&gt;size&lt;/VAR&gt;, then &lt;CODE&gt;stpncpy&lt;/CODE&gt;
         copies just the first &lt;VAR&gt;size&lt;/VAR&gt; characters and returns a pointer to the
         character directly following the one which was copied last.  Note that in
         this case there is no null terminator written into &lt;VAR&gt;to&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If the length of &lt;VAR&gt;from&lt;/VAR&gt; is less than &lt;VAR&gt;size&lt;/VAR&gt;, then &lt;CODE&gt;stpncpy&lt;/CODE&gt;
         copies all of &lt;VAR&gt;from&lt;/VAR&gt;, followed by enough null characters to add up
         to &lt;VAR&gt;size&lt;/VAR&gt; characters in all.  This behavior is rarely useful, but it
         is implemented to be useful in contexts where this behavior of the
         &lt;CODE&gt;strncpy&lt;/CODE&gt; is used.  &lt;CODE&gt;stpncpy&lt;/CODE&gt; returns a pointer to the
         &lt;EM&gt;first&lt;/EM&gt; written null character.
         &lt;br&gt;&lt;br&gt; This function is not part of ISO or POSIX but was found useful while
         developing the GNU C Library itself.
         &lt;br&gt;&lt;br&gt; Its behavior is undefined if the strings overlap.  The function is
         declared in &lt;TT&gt;string.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcpncpy" type="function">
    <function returntype="wchar_t *">
      <prototype>
        <parameter content="wchar_t *restrict wto"/>
        <parameter content="const wchar_t *restrict wfrom"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;wcpcpy&lt;/CODE&gt; but copies always exactly
         &lt;VAR&gt;wsize&lt;/VAR&gt; characters into &lt;VAR&gt;wto&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If the length of &lt;VAR&gt;wfrom&lt;/VAR&gt; is more then &lt;VAR&gt;size&lt;/VAR&gt;, then
         &lt;CODE&gt;wcpncpy&lt;/CODE&gt; copies just the first &lt;VAR&gt;size&lt;/VAR&gt; wide characters and
         returns a pointer to the wide character directly following the last
         non-null wide character which was copied last.  Note that in this case
         there is no null terminator written into &lt;VAR&gt;wto&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If the length of &lt;VAR&gt;wfrom&lt;/VAR&gt; is less than &lt;VAR&gt;size&lt;/VAR&gt;, then &lt;CODE&gt;wcpncpy&lt;/CODE&gt;
         copies all of &lt;VAR&gt;wfrom&lt;/VAR&gt;, followed by enough null characters to add up
         to &lt;VAR&gt;size&lt;/VAR&gt; characters in all.  This behavior is rarely useful, but it
         is implemented to be useful in contexts where this behavior of the
         &lt;CODE&gt;wcsncpy&lt;/CODE&gt; is used.  &lt;CODE&gt;wcpncpy&lt;/CODE&gt; returns a pointer to the
         &lt;EM&gt;first&lt;/EM&gt; written null character.
         &lt;br&gt;&lt;br&gt; This function is not part of ISO or POSIX but was found useful while
         developing the GNU C Library itself.
         &lt;br&gt;&lt;br&gt; Its behavior is undefined if the strings overlap.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;wcpncpy&lt;/CODE&gt; is a GNU extension and is declared in &lt;TT&gt;wchar.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strcat" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="char *restrict to"/>
        <parameter content="const char *restrict from"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;strcat&lt;/CODE&gt; function is similar to &lt;CODE&gt;strcpy&lt;/CODE&gt;, except that the
         characters from &lt;VAR&gt;from&lt;/VAR&gt; are concatenated or appended to the end of
         &lt;VAR&gt;to&lt;/VAR&gt;, instead of overwriting it.  That is, the first character from
         &lt;VAR&gt;from&lt;/VAR&gt; overwrites the null character marking the end of &lt;VAR&gt;to&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; An equivalent definition for &lt;CODE&gt;strcat&lt;/CODE&gt; would be:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         char *&lt;br&gt;
         strcat (char *restrict to, const char *restrict from)&lt;br&gt;
         {&lt;br&gt;
           strcpy (to + strlen (to), from);&lt;br&gt;
           return to;&lt;br&gt;
         }&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; This function has undefined results if the strings overlap.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcscat" type="function">
    <function returntype="wchar_t *">
      <prototype>
        <parameter content="wchar_t *restrict wto"/>
        <parameter content="const wchar_t *restrict wfrom"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wcscat&lt;/CODE&gt; function is similar to &lt;CODE&gt;wcscpy&lt;/CODE&gt;, except that the
         characters from &lt;VAR&gt;wfrom&lt;/VAR&gt; are concatenated or appended to the end of
         &lt;VAR&gt;wto&lt;/VAR&gt;, instead of overwriting it.  That is, the first character from
         &lt;VAR&gt;wfrom&lt;/VAR&gt; overwrites the null character marking the end of &lt;VAR&gt;wto&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; An equivalent definition for &lt;CODE&gt;wcscat&lt;/CODE&gt; would be:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         wchar_t *&lt;br&gt;
         wcscat (wchar_t *wto, const wchar_t *wfrom)&lt;br&gt;
         {&lt;br&gt;
           wcscpy (wto + wcslen (wto), wfrom);&lt;br&gt;
           return wto;&lt;br&gt;
         }&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; This function has undefined results if the strings overlap.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strncat" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="char *restrict to"/>
        <parameter content="const char *restrict from"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        This function is like &lt;CODE&gt;strcat&lt;/CODE&gt; except that not more than &lt;VAR&gt;size&lt;/VAR&gt;
         characters from &lt;VAR&gt;from&lt;/VAR&gt; are appended to the end of &lt;VAR&gt;to&lt;/VAR&gt;.  A
         single null character is also always appended to &lt;VAR&gt;to&lt;/VAR&gt;, so the total
         allocated size of &lt;VAR&gt;to&lt;/VAR&gt; must be at least &lt;CODE&gt;&lt;VAR&gt;size&lt;/VAR&gt; + 1&lt;/CODE&gt; bytes
         longer than its initial length.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;strncat&lt;/CODE&gt; function could be implemented like this:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         &lt;br&gt;
         char *&lt;br&gt;
         strncat (char *to, const char *from, size_t size)&lt;br&gt;
         {&lt;br&gt;
           to[strlen (to) + size] = '\0';&lt;br&gt;
           strncpy (to + strlen (to), from, size);&lt;br&gt;
           return to;&lt;br&gt;
         }&lt;br&gt;
         &lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; The behavior of &lt;CODE&gt;strncat&lt;/CODE&gt; is undefined if the strings overlap.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcsncat" type="function">
    <function returntype="wchar_t *">
      <prototype>
        <parameter content="wchar_t *restrict wto"/>
        <parameter content="const wchar_t *restrict wfrom"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        This function is like &lt;CODE&gt;wcscat&lt;/CODE&gt; except that not more than &lt;VAR&gt;size&lt;/VAR&gt;
         characters from &lt;VAR&gt;from&lt;/VAR&gt; are appended to the end of &lt;VAR&gt;to&lt;/VAR&gt;.  A
         single null character is also always appended to &lt;VAR&gt;to&lt;/VAR&gt;, so the total
         allocated size of &lt;VAR&gt;to&lt;/VAR&gt; must be at least &lt;CODE&gt;&lt;VAR&gt;size&lt;/VAR&gt; + 1&lt;/CODE&gt; bytes
         longer than its initial length.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;wcsncat&lt;/CODE&gt; function could be implemented like this:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         &lt;br&gt;
         wchar_t *&lt;br&gt;
         wcsncat (wchar_t *restrict wto, const wchar_t *restrict wfrom,&lt;br&gt;
                  size_t size)&lt;br&gt;
         {&lt;br&gt;
           wto[wcslen (to) + size] = L'\0';&lt;br&gt;
           wcsncpy (wto + wcslen (wto), wfrom, size);&lt;br&gt;
           return wto;&lt;br&gt;
         }&lt;br&gt;
         &lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; The behavior of &lt;CODE&gt;wcsncat&lt;/CODE&gt; is undefined if the strings overlap.
        </synopsis>
    </function>
  </construct>
  <construct id="function-bcopy" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="const void *from"/>
        <parameter content="void *to"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        This is a partially obsolete alternative for &lt;CODE&gt;memmove&lt;/CODE&gt;, derived from
         BSD.  Note that it is not quite equivalent to &lt;CODE&gt;memmove&lt;/CODE&gt;, because the
         arguments are not in the same order and there is no return value.
        </synopsis>
    </function>
  </construct>
  <construct id="function-bzero" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="void *block"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        This is a partially obsolete alternative for &lt;CODE&gt;memset&lt;/CODE&gt;, derived from
         BSD.  Note that it is not as general as &lt;CODE&gt;memset&lt;/CODE&gt;, because the only
         value it can store is zero.
        </synopsis>
    </function>
  </construct>
  <construct id="function-memcmp" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const void *a1"/>
        <parameter content="const void *a2"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        The function &lt;CODE&gt;memcmp&lt;/CODE&gt; compares the &lt;VAR&gt;size&lt;/VAR&gt; bytes of memory
         beginning at &lt;VAR&gt;a1&lt;/VAR&gt; against the &lt;VAR&gt;size&lt;/VAR&gt; bytes of memory beginning
         at &lt;VAR&gt;a2&lt;/VAR&gt;.  The value returned has the same sign as the difference
         between the first differing pair of bytes (interpreted as &lt;CODE&gt;unsigned
         char&lt;/CODE&gt; objects, then promoted to &lt;CODE&gt;int&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; If the contents of the two blocks are equal, &lt;CODE&gt;memcmp&lt;/CODE&gt; returns
         &lt;CODE&gt;0&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wmemcmp" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const wchar_t *a1"/>
        <parameter content="const wchar_t *a2"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "wcjar.h"/>
      </headers>
        <synopsis>
        The function &lt;CODE&gt;wmemcmp&lt;/CODE&gt; compares the &lt;VAR&gt;size&lt;/VAR&gt; wide characters
         beginning at &lt;VAR&gt;a1&lt;/VAR&gt; against the &lt;VAR&gt;size&lt;/VAR&gt; wide characters beginning
         at &lt;VAR&gt;a2&lt;/VAR&gt;.  The value returned is smaller than or larger than zero
         depending on whether the first differing wide character is &lt;VAR&gt;a1&lt;/VAR&gt; is
         smaller or larger than the corresponding character in &lt;VAR&gt;a2&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If the contents of the two blocks are equal, &lt;CODE&gt;wmemcmp&lt;/CODE&gt; returns
         &lt;CODE&gt;0&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strcmp" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *s1"/>
        <parameter content="const char *s2"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;strcmp&lt;/CODE&gt; function compares the string &lt;VAR&gt;s1&lt;/VAR&gt; against
         &lt;VAR&gt;s2&lt;/VAR&gt;, returning a value that has the same sign as the difference
         between the first differing pair of characters (interpreted as
         &lt;CODE&gt;unsigned char&lt;/CODE&gt; objects, then promoted to &lt;CODE&gt;int&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; If the two strings are equal, &lt;CODE&gt;strcmp&lt;/CODE&gt; returns &lt;CODE&gt;0&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; A consequence of the ordering used by &lt;CODE&gt;strcmp&lt;/CODE&gt; is that if &lt;VAR&gt;s1&lt;/VAR&gt;
         is an initial substring of &lt;VAR&gt;s2&lt;/VAR&gt;, then &lt;VAR&gt;s1&lt;/VAR&gt; is considered to be
         ``less than'' &lt;VAR&gt;s2&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;strcmp&lt;/CODE&gt; does not take sorting conventions of the language the
         strings are written in into account.  To get that one has to use
         &lt;CODE&gt;strcoll&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcscmp" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const wchar_t *ws1"/>
        <parameter content="const wchar_t *ws2"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;wcscmp&lt;/CODE&gt; function compares the wide character string &lt;VAR&gt;ws1&lt;/VAR&gt;
         against &lt;VAR&gt;ws2&lt;/VAR&gt;.  The value returned is smaller than or larger than zero
         depending on whether the first differing wide character is &lt;VAR&gt;ws1&lt;/VAR&gt; is
         smaller or larger than the corresponding character in &lt;VAR&gt;ws2&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If the two strings are equal, &lt;CODE&gt;wcscmp&lt;/CODE&gt; returns &lt;CODE&gt;0&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; A consequence of the ordering used by &lt;CODE&gt;wcscmp&lt;/CODE&gt; is that if &lt;VAR&gt;ws1&lt;/VAR&gt;
         is an initial substring of &lt;VAR&gt;ws2&lt;/VAR&gt;, then &lt;VAR&gt;ws1&lt;/VAR&gt; is considered to be
         ``less than'' &lt;VAR&gt;ws2&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;wcscmp&lt;/CODE&gt; does not take sorting conventions of the language the
         strings are written in into account.  To get that one has to use
         &lt;CODE&gt;wcscoll&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strcasecmp" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *s1"/>
        <parameter content="const char *s2"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        This function is like &lt;CODE&gt;strcmp&lt;/CODE&gt;, except that differences in case are
         ignored.  How uppercase and lowercase characters are related is
         determined by the currently selected locale.  In the standard &lt;CODE&gt;"C"&lt;/CODE&gt;
         locale the characters "A and "a do not match but in a locale which
         regards these characters as parts of the alphabet they do match.
         &lt;br&gt;&lt;br&gt;
         &lt;CODE&gt;strcasecmp&lt;/CODE&gt; is derived from BSD.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcscasecmp" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const wchar_t *ws1"/>
        <parameter content="const wchar_T *ws2"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        This function is like &lt;CODE&gt;wcscmp&lt;/CODE&gt;, except that differences in case are
         ignored.  How uppercase and lowercase characters are related is
         determined by the currently selected locale.  In the standard &lt;CODE&gt;"C"&lt;/CODE&gt;
         locale the characters "A and "a do not match but in a locale which
         regards these characters as parts of the alphabet they do match.
         &lt;br&gt;&lt;br&gt;
         &lt;CODE&gt;wcscasecmp&lt;/CODE&gt; is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strncmp" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *s1"/>
        <parameter content="const char *s2"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        This function is the similar to &lt;CODE&gt;strcmp&lt;/CODE&gt;, except that no more than
         &lt;VAR&gt;size&lt;/VAR&gt; characters are compared.  In other words, if the two
         strings are the same in their first &lt;VAR&gt;size&lt;/VAR&gt; characters, the
         return value is zero.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcsncmp" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const wchar_t *ws1"/>
        <parameter content="const wchar_t *ws2"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        This function is the similar to &lt;CODE&gt;wcscmp&lt;/CODE&gt;, except that no more than
         &lt;VAR&gt;size&lt;/VAR&gt; wide characters are compared.  In other words, if the two
         strings are the same in their first &lt;VAR&gt;size&lt;/VAR&gt; wide characters, the
         return value is zero.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strncasecmp" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *s1"/>
        <parameter content="const char *s2"/>
        <parameter content="size_t n"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        This function is like &lt;CODE&gt;strncmp&lt;/CODE&gt;, except that differences in case
         are ignored.  Like &lt;CODE&gt;strcasecmp&lt;/CODE&gt;, it is locale dependent how
         uppercase and lowercase characters are related.
         &lt;br&gt;&lt;br&gt;
         &lt;CODE&gt;strncasecmp&lt;/CODE&gt; is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcsncasecmp" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const wchar_t *ws1"/>
        <parameter content="const wchar_t *s2"/>
        <parameter content="size_t n"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        This function is like &lt;CODE&gt;wcsncmp&lt;/CODE&gt;, except that differences in case
         are ignored.  Like &lt;CODE&gt;wcscasecmp&lt;/CODE&gt;, it is locale dependent how
         uppercase and lowercase characters are related.
         &lt;br&gt;&lt;br&gt;
         &lt;CODE&gt;wcsncasecmp&lt;/CODE&gt; is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strverscmp" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *s1"/>
        <parameter content="const char *s2"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;strverscmp&lt;/CODE&gt; function compares the string &lt;VAR&gt;s1&lt;/VAR&gt; against
         &lt;VAR&gt;s2&lt;/VAR&gt;, considering them as holding indices/version numbers.  Return
         value follows the same conventions as found in the &lt;CODE&gt;strverscmp&lt;/CODE&gt;
         function.  In fact, if &lt;VAR&gt;s1&lt;/VAR&gt; and &lt;VAR&gt;s2&lt;/VAR&gt; contain no digits,
         &lt;CODE&gt;strverscmp&lt;/CODE&gt; behaves like &lt;CODE&gt;strcmp&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; Basically, we compare strings normally (character by character), until
         we find a digit in each string - then we enter a special comparison
         mode, where each sequence of digits is taken as a whole.  If we reach the
         end of these two parts without noticing a difference, we return to the
         standard comparison mode.  There are two types of numeric parts:
         "integral" and "fractional" (those  begin with a '0'). The types
         of the numeric parts affect the way we sort them:
         &lt;br&gt;&lt;br&gt; &lt;OL&gt;
         &lt;LI&gt;
         integral/integral: we compare values as you would expect.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         fractional/integral: the fractional part is less than the integral one.
         Again, no surprise.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         fractional/fractional: the things become a bit more complex.
         If the common prefix contains only leading zeroes, the longest part is less
         than the other one; else the comparison behaves normally.
         &lt;/OL&gt;
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         strverscmp ("no digit", "no digit")&lt;br&gt;
              0    /* same behavior as strcmp. */&lt;br&gt;
         strverscmp ("item#99", "item#100")&lt;br&gt;
              &lt;0   /* same prefix, but 99 &lt; 100. */&lt;br&gt;
         strverscmp ("alpha1", "alpha001")&lt;br&gt;
              &gt;0   /* fractional part inferior to integral one. */&lt;br&gt;
         strverscmp ("part1_f012", "part1_f01")&lt;br&gt;
              &gt;0   /* two fractional parts. */&lt;br&gt;
         strverscmp ("foo.009", "foo.0")&lt;br&gt;
              &lt;0   /* idem, but with leading zeroes only. */&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; This function is especially useful when dealing with filename sorting,
         because filenames frequently hold indices/version numbers.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;strverscmp&lt;/CODE&gt; is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-bcmp" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const void *a1"/>
        <parameter content="const void *a2"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        This is an obsolete alias for &lt;CODE&gt;memcmp&lt;/CODE&gt;, derived from BSD.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strcoll" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *s1"/>
        <parameter content="const char *s2"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;strcoll&lt;/CODE&gt; function is similar to &lt;CODE&gt;strcmp&lt;/CODE&gt; but uses the
         collating sequence of the current locale for collation (the
         &lt;CODE&gt;LC_COLLATE&lt;/CODE&gt; locale).
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcscoll" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const wchar_t *ws1"/>
        <parameter content="const wchar_t *ws2"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wcscoll&lt;/CODE&gt; function is similar to &lt;CODE&gt;wcscmp&lt;/CODE&gt; but uses the
         collating sequence of the current locale for collation (the
         &lt;CODE&gt;LC_COLLATE&lt;/CODE&gt; locale).
        </synopsis>
    </function>
  </construct>
  <construct id="function-strxfrm" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="char *restrict to"/>
        <parameter content="const char *restrict from"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        The function &lt;CODE&gt;strxfrm&lt;/CODE&gt; transforms the string &lt;VAR&gt;from&lt;/VAR&gt; using the
         collation transformation determined by the locale currently selected for
         collation, and stores the transformed string in the array &lt;VAR&gt;to&lt;/VAR&gt;.  Up
         to &lt;VAR&gt;size&lt;/VAR&gt; characters (including a terminating null character) are
         stored.
         &lt;br&gt;&lt;br&gt; The behavior is undefined if the strings &lt;VAR&gt;to&lt;/VAR&gt; and &lt;VAR&gt;from&lt;/VAR&gt;
         overlap; see Copying and Concatenation.
         &lt;br&gt;&lt;br&gt; The return value is the length of the entire transformed string.  This
         value is not affected by the value of &lt;VAR&gt;size&lt;/VAR&gt;, but if it is greater
         or equal than &lt;VAR&gt;size&lt;/VAR&gt;, it means that the transformed string did not
         entirely fit in the array &lt;VAR&gt;to&lt;/VAR&gt;.  In this case, only as much of the
         string as actually fits was stored.  To get the whole transformed
         string, call &lt;CODE&gt;strxfrm&lt;/CODE&gt; again with a bigger output array.
         &lt;br&gt;&lt;br&gt; The transformed string may be longer than the original string, and it
         may also be shorter.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;size&lt;/VAR&gt; is zero, no characters are stored in &lt;VAR&gt;to&lt;/VAR&gt;.  In this
         case, &lt;CODE&gt;strxfrm&lt;/CODE&gt; simply returns the number of characters that would
         be the length of the transformed string.  This is useful for determining
         what size the allocated array should be.  It does not matter what
         &lt;VAR&gt;to&lt;/VAR&gt; is if &lt;VAR&gt;size&lt;/VAR&gt; is zero; &lt;VAR&gt;to&lt;/VAR&gt; may even be a null pointer.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcsxfrm" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="wchar_t *restrict wto"/>
        <parameter content="const wchar_t *wfrom"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The function &lt;CODE&gt;wcsxfrm&lt;/CODE&gt; transforms wide character string &lt;VAR&gt;wfrom&lt;/VAR&gt;
         using the collation transformation determined by the locale currently
         selected for collation, and stores the transformed string in the array
         &lt;VAR&gt;wto&lt;/VAR&gt;.  Up to &lt;VAR&gt;size&lt;/VAR&gt; wide characters (including a terminating null
         character) are stored.
         &lt;br&gt;&lt;br&gt; The behavior is undefined if the strings &lt;VAR&gt;wto&lt;/VAR&gt; and &lt;VAR&gt;wfrom&lt;/VAR&gt;
         overlap; see Copying and Concatenation.
         &lt;br&gt;&lt;br&gt; The return value is the length of the entire transformed wide character
         string.  This value is not affected by the value of &lt;VAR&gt;size&lt;/VAR&gt;, but if
         it is greater or equal than &lt;VAR&gt;size&lt;/VAR&gt;, it means that the transformed
         wide character string did not entirely fit in the array &lt;VAR&gt;wto&lt;/VAR&gt;.  In
         this case, only as much of the wide character string as actually fits
         was stored.  To get the whole transformed wide character string, call
         &lt;CODE&gt;wcsxfrm&lt;/CODE&gt; again with a bigger output array.
         &lt;br&gt;&lt;br&gt; The transformed wide character string may be longer than the original
         wide character string, and it may also be shorter.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;size&lt;/VAR&gt; is zero, no characters are stored in &lt;VAR&gt;to&lt;/VAR&gt;.  In this
         case, &lt;CODE&gt;wcsxfrm&lt;/CODE&gt; simply returns the number of wide characters that
         would be the length of the transformed wide character string.  This is
         useful for determining what size the allocated array should be (remember
         to multiply with &lt;CODE&gt;sizeof (wchar_t)&lt;/CODE&gt;).  It does not matter what
         &lt;VAR&gt;wto&lt;/VAR&gt; is if &lt;VAR&gt;size&lt;/VAR&gt; is zero; &lt;VAR&gt;wto&lt;/VAR&gt; may even be a null pointer.
        </synopsis>
    </function>
  </construct>
  <construct id="function-memchr" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="const void *block"/>
        <parameter content="int c"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        This function finds the first occurrence of the byte &lt;VAR&gt;c&lt;/VAR&gt; (converted
         to an &lt;CODE&gt;unsigned char&lt;/CODE&gt;) in the initial &lt;VAR&gt;size&lt;/VAR&gt; bytes of the
         object beginning at &lt;VAR&gt;block&lt;/VAR&gt;.  The return value is a pointer to the
         located byte, or a null pointer if no match was found.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wmemchr" type="function">
    <function returntype="wchar_t *">
      <prototype>
        <parameter content="const wchar_t *block"/>
        <parameter content="wchar_t wc"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        This function finds the first occurrence of the wide character &lt;VAR&gt;wc&lt;/VAR&gt;
         in the initial &lt;VAR&gt;size&lt;/VAR&gt; wide characters of the object beginning at
         &lt;VAR&gt;block&lt;/VAR&gt;.  The return value is a pointer to the located wide
         character, or a null pointer if no match was found.
        </synopsis>
    </function>
  </construct>
  <construct id="function-rawmemchr" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="const void *block"/>
        <parameter content="int c"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        Often the &lt;CODE&gt;memchr&lt;/CODE&gt; function is used with the knowledge that the
         byte &lt;VAR&gt;c&lt;/VAR&gt; is available in the memory block specified by the
         parameters.  But this means that the &lt;VAR&gt;size&lt;/VAR&gt; parameter is not really
         needed and that the tests performed with it at runtime (to check whether
         the end of the block is reached) are not needed.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;rawmemchr&lt;/CODE&gt; function exists for just this situation which is
         surprisingly frequent.  The interface is similar to &lt;CODE&gt;memchr&lt;/CODE&gt; except
         that the &lt;VAR&gt;size&lt;/VAR&gt; parameter is missing.  The function will look beyond
         the end of the block pointed to by &lt;VAR&gt;block&lt;/VAR&gt; in case the programmer
         made an error in assuming that the byte &lt;VAR&gt;c&lt;/VAR&gt; is present in the block.
         In this case the result is unspecified.  Otherwise the return value is a
         pointer to the located byte.
         &lt;br&gt;&lt;br&gt; This function is of special interest when looking for the end of a
         string.  Since all strings are terminated by a null byte a call like
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
            rawmemchr (str, '\0')&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt;
         will never go beyond the end of the string.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-memrchr" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="const void *block"/>
        <parameter content="int c"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        The function &lt;CODE&gt;memrchr&lt;/CODE&gt; is like &lt;CODE&gt;memchr&lt;/CODE&gt;, except that it searches
         backwards from the end of the block defined by &lt;VAR&gt;block&lt;/VAR&gt; and &lt;VAR&gt;size&lt;/VAR&gt;
         (instead of forwards from the front).
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strchr" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *string"/>
        <parameter content="int c"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;strchr&lt;/CODE&gt; function finds the first occurrence of the character
         &lt;VAR&gt;c&lt;/VAR&gt; (converted to a &lt;CODE&gt;char&lt;/CODE&gt;) in the null-terminated string
         beginning at &lt;VAR&gt;string&lt;/VAR&gt;.  The return value is a pointer to the located
         character, or a null pointer if no match was found.
         &lt;br&gt;&lt;br&gt; For example,
         &lt;pre&gt;&lt;br&gt;
         strchr ("hello, world", 'l')&lt;br&gt;
              "llo, world"&lt;br&gt;
         strchr ("hello, world", '?')&lt;br&gt;
              NULL&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; The terminating null character is considered to be part of the string,
         so you can use this function get a pointer to the end of a string by
         specifying a null character as the value of the &lt;VAR&gt;c&lt;/VAR&gt; argument.  It
         would be better (but less portable) to use &lt;CODE&gt;strchrnul&lt;/CODE&gt; in this
         case, though.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcschr" type="function">
    <function returntype="wchar_t *">
      <prototype>
        <parameter content="const wchar_t *wstring"/>
        <parameter content="int wc"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wcschr&lt;/CODE&gt; function finds the first occurrence of the wide
         character &lt;VAR&gt;wc&lt;/VAR&gt; in the null-terminated wide character string
         beginning at &lt;VAR&gt;wstring&lt;/VAR&gt;.  The return value is a pointer to the
         located wide character, or a null pointer if no match was found.
         &lt;br&gt;&lt;br&gt; The terminating null character is considered to be part of the wide
         character string, so you can use this function get a pointer to the end
         of a wide character string by specifying a null wude character as the
         value of the &lt;VAR&gt;wc&lt;/VAR&gt; argument.  It would be better (but less portable)
         to use &lt;CODE&gt;wcschrnul&lt;/CODE&gt; in this case, though.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strchrnul" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *string"/>
        <parameter content="int c"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;strchrnul&lt;/CODE&gt; is the same as &lt;CODE&gt;strchr&lt;/CODE&gt; except that if it does
         not find the character, it returns a pointer to string's terminating
         null character rather than a null pointer.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcschrnul" type="function">
    <function returntype="wchar_t *">
      <prototype>
        <parameter content="const wchar_t *wstring"/>
        <parameter content="wchar_t wc"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;wcschrnul&lt;/CODE&gt; is the same as &lt;CODE&gt;wcschr&lt;/CODE&gt; except that if it does not
         find the wide character, it returns a pointer to wide character string's
         terminating null wide character rather than a null pointer.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strrchr" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *string"/>
        <parameter content="int c"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        The function &lt;CODE&gt;strrchr&lt;/CODE&gt; is like &lt;CODE&gt;strchr&lt;/CODE&gt;, except that it searches
         backwards from the end of the string &lt;VAR&gt;string&lt;/VAR&gt; (instead of forwards
         from the front).
         &lt;br&gt;&lt;br&gt; For example,
         &lt;pre&gt;&lt;br&gt;
         strrchr ("hello, world", 'l')&lt;br&gt;
              "ld"&lt;br&gt;
         &lt;/pre&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcsrchr" type="function">
    <function returntype="wchar_t *">
      <prototype>
        <parameter content="const wchar_t *wstring"/>
        <parameter content="wchar_t c"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The function &lt;CODE&gt;wcsrchr&lt;/CODE&gt; is like &lt;CODE&gt;wcschr&lt;/CODE&gt;, except that it searches
         backwards from the end of the string &lt;VAR&gt;wstring&lt;/VAR&gt; (instead of forwards
         from the front).
        </synopsis>
    </function>
  </construct>
  <construct id="function-strstr" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *haystack"/>
        <parameter content="const char *needle"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        This is like &lt;CODE&gt;strchr&lt;/CODE&gt;, except that it searches &lt;VAR&gt;haystack&lt;/VAR&gt; for a
         substring &lt;VAR&gt;needle&lt;/VAR&gt; rather than just a single character.  It
         returns a pointer into the string &lt;VAR&gt;haystack&lt;/VAR&gt; that is the first
         character of the substring, or a null pointer if no match was found.  If
         &lt;VAR&gt;needle&lt;/VAR&gt; is an empty string, the function returns &lt;VAR&gt;haystack&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; For example,
         &lt;pre&gt;&lt;br&gt;
         strstr ("hello, world", "l")&lt;br&gt;
              "llo, world"&lt;br&gt;
         strstr ("hello, world", "wo")&lt;br&gt;
              "world"&lt;br&gt;
         &lt;/pre&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcsstr" type="function">
    <function returntype="wchar_t *">
      <prototype>
        <parameter content="const wchar_t *haystack"/>
        <parameter content="const wchar_t *needle"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        This is like &lt;CODE&gt;wcschr&lt;/CODE&gt;, except that it searches &lt;VAR&gt;haystack&lt;/VAR&gt; for a
         substring &lt;VAR&gt;needle&lt;/VAR&gt; rather than just a single wide character.  It
         returns a pointer into the string &lt;VAR&gt;haystack&lt;/VAR&gt; that is the first wide
         character of the substring, or a null pointer if no match was found.  If
         &lt;VAR&gt;needle&lt;/VAR&gt; is an empty string, the function returns &lt;VAR&gt;haystack&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcswcs" type="function">
    <function returntype="wchar_t *">
      <prototype>
        <parameter content="const wchar_t *haystack"/>
        <parameter content="const wchar_t *needle"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;wcswcs&lt;/CODE&gt; is an deprecated alias for &lt;CODE&gt;wcsstr&lt;/CODE&gt;.  This is the
         name originally used in the X/Open Portability Guide before the
         Amendment 1 to ISO C90 was published.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strcasestr" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *haystack"/>
        <parameter content="const char *needle"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        This is like &lt;CODE&gt;strstr&lt;/CODE&gt;, except that it ignores case in searching for
         the substring.   Like &lt;CODE&gt;strcasecmp&lt;/CODE&gt;, it is locale dependent how
         uppercase and lowercase characters are related.
         &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt; For example,
         &lt;pre&gt;&lt;br&gt;
         strcasestr ("hello, world", "L")&lt;br&gt;
              "llo, world"&lt;br&gt;
         strcasestr ("hello, World", "wo")&lt;br&gt;
              "World"&lt;br&gt;
         &lt;/pre&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-memmem" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="const void *haystack"/>
        <parameter content="size_t haystack-len,const void *needle"/>
        <parameter content="size_t needle-len"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        This is like &lt;CODE&gt;strstr&lt;/CODE&gt;, but &lt;VAR&gt;needle&lt;/VAR&gt; and &lt;VAR&gt;haystack&lt;/VAR&gt; are byte
         arrays rather than null-terminated strings.  &lt;VAR&gt;needle-len&lt;/VAR&gt; is the
         length of &lt;VAR&gt;needle&lt;/VAR&gt; and &lt;VAR&gt;haystack-len&lt;/VAR&gt; is the length of
         &lt;VAR&gt;haystack&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strspn" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="const char *string"/>
        <parameter content="const char *skipset"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;strspn&lt;/CODE&gt; (``string span'') function returns the length of the
         initial substring of &lt;VAR&gt;string&lt;/VAR&gt; that consists entirely of characters that
         are members of the set specified by the string &lt;VAR&gt;skipset&lt;/VAR&gt;.  The order
         of the characters in &lt;VAR&gt;skipset&lt;/VAR&gt; is not important.
         &lt;br&gt;&lt;br&gt; For example,
         &lt;pre&gt;&lt;br&gt;
         strspn ("hello, world", "abcdefghijklmnopqrstuvwxyz")&lt;br&gt;
              5&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; Note that ``character'' is here used in the sense of byte.  In a string
         using a multibyte character encoding (abstract) character consisting of
         more than one byte are not treated as an entity.  Each byte is treated
         separately.  The function is not locale-dependent.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcsspn" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="const wchar_t *wstring"/>
        <parameter content="const wchar_t *skipset"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wcsspn&lt;/CODE&gt; (``wide character string span'') function returns the
         length of the initial substring of &lt;VAR&gt;wstring&lt;/VAR&gt; that consists entirely
         of wide characters that are members of the set specified by the string
         &lt;VAR&gt;skipset&lt;/VAR&gt;.  The order of the wide characters in &lt;VAR&gt;skipset&lt;/VAR&gt; is not
         important.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strcspn" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="const char *string"/>
        <parameter content="const char *stopset"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;strcspn&lt;/CODE&gt; (``string complement span'') function returns the length
         of the initial substring of &lt;VAR&gt;string&lt;/VAR&gt; that consists entirely of characters
         that are &lt;EM&gt;not&lt;/EM&gt; members of the set specified by the string &lt;VAR&gt;stopset&lt;/VAR&gt;.
         (In other words, it returns the offset of the first character in &lt;VAR&gt;string&lt;/VAR&gt;
         that is a member of the set &lt;VAR&gt;stopset&lt;/VAR&gt;.)
         &lt;br&gt;&lt;br&gt; For example,
         &lt;pre&gt;&lt;br&gt;
         strcspn ("hello, world", " \t\n,.;!?")&lt;br&gt;
              5&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; Note that ``character'' is here used in the sense of byte.  In a string
         using a multibyte character encoding (abstract) character consisting of
         more than one byte are not treated as an entity.  Each byte is treated
         separately.  The function is not locale-dependent.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcscspn" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="const wchar_t *wstring"/>
        <parameter content="const wchar_t *stopset"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wcscspn&lt;/CODE&gt; (``wide character string complement span'') function
         returns the length of the initial substring of &lt;VAR&gt;wstring&lt;/VAR&gt; that
         consists entirely of wide characters that are &lt;EM&gt;not&lt;/EM&gt; members of the
         set specified by the string &lt;VAR&gt;stopset&lt;/VAR&gt;.  (In other words, it returns
         the offset of the first character in &lt;VAR&gt;string&lt;/VAR&gt; that is a member of
         the set &lt;VAR&gt;stopset&lt;/VAR&gt;.)
        </synopsis>
    </function>
  </construct>
  <construct id="function-strpbrk" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *string"/>
        <parameter content="const char *stopset"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;strpbrk&lt;/CODE&gt; (``string pointer break'') function is related to
         &lt;CODE&gt;strcspn&lt;/CODE&gt;, except that it returns a pointer to the first character
         in &lt;VAR&gt;string&lt;/VAR&gt; that is a member of the set &lt;VAR&gt;stopset&lt;/VAR&gt; instead of the
         length of the initial substring.  It returns a null pointer if no such
         character from &lt;VAR&gt;stopset&lt;/VAR&gt; is found.
         &lt;br&gt;&lt;br&gt; For example,
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         strpbrk ("hello, world", " \t\n,.;!?")&lt;br&gt;
              ", world"&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; Note that ``character'' is here used in the sense of byte.  In a string
         using a multibyte character encoding (abstract) character consisting of
         more than one byte are not treated as an entity.  Each byte is treated
         separately.  The function is not locale-dependent.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcspbrk" type="function">
    <function returntype="wchar_t *">
      <prototype>
        <parameter content="const wchar_t *wstring"/>
        <parameter content="const wchar_t *stopset"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wcspbrk&lt;/CODE&gt; (``wide character string pointer break'') function is
         related to &lt;CODE&gt;wcscspn&lt;/CODE&gt;, except that it returns a pointer to the first
         wide character in &lt;VAR&gt;wstring&lt;/VAR&gt; that is a member of the set
         &lt;VAR&gt;stopset&lt;/VAR&gt; instead of the length of the initial substring.  It
         returns a null pointer if no such character from &lt;VAR&gt;stopset&lt;/VAR&gt; is found.
        </synopsis>
    </function>
  </construct>
  <construct id="function-index" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *string"/>
        <parameter content="int c"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;index&lt;/CODE&gt; is another name for &lt;CODE&gt;strchr&lt;/CODE&gt;; they are exactly the same.
         New code should always use &lt;CODE&gt;strchr&lt;/CODE&gt; since this name is defined in
         ISO C while &lt;CODE&gt;index&lt;/CODE&gt; is a BSD invention which never was available
         on System V derived systems.
        </synopsis>
    </function>
  </construct>
  <construct id="function-rindex" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *string"/>
        <parameter content="int c"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;rindex&lt;/CODE&gt; is another name for &lt;CODE&gt;strrchr&lt;/CODE&gt;; they are exactly the same.
         New code should always use &lt;CODE&gt;strrchr&lt;/CODE&gt; since this name is defined in
         ISO C while &lt;CODE&gt;rindex&lt;/CODE&gt; is a BSD invention which never was available
         on System V derived systems.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strtok" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="char *restrict newstring"/>
        <parameter content="const char *restrict delimiters"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        A string can be split into tokens by making a series of calls to the
         function &lt;CODE&gt;strtok&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The string to be split up is passed as the &lt;VAR&gt;newstring&lt;/VAR&gt; argument on
         the first call only.  The &lt;CODE&gt;strtok&lt;/CODE&gt; function uses this to set up
         some internal state information.  Subsequent calls to get additional
         tokens from the same string are indicated by passing a null pointer as
         the &lt;VAR&gt;newstring&lt;/VAR&gt; argument.  Calling &lt;CODE&gt;strtok&lt;/CODE&gt; with another
         non-null &lt;VAR&gt;newstring&lt;/VAR&gt; argument reinitializes the state information.
         It is guaranteed that no other library function ever calls &lt;CODE&gt;strtok&lt;/CODE&gt;
         behind your back (which would mess up this internal state information).
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;delimiters&lt;/VAR&gt; argument is a string that specifies a set of delimiters
         that may surround the token being extracted.  All the initial characters
         that are members of this set are discarded.  The first character that is
         &lt;EM&gt;not&lt;/EM&gt; a member of this set of delimiters marks the beginning of the
         next token.  The end of the token is found by looking for the next
         character that is a member of the delimiter set.  This character in the
         original string &lt;VAR&gt;newstring&lt;/VAR&gt; is overwritten by a null character, and the
         pointer to the beginning of the token in &lt;VAR&gt;newstring&lt;/VAR&gt; is returned.
         &lt;br&gt;&lt;br&gt; On the next call to &lt;CODE&gt;strtok&lt;/CODE&gt;, the searching begins at the next
         character beyond the one that marked the end of the previous token.
         Note that the set of delimiters &lt;VAR&gt;delimiters&lt;/VAR&gt; do not have to be the
         same on every call in a series of calls to &lt;CODE&gt;strtok&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; If the end of the string &lt;VAR&gt;newstring&lt;/VAR&gt; is reached, or if the remainder of
         string consists only of delimiter characters, &lt;CODE&gt;strtok&lt;/CODE&gt; returns
         a null pointer.
         &lt;br&gt;&lt;br&gt; Note that ``character'' is here used in the sense of byte.  In a string
         using a multibyte character encoding (abstract) character consisting of
         more than one byte are not treated as an entity.  Each byte is treated
         separately.  The function is not locale-dependent.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcstok" type="function">
    <function returntype="wchar_t *">
      <prototype>
        <parameter content="wchar_t *newstring"/>
        <parameter content="const char *delimiters"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        A string can be split into tokens by making a series of calls to the
         function &lt;CODE&gt;wcstok&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The string to be split up is passed as the &lt;VAR&gt;newstring&lt;/VAR&gt; argument on
         the first call only.  The &lt;CODE&gt;wcstok&lt;/CODE&gt; function uses this to set up
         some internal state information.  Subsequent calls to get additional
         tokens from the same wide character string are indicated by passing a
         null pointer as the &lt;VAR&gt;newstring&lt;/VAR&gt; argument.  Calling &lt;CODE&gt;wcstok&lt;/CODE&gt;
         with another non-null &lt;VAR&gt;newstring&lt;/VAR&gt; argument reinitializes the state
         information.  It is guaranteed that no other library function ever calls
         &lt;CODE&gt;wcstok&lt;/CODE&gt; behind your back (which would mess up this internal state
         information).
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;delimiters&lt;/VAR&gt; argument is a wide character string that specifies
         a set of delimiters that may surround the token being extracted.  All
         the initial wide characters that are members of this set are discarded.
         The first wide character that is &lt;EM&gt;not&lt;/EM&gt; a member of this set of
         delimiters marks the beginning of the next token.  The end of the token
         is found by looking for the next wide character that is a member of the
         delimiter set.  This wide character in the original wide character
         string &lt;VAR&gt;newstring&lt;/VAR&gt; is overwritten by a null wide character, and the
         pointer to the beginning of the token in &lt;VAR&gt;newstring&lt;/VAR&gt; is returned.
         &lt;br&gt;&lt;br&gt; On the next call to &lt;CODE&gt;wcstok&lt;/CODE&gt;, the searching begins at the next
         wide character beyond the one that marked the end of the previous token.
         Note that the set of delimiters &lt;VAR&gt;delimiters&lt;/VAR&gt; do not have to be the
         same on every call in a series of calls to &lt;CODE&gt;wcstok&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; If the end of the wide character string &lt;VAR&gt;newstring&lt;/VAR&gt; is reached, or
         if the remainder of string consists only of delimiter wide characters,
         &lt;CODE&gt;wcstok&lt;/CODE&gt; returns a null pointer.
         &lt;br&gt;&lt;br&gt; Note that ``character'' is here used in the sense of byte.  In a string
         using a multibyte character encoding (abstract) character consisting of
         more than one byte are not treated as an entity.  Each byte is treated
         separately.  The function is not locale-dependent.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strtok_r" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="char *newstring"/>
        <parameter content="const char *delimiters"/>
        <parameter content="char **save_ptr"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        Just like &lt;CODE&gt;strtok&lt;/CODE&gt;, this function splits the string into several
         tokens which can be accessed by successive calls to &lt;CODE&gt;strtok_r&lt;/CODE&gt;.
         The difference is that the information about the next token is stored in
         the space pointed to by the third argument, &lt;VAR&gt;save_ptr&lt;/VAR&gt;, which is a
         pointer to a string pointer.  Calling &lt;CODE&gt;strtok_r&lt;/CODE&gt; with a null
         pointer for &lt;VAR&gt;newstring&lt;/VAR&gt; and leaving &lt;VAR&gt;save_ptr&lt;/VAR&gt; between the calls
         unchanged does the job without hindering reentrancy.
         &lt;br&gt;&lt;br&gt; This function is defined in POSIX.1 and can be found on many systems
         which support multi-threading.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strsep" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="char **string_ptr"/>
        <parameter content="const char *delimiter"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        This function has a similar functionality as &lt;CODE&gt;strtok_r&lt;/CODE&gt; with the
         &lt;VAR&gt;newstring&lt;/VAR&gt; argument replaced by the &lt;VAR&gt;save_ptr&lt;/VAR&gt; argument.  The
         initialization of the moving pointer has to be done by the user.
         Successive calls to &lt;CODE&gt;strsep&lt;/CODE&gt; move the pointer along the tokens
         separated by &lt;VAR&gt;delimiter&lt;/VAR&gt;, returning the address of the next token
         and updating &lt;VAR&gt;string_ptr&lt;/VAR&gt; to point to the beginning of the next
         token.
         &lt;br&gt;&lt;br&gt; One difference between &lt;CODE&gt;strsep&lt;/CODE&gt; and &lt;CODE&gt;strtok_r&lt;/CODE&gt; is that if the
         input string contains more than one character from &lt;VAR&gt;delimiter&lt;/VAR&gt; in a
         row &lt;CODE&gt;strsep&lt;/CODE&gt; returns an empty string for each pair of characters
         from &lt;VAR&gt;delimiter&lt;/VAR&gt;.  This means that a program normally should test
         for &lt;CODE&gt;strsep&lt;/CODE&gt; returning an empty string before processing it.
         &lt;br&gt;&lt;br&gt; This function was introduced in 4.3BSD and therefore is widely available.
        </synopsis>
    </function>
  </construct>
  <construct id="function-basename" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *filename"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        The GNU version of the &lt;CODE&gt;basename&lt;/CODE&gt; function returns the last
         component of the path in &lt;VAR&gt;filename&lt;/VAR&gt;.  This function is the preferred
         usage, since it does not modify the argument, &lt;VAR&gt;filename&lt;/VAR&gt;, and
         respects trailing slashes.  The prototype for &lt;CODE&gt;basename&lt;/CODE&gt; can be
         found in &lt;TT&gt;string.h&lt;/TT&gt;.  Note, this function is overriden by the XPG
         version, if &lt;TT&gt;libgen.h&lt;/TT&gt; is included.
         &lt;br&gt;&lt;br&gt; Example of using GNU &lt;CODE&gt;basename&lt;/CODE&gt;:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         #include &lt;string.h&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; int&lt;br&gt;
         main (int argc, char *argv[])&lt;br&gt;
         {&lt;br&gt;
           char *prog = basename (argv[0]);&lt;br&gt;
         &lt;br&gt;&lt;br&gt;   if (argc &lt; 2)&lt;br&gt;
             {&lt;br&gt;
               fprintf (stderr, "Usage %s &lt;arg&gt;\n", prog);&lt;br&gt;
               exit (1);&lt;br&gt;
             }&lt;br&gt;
         &lt;br&gt;&lt;br&gt;   &lt;small&gt;...&lt;/small&gt;&lt;br&gt;
         }&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; Portability Note: This function may produce different results
         on different systems.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-basename" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="char *path"/>
      </prototype>
      <headers>
        <header filename = "libgen.h"/>
      </headers>
        <synopsis>
        This is the standard XPG defined &lt;CODE&gt;basename&lt;/CODE&gt;. It is similar in
         spirit to the GNU version, but may modify the &lt;VAR&gt;path&lt;/VAR&gt; by removing
         trailing '/' characters.  If the &lt;VAR&gt;path&lt;/VAR&gt; is made up entirely of '/'
         characters, then "/" will be returned.  Also, if &lt;VAR&gt;path&lt;/VAR&gt; is
         &lt;CODE&gt;NULL&lt;/CODE&gt; or an empty string, then "." is returned.  The prototype for
         the XPG version can be found in &lt;TT&gt;libgen.h&lt;/TT&gt;.
         &lt;br&gt;&lt;br&gt; Example of using XPG &lt;CODE&gt;basename&lt;/CODE&gt;:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         #include &lt;libgen.h&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; int&lt;br&gt;
         main (int argc, char *argv[])&lt;br&gt;
         {&lt;br&gt;
           char *prog;&lt;br&gt;
           char *path = strdupa (argv[0]);&lt;br&gt;
         &lt;br&gt;&lt;br&gt;   prog = basename (path);&lt;br&gt;
         &lt;br&gt;&lt;br&gt;   if (argc &lt; 2)&lt;br&gt;
             {&lt;br&gt;
               fprintf (stderr, "Usage %s &lt;arg&gt;\n", prog);&lt;br&gt;
               exit (1);&lt;br&gt;
             }&lt;br&gt;
         &lt;br&gt;&lt;br&gt;   &lt;small&gt;...&lt;/small&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; }&lt;br&gt;
         &lt;/pre&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-dirname" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="char *path"/>
      </prototype>
      <headers>
        <header filename = "libgen.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;dirname&lt;/CODE&gt; function is the compliment to the XPG version of
         &lt;CODE&gt;basename&lt;/CODE&gt;.  It returns the parent directory of the file specified
         by &lt;VAR&gt;path&lt;/VAR&gt;.  If &lt;VAR&gt;path&lt;/VAR&gt; is &lt;CODE&gt;NULL&lt;/CODE&gt;, an empty string, or
         contains no '/' characters, then "." is returned.  The prototype for this
         function can be found in &lt;TT&gt;libgen.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strfry" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="char *string"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; &lt;CODE&gt;strfry&lt;/CODE&gt; creates a pseudorandom anagram of a string, replacing the
         input with the anagram in place.  For each position in the string,
         &lt;CODE&gt;strfry&lt;/CODE&gt; swaps it with a position in the string selected at random
         (from a uniform distribution).  The two positions may be the same.
         &lt;br&gt;&lt;br&gt; The return value of &lt;CODE&gt;strfry&lt;/CODE&gt; is always &lt;VAR&gt;string&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; Portability Note:  This function is unique to the GNU C library.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-memfrob" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="void *mem"/>
        <parameter content="size_t length"/>
      </prototype>
      <headers>
        <header filename = "string.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; &lt;CODE&gt;memfrob&lt;/CODE&gt; transforms (frobnicates) each byte of the data structure
         at &lt;VAR&gt;mem&lt;/VAR&gt;, which is &lt;VAR&gt;length&lt;/VAR&gt; bytes long, by bitwise exclusive
         oring it with binary 00101010.  It does the transformation in place and
         its return value is always &lt;VAR&gt;mem&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; Note that &lt;CODE&gt;memfrob&lt;/CODE&gt; a second time on the same data structure
         returns it to its original state.
         &lt;br&gt;&lt;br&gt; This is a good function for hiding information from someone who doesn't
         want to see it or doesn't want to see it very much.  To really prevent
         people from retrieving the information, use stronger encryption such as
         that described in .
         &lt;br&gt;&lt;br&gt; Portability Note:  This function is unique to the GNU C library.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-l64a" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="long int n"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        This function encodes a 32-bit input value using characters from the
         basic character set.  It returns a pointer to a 7 character buffer which
         contains an encoded version of &lt;VAR&gt;n&lt;/VAR&gt;.  To encode a series of bytes the
         user must copy the returned string to a destination buffer.  It returns
         the empty string if &lt;VAR&gt;n&lt;/VAR&gt; is zero, which is somewhat bizarre but
         mandated by the standard.*
         Warning: Since a static buffer is used this function should not
         be used in multi-threaded programs.  There is no thread-safe alternative
         to this function in the C library.*
         Compatibility Note: The XPG standard states that the return
         value of &lt;CODE&gt;l64a&lt;/CODE&gt; is undefined if &lt;VAR&gt;n&lt;/VAR&gt; is negative.  In the GNU
         implementation, &lt;CODE&gt;l64a&lt;/CODE&gt; treats its argument as unsigned, so it will
         return a sensible encoding for any nonzero &lt;VAR&gt;n&lt;/VAR&gt;; however, portable
         programs should not rely on this.
         &lt;br&gt;&lt;br&gt; To encode a large buffer &lt;CODE&gt;l64a&lt;/CODE&gt; must be called in a loop, once for
         each 32-bit word of the buffer.  For example, one could do something
         like this:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         char *&lt;br&gt;
         encode (const void *buf, size_t len)&lt;br&gt;
         {&lt;br&gt;
           /* We know in advance how long the buffer has to be. */&lt;br&gt;
           unsigned char *in = (unsigned char *) buf;&lt;br&gt;
           char *out = malloc (6 + ((len + 3) / 4) * 6 + 1);&lt;br&gt;
           char *cp = out, *p;&lt;br&gt;
         &lt;br&gt;&lt;br&gt;   /* Encode the length. */&lt;br&gt;
           /* Using `htonl' is necessary so that the data can be&lt;br&gt;
              decoded even on machines with different byte order.&lt;br&gt;
              `l64a' can return a string shorter than 6 bytes, so &lt;br&gt;
              we pad it with encoding of 0 ('.') at the end by &lt;br&gt;
              hand. */&lt;br&gt;
         &lt;br&gt;&lt;br&gt;   p = stpcpy (cp, l64a (htonl (len)));&lt;br&gt;
           cp = mempcpy (p, "......", 6 - (p - cp));&lt;br&gt;
         &lt;br&gt;&lt;br&gt;   while (len &gt; 3)&lt;br&gt;
             {&lt;br&gt;
               unsigned long int n = *in++;&lt;br&gt;
               n = (n &lt;&lt; 8) | *in++;&lt;br&gt;
               n = (n &lt;&lt; 8) | *in++;&lt;br&gt;
               n = (n &lt;&lt; 8) | *in++;&lt;br&gt;
               len -= 4;&lt;br&gt;
               p = stpcpy (cp, l64a (htonl (n)));&lt;br&gt;
               cp = mempcpy (p, "......", 6 - (p - cp));&lt;br&gt;
             }&lt;br&gt;
           if (len &gt; 0)&lt;br&gt;
             {&lt;br&gt;
               unsigned long int n = *in++;&lt;br&gt;
               if (--len &gt; 0)&lt;br&gt;
                 {&lt;br&gt;
                   n = (n &lt;&lt; 8) | *in++;&lt;br&gt;
                   if (--len &gt; 0)&lt;br&gt;
                     n = (n &lt;&lt; 8) | *in;&lt;br&gt;
                 }&lt;br&gt;
               cp = stpcpy (cp, l64a (htonl (n)));&lt;br&gt;
             }&lt;br&gt;
           *cp = '\0';&lt;br&gt;
           return out;&lt;br&gt;
         }&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; It is strange that the library does not provide the complete
         functionality needed but so be it.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-a64l" type="function">
    <function returntype="long int">
      <prototype>
        <parameter content="const char *string"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The parameter &lt;VAR&gt;string&lt;/VAR&gt; should contain a string which was produced by
         a call to &lt;CODE&gt;l64a&lt;/CODE&gt;.  The function processes at least 6 characters of
         this string, and decodes the characters it finds according to the table
         below.  It stops decoding when it finds a character not in the table,
         rather like &lt;CODE&gt;atoi&lt;/CODE&gt;; if you have a buffer which has been broken into
         lines, you must be careful to skip over the end-of-line characters.
         &lt;br&gt;&lt;br&gt; The decoded number is returned as a &lt;CODE&gt;long int&lt;/CODE&gt; value.
        </synopsis>
    </function>
  </construct>
  <construct id="function-argz_create" type="function">
    <function returntype="error_t">
      <prototype>
        <parameter content="char *const argv[]"/>
        <parameter content="char **argz"/>
        <parameter content="size_t *argz_len"/>
      </prototype>
      <headers>
        <header filename = "argz.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;argz_create&lt;/CODE&gt; function converts the Unix-style argument vector
         &lt;VAR&gt;argv&lt;/VAR&gt; (a vector of pointers to normal C strings, terminated by
         &lt;CODE&gt;(char *)0&lt;/CODE&gt;; ) into an argz vector with
         the same elements, which is returned in &lt;VAR&gt;argz&lt;/VAR&gt; and &lt;VAR&gt;argz_len&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-argz_create_sep" type="function">
    <function returntype="error_t">
      <prototype>
        <parameter content="const char *string"/>
        <parameter content="int sep"/>
        <parameter content="char **argz"/>
        <parameter content="size_t *argz_len"/>
      </prototype>
      <headers>
        <header filename = "argz.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;argz_create_sep&lt;/CODE&gt; function converts the null-terminated string
         &lt;VAR&gt;string&lt;/VAR&gt; into an argz vector (returned in &lt;VAR&gt;argz&lt;/VAR&gt; and
         &lt;VAR&gt;argz_len&lt;/VAR&gt;) by splitting it into elements at every occurrence of the
         character &lt;VAR&gt;sep&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-argz_count" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="const char *argz"/>
        <parameter content="size_t arg_len"/>
      </prototype>
      <headers>
        <header filename = "argz.h"/>
      </headers>
        <synopsis>
        Returns the number of elements in the argz vector &lt;VAR&gt;argz&lt;/VAR&gt; and
         &lt;VAR&gt;argz_len&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-argz_extract" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="char *argz"/>
        <parameter content="size_t argz_len"/>
        <parameter content="char **argv"/>
      </prototype>
      <headers>
        <header filename = "argz.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;argz_extract&lt;/CODE&gt; function converts the argz vector &lt;VAR&gt;argz&lt;/VAR&gt; and
         &lt;VAR&gt;argz_len&lt;/VAR&gt; into a Unix-style argument vector stored in &lt;VAR&gt;argv&lt;/VAR&gt;,
         by putting pointers to every element in &lt;VAR&gt;argz&lt;/VAR&gt; into successive
         positions in &lt;VAR&gt;argv&lt;/VAR&gt;, followed by a terminator of &lt;CODE&gt;0&lt;/CODE&gt;.
         &lt;VAR&gt;Argv&lt;/VAR&gt; must be pre-allocated with enough space to hold all the
         elements in &lt;VAR&gt;argz&lt;/VAR&gt; plus the terminating &lt;CODE&gt;(char *)0&lt;/CODE&gt;
         (&lt;CODE&gt;(argz_count (&lt;VAR&gt;argz&lt;/VAR&gt;, &lt;VAR&gt;argz_len&lt;/VAR&gt;) + 1) * sizeof (char *)&lt;/CODE&gt;
         bytes should be enough).  Note that the string pointers stored into
         &lt;VAR&gt;argv&lt;/VAR&gt; point into &lt;VAR&gt;argz&lt;/VAR&gt;---they are not copies---and so
         &lt;VAR&gt;argz&lt;/VAR&gt; must be copied if it will be changed while &lt;VAR&gt;argv&lt;/VAR&gt; is
         still active.  This function is useful for passing the elements in
         &lt;VAR&gt;argz&lt;/VAR&gt; to an exec function .
        </synopsis>
    </function>
  </construct>
  <construct id="function-argz_stringify" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="char *argz"/>
        <parameter content="size_t len"/>
        <parameter content="int sep"/>
      </prototype>
      <headers>
        <header filename = "argz.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;argz_stringify&lt;/CODE&gt; converts &lt;VAR&gt;argz&lt;/VAR&gt; into a normal string with
         the elements separated by the character &lt;VAR&gt;sep&lt;/VAR&gt;, by replacing each
         &lt;CODE&gt;'\0'&lt;/CODE&gt; inside &lt;VAR&gt;argz&lt;/VAR&gt; (except the last one, which terminates the
         string) with &lt;VAR&gt;sep&lt;/VAR&gt;.  This is handy for printing &lt;VAR&gt;argz&lt;/VAR&gt; in a
         readable manner.
        </synopsis>
    </function>
  </construct>
  <construct id="function-argz_add" type="function">
    <function returntype="error_t">
      <prototype>
        <parameter content="char **argz"/>
        <parameter content="size_t *argz_len"/>
        <parameter content="const char *str"/>
      </prototype>
      <headers>
        <header filename = "argz.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;argz_add&lt;/CODE&gt; function adds the string &lt;VAR&gt;str&lt;/VAR&gt; to the end of the
         argz vector &lt;CODE&gt;*&lt;VAR&gt;argz&lt;/VAR&gt;&lt;/CODE&gt;, and updates &lt;CODE&gt;*&lt;VAR&gt;argz&lt;/VAR&gt;&lt;/CODE&gt; and
         &lt;CODE&gt;*&lt;VAR&gt;argz_len&lt;/VAR&gt;&lt;/CODE&gt; accordingly.
        </synopsis>
    </function>
  </construct>
  <construct id="function-argz_add_sep" type="function">
    <function returntype="error_t">
      <prototype>
        <parameter content="char **argz"/>
        <parameter content="size_t *argz_len"/>
        <parameter content="const char *str"/>
        <parameter content="int delim"/>
      </prototype>
      <headers>
        <header filename = "argz.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;argz_add_sep&lt;/CODE&gt; function is similar to &lt;CODE&gt;argz_add&lt;/CODE&gt;, but
         &lt;VAR&gt;str&lt;/VAR&gt; is split into separate elements in the result at occurrences of
         the character &lt;VAR&gt;delim&lt;/VAR&gt;.  This is useful, for instance, for
         adding the components of a Unix search path to an argz vector, by using
         a value of &lt;CODE&gt;':'&lt;/CODE&gt; for &lt;VAR&gt;delim&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-argz_append" type="function">
    <function returntype="error_t">
      <prototype>
        <parameter content="char **argz"/>
        <parameter content="size_t *argz_len"/>
        <parameter content="const char *buf"/>
        <parameter content="size_t buf_len"/>
      </prototype>
      <headers>
        <header filename = "argz.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;argz_append&lt;/CODE&gt; function appends &lt;VAR&gt;buf_len&lt;/VAR&gt; bytes starting at
         &lt;VAR&gt;buf&lt;/VAR&gt; to the argz vector &lt;CODE&gt;*&lt;VAR&gt;argz&lt;/VAR&gt;&lt;/CODE&gt;, reallocating
         &lt;CODE&gt;*&lt;VAR&gt;argz&lt;/VAR&gt;&lt;/CODE&gt; to accommodate it, and adding &lt;VAR&gt;buf_len&lt;/VAR&gt; to
         &lt;CODE&gt;*&lt;VAR&gt;argz_len&lt;/VAR&gt;&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-argz_delete" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="char **argz"/>
        <parameter content="size_t *argz_len"/>
        <parameter content="char *entry"/>
      </prototype>
      <headers>
        <header filename = "argz.h"/>
      </headers>
        <synopsis>
        If &lt;VAR&gt;entry&lt;/VAR&gt; points to the beginning of one of the elements in the
         argz vector &lt;CODE&gt;*&lt;VAR&gt;argz&lt;/VAR&gt;&lt;/CODE&gt;, the &lt;CODE&gt;argz_delete&lt;/CODE&gt; function will
         remove this entry and reallocate &lt;CODE&gt;*&lt;VAR&gt;argz&lt;/VAR&gt;&lt;/CODE&gt;, modifying
         &lt;CODE&gt;*&lt;VAR&gt;argz&lt;/VAR&gt;&lt;/CODE&gt; and &lt;CODE&gt;*&lt;VAR&gt;argz_len&lt;/VAR&gt;&lt;/CODE&gt; accordingly.  Note that as
         destructive argz functions usually reallocate their argz argument,
         pointers into argz vectors such as &lt;VAR&gt;entry&lt;/VAR&gt; will then become invalid.
        </synopsis>
    </function>
  </construct>
  <construct id="function-argz_insert" type="function">
    <function returntype="error_t">
      <prototype>
        <parameter content="char **argz"/>
        <parameter content="size_t *argz_len"/>
        <parameter content="char *before"/>
        <parameter content="const char *entry"/>
      </prototype>
      <headers>
        <header filename = "argz.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;argz_insert&lt;/CODE&gt; function inserts the string &lt;VAR&gt;entry&lt;/VAR&gt; into the
         argz vector &lt;CODE&gt;*&lt;VAR&gt;argz&lt;/VAR&gt;&lt;/CODE&gt; at a point just before the existing
         element pointed to by &lt;VAR&gt;before&lt;/VAR&gt;, reallocating &lt;CODE&gt;*&lt;VAR&gt;argz&lt;/VAR&gt;&lt;/CODE&gt; and
         updating &lt;CODE&gt;*&lt;VAR&gt;argz&lt;/VAR&gt;&lt;/CODE&gt; and &lt;CODE&gt;*&lt;VAR&gt;argz_len&lt;/VAR&gt;&lt;/CODE&gt;.  If &lt;VAR&gt;before&lt;/VAR&gt;
         is &lt;CODE&gt;0&lt;/CODE&gt;, &lt;VAR&gt;entry&lt;/VAR&gt; is added to the end instead (as if by
         &lt;CODE&gt;argz_add&lt;/CODE&gt;).  Since the first element is in fact the same as
         &lt;CODE&gt;*&lt;VAR&gt;argz&lt;/VAR&gt;&lt;/CODE&gt;, passing in &lt;CODE&gt;*&lt;VAR&gt;argz&lt;/VAR&gt;&lt;/CODE&gt; as the value of
         &lt;VAR&gt;before&lt;/VAR&gt; will result in &lt;VAR&gt;entry&lt;/VAR&gt; being inserted at the beginning.
        </synopsis>
    </function>
  </construct>
  <construct id="function-argz_next" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="char *argz"/>
        <parameter content="size_t argz_len"/>
        <parameter content="const char *entry"/>
      </prototype>
      <headers>
        <header filename = "argz.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;argz_next&lt;/CODE&gt; function provides a convenient way of iterating
         over the elements in the argz vector &lt;VAR&gt;argz&lt;/VAR&gt;.  It returns a pointer
         to the next element in &lt;VAR&gt;argz&lt;/VAR&gt; after the element &lt;VAR&gt;entry&lt;/VAR&gt;, or
         &lt;CODE&gt;0&lt;/CODE&gt; if there are no elements following &lt;VAR&gt;entry&lt;/VAR&gt;.  If &lt;VAR&gt;entry&lt;/VAR&gt;
         is &lt;CODE&gt;0&lt;/CODE&gt;, the first element of &lt;VAR&gt;argz&lt;/VAR&gt; is returned.
         &lt;br&gt;&lt;br&gt; This behavior suggests two styles of iteration:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
             char *entry = 0;&lt;br&gt;
             while ((entry = argz_next (&lt;VAR&gt;argz&lt;/VAR&gt;, &lt;VAR&gt;argz_len&lt;/VAR&gt;, entry)))&lt;br&gt;
               &lt;VAR&gt;action&lt;/VAR&gt;;&lt;br&gt;
         &lt;/pre&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; (the double parentheses are necessary to make some C compilers shut up&lt;br&gt;
         about what they consider a questionable &lt;CODE&gt;while&lt;/CODE&gt;-test) and:&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
             char *entry;&lt;br&gt;
             for (entry = &lt;VAR&gt;argz&lt;/VAR&gt;;&lt;br&gt;
                  entry;&lt;br&gt;
                  entry = argz_next (&lt;VAR&gt;argz&lt;/VAR&gt;, &lt;VAR&gt;argz_len&lt;/VAR&gt;, entry))&lt;br&gt;
               &lt;VAR&gt;action&lt;/VAR&gt;;&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; Note that the latter depends on &lt;VAR&gt;argz&lt;/VAR&gt; having a value of &lt;CODE&gt;0&lt;/CODE&gt; if
         it is empty (rather than a pointer to an empty block of memory); this
         invariant is maintained for argz vectors created by the functions here.
        </synopsis>
    </function>
  </construct>
  <construct id="function-argz_replace" type="function">
    <function returntype="error_t">
      <prototype>
      </prototype>
      <headers>
        <header filename = "argz.h"/>
      </headers>
        <synopsis>
        Replace any occurrences of the string &lt;VAR&gt;str&lt;/VAR&gt; in &lt;VAR&gt;argz&lt;/VAR&gt; with
         &lt;VAR&gt;with&lt;/VAR&gt;, reallocating &lt;VAR&gt;argz&lt;/VAR&gt; as necessary.  If
         &lt;VAR&gt;replace_count&lt;/VAR&gt; is non-zero, &lt;CODE&gt;*&lt;VAR&gt;replace_count&lt;/VAR&gt;&lt;/CODE&gt; will be
         incremented by number of replacements performed.
        </synopsis>
    </function>
  </construct>
  <construct id="function-envz_entry" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *envz"/>
        <parameter content="size_t envz_len"/>
        <parameter content="const char *name"/>
      </prototype>
      <headers>
        <header filename = "envz.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;envz_entry&lt;/CODE&gt; function finds the entry in &lt;VAR&gt;envz&lt;/VAR&gt; with the name
         &lt;VAR&gt;name&lt;/VAR&gt;, and returns a pointer to the whole entry---that is, the argz
         element which begins with &lt;VAR&gt;name&lt;/VAR&gt; followed by a &lt;CODE&gt;'='&lt;/CODE&gt; character.  If
         there is no entry with that name, &lt;CODE&gt;0&lt;/CODE&gt; is returned.
        </synopsis>
    </function>
  </construct>
  <construct id="function-envz_get" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *envz"/>
        <parameter content="size_t envz_len"/>
        <parameter content="const char *name"/>
      </prototype>
      <headers>
        <header filename = "envz.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;envz_get&lt;/CODE&gt; function finds the entry in &lt;VAR&gt;envz&lt;/VAR&gt; with the name
         &lt;VAR&gt;name&lt;/VAR&gt; (like &lt;CODE&gt;envz_entry&lt;/CODE&gt;), and returns a pointer to the value
         portion of that entry (following the &lt;CODE&gt;'='&lt;/CODE&gt;).  If there is no entry with
         that name (or only a null entry), &lt;CODE&gt;0&lt;/CODE&gt; is returned.
        </synopsis>
    </function>
  </construct>
  <construct id="function-envz_add" type="function">
    <function returntype="error_t">
      <prototype>
        <parameter content="char **envz"/>
        <parameter content="size_t *envz_len"/>
        <parameter content="const char *name"/>
        <parameter content="const char *value"/>
      </prototype>
      <headers>
        <header filename = "envz.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;envz_add&lt;/CODE&gt; function adds an entry to &lt;CODE&gt;*&lt;VAR&gt;envz&lt;/VAR&gt;&lt;/CODE&gt;
         (updating &lt;CODE&gt;*&lt;VAR&gt;envz&lt;/VAR&gt;&lt;/CODE&gt; and &lt;CODE&gt;*&lt;VAR&gt;envz_len&lt;/VAR&gt;&lt;/CODE&gt;) with the name
         &lt;VAR&gt;name&lt;/VAR&gt;, and value &lt;VAR&gt;value&lt;/VAR&gt;.  If an entry with the same name
         already exists in &lt;VAR&gt;envz&lt;/VAR&gt;, it is removed first.  If &lt;VAR&gt;value&lt;/VAR&gt; is
         &lt;CODE&gt;0&lt;/CODE&gt;, then the new entry will the special null type of entry
         (mentioned above).
        </synopsis>
    </function>
  </construct>
  <construct id="function-envz_merge" type="function">
    <function returntype="error_t">
      <prototype>
        <parameter content="char **envz"/>
        <parameter content="size_t *envz_len"/>
        <parameter content="const char *envz2"/>
        <parameter content="size_t envz2_len"/>
        <parameter content="int override"/>
      </prototype>
      <headers>
        <header filename = "envz.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;envz_merge&lt;/CODE&gt; function adds each entry in &lt;VAR&gt;envz2&lt;/VAR&gt; to &lt;VAR&gt;envz&lt;/VAR&gt;,
         as if with &lt;CODE&gt;envz_add&lt;/CODE&gt;, updating &lt;CODE&gt;*&lt;VAR&gt;envz&lt;/VAR&gt;&lt;/CODE&gt; and
         &lt;CODE&gt;*&lt;VAR&gt;envz_len&lt;/VAR&gt;&lt;/CODE&gt;.  If &lt;VAR&gt;override&lt;/VAR&gt; is true, then values in &lt;VAR&gt;envz2&lt;/VAR&gt;
         will supersede those with the same name in &lt;VAR&gt;envz&lt;/VAR&gt;, otherwise not.
         &lt;br&gt;&lt;br&gt; Null entries are treated just like other entries in this respect, so a null
         entry in &lt;VAR&gt;envz&lt;/VAR&gt; can prevent an entry of the same name in &lt;VAR&gt;envz2&lt;/VAR&gt; from
         being added to &lt;VAR&gt;envz&lt;/VAR&gt;, if &lt;VAR&gt;override&lt;/VAR&gt; is false.
        </synopsis>
    </function>
  </construct>
  <construct id="function-envz_strip" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="char **envz"/>
        <parameter content="size_t *envz_len"/>
      </prototype>
      <headers>
        <header filename = "envz.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;envz_strip&lt;/CODE&gt; function removes any null entries from &lt;VAR&gt;envz&lt;/VAR&gt;,
         updating &lt;CODE&gt;*&lt;VAR&gt;envz&lt;/VAR&gt;&lt;/CODE&gt; and &lt;CODE&gt;*&lt;VAR&gt;envz_len&lt;/VAR&gt;&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getopt" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int argc"/>
        <parameter content="char **argv"/>
        <parameter content="const char *options"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getopt&lt;/CODE&gt; function gets the next option argument from the
         argument list specified by the &lt;VAR&gt;argv&lt;/VAR&gt; and &lt;VAR&gt;argc&lt;/VAR&gt; arguments.
         Normally these values come directly from the arguments received by
         &lt;CODE&gt;main&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;options&lt;/VAR&gt; argument is a string that specifies the option
         characters that are valid for this program.  An option character in this
         string can be followed by a colon (&lt;samp&gt;:&lt;/samp&gt;) to indicate that it takes a
         required argument.  If an option character is followed by two colons
         (&lt;samp&gt;::&lt;/samp&gt;), its argument is optional; this is a GNU extension.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;getopt&lt;/CODE&gt; has three ways to deal with options that follow
         non-options &lt;VAR&gt;argv&lt;/VAR&gt; elements.  The special argument &lt;samp&gt;--&lt;/samp&gt; forces
         in all cases the end of option scanning.
         &lt;br&gt;&lt;br&gt; &lt;OL&gt;
         &lt;LI&gt;
         The default is to permute the contents of &lt;VAR&gt;argv&lt;/VAR&gt; while scanning it
         so that eventually all the non-options are at the end.  This allows
         options to be given in any order, even with programs that were not
         written to expect this.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         If the &lt;VAR&gt;options&lt;/VAR&gt; argument string begins with a hyphen (&lt;samp&gt;-&lt;/samp&gt;), this
         is treated specially.  It permits arguments that are not options to be
         returned as if they were associated with option character &lt;samp&gt;\1&lt;/samp&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         POSIX demands the following behavior: The first non-option stops option
         processing.  This mode is selected by either setting the environment
         variable &lt;CODE&gt;POSIXLY_CORRECT&lt;/CODE&gt; or beginning the &lt;VAR&gt;options&lt;/VAR&gt; argument
         string with a plus sign (&lt;samp&gt;+&lt;/samp&gt;).
         &lt;/OL&gt;
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;getopt&lt;/CODE&gt; function returns the option character for the next
         command line option.  When no more option arguments are available, it
         returns &lt;CODE&gt;-1&lt;/CODE&gt;.  There may still be more non-option arguments; you
         must compare the external variable &lt;CODE&gt;optind&lt;/CODE&gt; against the &lt;VAR&gt;argc&lt;/VAR&gt;
         parameter to check this.
         &lt;br&gt;&lt;br&gt; If the option has an argument, &lt;CODE&gt;getopt&lt;/CODE&gt; returns the argument by
         storing it in the variable &lt;VAR&gt;optarg&lt;/VAR&gt;.  You don't ordinarily need to
         copy the &lt;CODE&gt;optarg&lt;/CODE&gt; string, since it is a pointer into the original
         &lt;VAR&gt;argv&lt;/VAR&gt; array, not into a static area that might be overwritten.
         &lt;br&gt;&lt;br&gt; If &lt;CODE&gt;getopt&lt;/CODE&gt; finds an option character in &lt;VAR&gt;argv&lt;/VAR&gt; that was not
         included in &lt;VAR&gt;options&lt;/VAR&gt;, or a missing option argument, it returns
         &lt;samp&gt;?&lt;/samp&gt; and sets the external variable &lt;CODE&gt;optopt&lt;/CODE&gt; to the actual
         option character.  If the first character of &lt;VAR&gt;options&lt;/VAR&gt; is a colon
         (&lt;samp&gt;:&lt;/samp&gt;), then &lt;CODE&gt;getopt&lt;/CODE&gt; returns &lt;samp&gt;:&lt;/samp&gt; instead of &lt;samp&gt;?&lt;/samp&gt; to
         indicate a missing option argument.  In addition, if the external
         variable &lt;CODE&gt;opterr&lt;/CODE&gt; is nonzero (which is the default), &lt;CODE&gt;getopt&lt;/CODE&gt;
         prints an error message.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-option" type="struct">
    <structure>
        <synopsis>
        This structure describes a single long option name for the sake of
         &lt;CODE&gt;getopt_long&lt;/CODE&gt;.  The argument &lt;VAR&gt;longopts&lt;/VAR&gt; must be an array of
         these structures, one for each long option.  Terminate the array with an
         element containing all zeros.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;struct option&lt;/CODE&gt; structure has these fields:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="const char *name">
            <synopsis>
            This field is the name of the option.  It is a string.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int has_arg">
            <synopsis>
            This field says whether the option takes an argument.  It is an integer,
             and there are three legitimate values: &lt;CODE&gt;no_argument&lt;/CODE&gt;,
             &lt;CODE&gt;required_argument&lt;/CODE&gt; and &lt;CODE&gt;optional_argument&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int *flag">
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-getopt_long" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int argc"/>
        <parameter content="char *const *argv"/>
        <parameter content="const char *shortopts"/>
        <parameter content="const struct option *longopts"/>
        <parameter content="int *indexptr"/>
      </prototype>
      <headers>
        <header filename = "getopt.h"/>
      </headers>
        <synopsis>
        Decode options from the vector &lt;VAR&gt;argv&lt;/VAR&gt; (whose length is &lt;VAR&gt;argc&lt;/VAR&gt;).
         The argument &lt;VAR&gt;shortopts&lt;/VAR&gt; describes the short options to accept, just as
         it does in &lt;CODE&gt;getopt&lt;/CODE&gt;.  The argument &lt;VAR&gt;longopts&lt;/VAR&gt; describes the long
         options to accept (see above).
         &lt;br&gt;&lt;br&gt; When &lt;CODE&gt;getopt_long&lt;/CODE&gt; encounters a short option, it does the same
         thing that &lt;CODE&gt;getopt&lt;/CODE&gt; would do: it returns the character code for the
         option, and stores the options argument (if it has one) in &lt;CODE&gt;optarg&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; When &lt;CODE&gt;getopt_long&lt;/CODE&gt; encounters a long option, it takes actions based
         on the &lt;CODE&gt;flag&lt;/CODE&gt; and &lt;CODE&gt;val&lt;/CODE&gt; fields of the definition of that
         option.
         &lt;br&gt;&lt;br&gt; If &lt;CODE&gt;flag&lt;/CODE&gt; is a null pointer, then &lt;CODE&gt;getopt_long&lt;/CODE&gt; returns the
         contents of &lt;CODE&gt;val&lt;/CODE&gt; to indicate which option it found.  You should
         arrange distinct values in the &lt;CODE&gt;val&lt;/CODE&gt; field for options with
         different meanings, so you can decode these values after
         &lt;CODE&gt;getopt_long&lt;/CODE&gt; returns.  If the long option is equivalent to a short
         option, you can use the short option's character code in &lt;CODE&gt;val&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; If &lt;CODE&gt;flag&lt;/CODE&gt; is not a null pointer, that means this option should just
         set a flag in the program.  The flag is a variable of type &lt;CODE&gt;int&lt;/CODE&gt;
         that you define.  Put the address of the flag in the &lt;CODE&gt;flag&lt;/CODE&gt; field.
         Put in the &lt;CODE&gt;val&lt;/CODE&gt; field the value you would like this option to
         store in the flag.  In this case, &lt;CODE&gt;getopt_long&lt;/CODE&gt; returns &lt;CODE&gt;0&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; For any long option, &lt;CODE&gt;getopt_long&lt;/CODE&gt; tells you the index in the array
         &lt;VAR&gt;longopts&lt;/VAR&gt; of the options definition, by storing it into
         &lt;CODE&gt;*&lt;VAR&gt;indexptr&lt;/VAR&gt;&lt;/CODE&gt;.  You can get the name of the option with
         &lt;CODE&gt;&lt;VAR&gt;longopts&lt;/VAR&gt;[*&lt;VAR&gt;indexptr&lt;/VAR&gt;].name&lt;/CODE&gt;.  So you can distinguish among
         long options either by the values in their &lt;CODE&gt;val&lt;/CODE&gt; fields or by their
         indices.  You can also distinguish in this way among long options that
         set flags.
         &lt;br&gt;&lt;br&gt; When a long option has an argument, &lt;CODE&gt;getopt_long&lt;/CODE&gt; puts the argument
         value in the variable &lt;CODE&gt;optarg&lt;/CODE&gt; before returning.  When the option
         has no argument, the value in &lt;CODE&gt;optarg&lt;/CODE&gt; is a null pointer.  This is
         how you can tell whether an optional argument was supplied.
         &lt;br&gt;&lt;br&gt; When &lt;CODE&gt;getopt_long&lt;/CODE&gt; has no more options to handle, it returns
         &lt;CODE&gt;-1&lt;/CODE&gt;, and leaves in the variable &lt;CODE&gt;optind&lt;/CODE&gt; the index in
         &lt;VAR&gt;argv&lt;/VAR&gt; of the next remaining argument.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getopt_long_only" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int argc"/>
        <parameter content="char *const *argv"/>
        <parameter content="const char *shortopts"/>
        <parameter content="const struct option *longopts"/>
        <parameter content="int *indexptr"/>
      </prototype>
      <headers>
        <header filename = "getopt.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;getopt_long_only&lt;/CODE&gt; function is equivalent to the
         &lt;CODE&gt;getopt_long&lt;/CODE&gt; function but it allows to specify the user of the
         application to pass long options with only &lt;samp&gt;-&lt;/samp&gt; instead of
         &lt;samp&gt;--&lt;/samp&gt;.  The &lt;samp&gt;--&lt;/samp&gt; prefix is still recognized but instead of
         looking through the short options if a &lt;samp&gt;-&lt;/samp&gt; is seen it is first
         tried whether this parameter names a long option.  If not, it is parsed
         as a short option.
         &lt;br&gt;&lt;br&gt; Assuming &lt;CODE&gt;getopt_long_only&lt;/CODE&gt; is used starting an application with
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
           app -foo&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt;
         the &lt;CODE&gt;getopt_long_only&lt;/CODE&gt; will first look for a long option named
         &lt;samp&gt;foo&lt;/samp&gt;.  If this is not found, the short options &lt;samp&gt;f&lt;/samp&gt;, &lt;samp&gt;o&lt;/samp&gt;,
         and again &lt;samp&gt;o&lt;/samp&gt; are recognized.
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-div_t" type="dtype">
    <structure>
        <synopsis>
        This is a structure type used to hold the result returned by the &lt;CODE&gt;div&lt;/CODE&gt;
         function.  It has the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="int quot">
            <synopsis>
            The quotient from the division.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-div" type="function">
    <function returntype="div_t">
      <prototype>
        <parameter content="int numerator"/>
        <parameter content="int denominator"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        This function &lt;CODE&gt;div&lt;/CODE&gt; computes the quotient and remainder from
         the division of &lt;VAR&gt;numerator&lt;/VAR&gt; by &lt;VAR&gt;denominator&lt;/VAR&gt;, returning the
         result in a structure of type &lt;CODE&gt;div_t&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; If the result cannot be represented (as in a division by zero), the
         behavior is undefined.
         &lt;br&gt;&lt;br&gt; Here is an example, albeit not a very useful one.
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         div_t result;&lt;br&gt;
         result = div (20, -6);&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt;
         Now &lt;CODE&gt;result.quot&lt;/CODE&gt; is &lt;CODE&gt;-3&lt;/CODE&gt; and &lt;CODE&gt;result.rem&lt;/CODE&gt; is &lt;CODE&gt;2&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-ldiv_t" type="dtype">
    <structure>
        <synopsis>
        This is a structure type used to hold the result returned by the &lt;CODE&gt;ldiv&lt;/CODE&gt;
         function.  It has the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="long int quot">
            <synopsis>
            The quotient from the division.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-ldiv" type="function">
    <function returntype="ldiv_t">
      <prototype>
        <parameter content="long int numerator"/>
        <parameter content="long int denominator"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;ldiv&lt;/CODE&gt; function is similar to &lt;CODE&gt;div&lt;/CODE&gt;, except that the
         arguments are of type &lt;CODE&gt;long int&lt;/CODE&gt; and the result is returned as a
         structure of type &lt;CODE&gt;ldiv_t&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-lldiv_t" type="dtype">
    <structure>
        <synopsis>
        This is a structure type used to hold the result returned by the &lt;CODE&gt;lldiv&lt;/CODE&gt;
         function.  It has the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="long long int quot">
            <synopsis>
            The quotient from the division.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-lldiv" type="function">
    <function returntype="lldiv_t">
      <prototype>
        <parameter content="long long int numerator"/>
        <parameter content="long long int denominator"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;lldiv&lt;/CODE&gt; function is like the &lt;CODE&gt;div&lt;/CODE&gt; function, but the
         arguments are of type &lt;CODE&gt;long long int&lt;/CODE&gt; and the result is returned as
         a structure of type &lt;CODE&gt;lldiv_t&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;lldiv&lt;/CODE&gt; function was added in ISO C99.
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-imaxdiv_t" type="dtype">
    <structure>
        <synopsis>
        This is a structure type used to hold the result returned by the &lt;CODE&gt;imaxdiv&lt;/CODE&gt;
         function.  It has the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="intmax_t quot">
            <synopsis>
            The quotient from the division.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-imaxdiv" type="function">
    <function returntype="imaxdiv_t">
      <prototype>
        <parameter content="intmax_t numerator"/>
        <parameter content="intmax_t denominator"/>
      </prototype>
      <headers>
        <header filename = "inttypes.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;imaxdiv&lt;/CODE&gt; function is like the &lt;CODE&gt;div&lt;/CODE&gt; function, but the
         arguments are of type &lt;CODE&gt;intmax_t&lt;/CODE&gt; and the result is returned as
         a structure of type &lt;CODE&gt;imaxdiv_t&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; See Integers for a description of the &lt;CODE&gt;intmax_t&lt;/CODE&gt; type.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;imaxdiv&lt;/CODE&gt; function was added in ISO C99.
        </synopsis>
    </function>
  </construct>
  <construct id="function-isinf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        This function returns &lt;CODE&gt;-1&lt;/CODE&gt; if &lt;VAR&gt;x&lt;/VAR&gt; represents negative infinity,
         &lt;CODE&gt;1&lt;/CODE&gt; if &lt;VAR&gt;x&lt;/VAR&gt; represents positive infinity, and &lt;CODE&gt;0&lt;/CODE&gt; otherwise.
        </synopsis>
    </function>
  </construct>
  <construct id="function-isinff" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        This function returns &lt;CODE&gt;-1&lt;/CODE&gt; if &lt;VAR&gt;x&lt;/VAR&gt; represents negative infinity,
         &lt;CODE&gt;1&lt;/CODE&gt; if &lt;VAR&gt;x&lt;/VAR&gt; represents positive infinity, and &lt;CODE&gt;0&lt;/CODE&gt; otherwise.
        </synopsis>
    </function>
  </construct>
  <construct id="function-isinfl" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        This function returns &lt;CODE&gt;-1&lt;/CODE&gt; if &lt;VAR&gt;x&lt;/VAR&gt; represents negative infinity,
         &lt;CODE&gt;1&lt;/CODE&gt; if &lt;VAR&gt;x&lt;/VAR&gt; represents positive infinity, and &lt;CODE&gt;0&lt;/CODE&gt; otherwise.
        </synopsis>
    </function>
  </construct>
  <construct id="function-isnan" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        This function returns a nonzero value if &lt;VAR&gt;x&lt;/VAR&gt; is a ``not a number''
         value, and zero otherwise.
         &lt;br&gt;&lt;br&gt; NB: The &lt;CODE&gt;isnan&lt;/CODE&gt; macro defined by ISO C99 overrides
         the BSD function.  This is normally not a problem, because the two
         routines behave identically.  However, if you really need to get the BSD
         function for some reason, you can write
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         (isnan) (x)&lt;br&gt;
         &lt;/pre&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-isnanf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        This function returns a nonzero value if &lt;VAR&gt;x&lt;/VAR&gt; is a ``not a number''
         value, and zero otherwise.
         &lt;br&gt;&lt;br&gt; NB: The &lt;CODE&gt;isnan&lt;/CODE&gt; macro defined by ISO C99 overrides
         the BSD function.  This is normally not a problem, because the two
         routines behave identically.  However, if you really need to get the BSD
         function for some reason, you can write
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         (isnan) (x)&lt;br&gt;
         &lt;/pre&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-isnanl" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        This function returns a nonzero value if &lt;VAR&gt;x&lt;/VAR&gt; is a ``not a number''
         value, and zero otherwise.
         &lt;br&gt;&lt;br&gt; NB: The &lt;CODE&gt;isnan&lt;/CODE&gt; macro defined by ISO C99 overrides
         the BSD function.  This is normally not a problem, because the two
         routines behave identically.  However, if you really need to get the BSD
         function for some reason, you can write
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         (isnan) (x)&lt;br&gt;
         &lt;/pre&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-finite" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        This function returns a nonzero value if &lt;VAR&gt;x&lt;/VAR&gt; is finite or a ``not a
         number'' value, and zero otherwise.
        </synopsis>
    </function>
  </construct>
  <construct id="function-finitef" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        This function returns a nonzero value if &lt;VAR&gt;x&lt;/VAR&gt; is finite or a ``not a
         number'' value, and zero otherwise.
        </synopsis>
    </function>
  </construct>
  <construct id="function-finitel" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        This function returns a nonzero value if &lt;VAR&gt;x&lt;/VAR&gt; is finite or a ``not a
         number'' value, and zero otherwise.
        </synopsis>
    </function>
  </construct>
  <construct id="function-feclearexcept" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int excepts"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
        <header filename = "fenv.h"/>
      </headers>
        <synopsis>
        This function clears all of the supported exception flags indicated by
         &lt;VAR&gt;excepts&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The function returns zero in case the operation was successful, a
         non-zero value otherwise.
        </synopsis>
    </function>
  </construct>
  <construct id="function-feraiseexcept" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int excepts"/>
      </prototype>
      <headers>
        <header filename = "fenv.h"/>
      </headers>
        <synopsis>
        This function raises the supported exceptions indicated by
         &lt;VAR&gt;excepts&lt;/VAR&gt;.  If more than one exception bit in &lt;VAR&gt;excepts&lt;/VAR&gt; is set
         the order in which the exceptions are raised is undefined except that
         overflow (&lt;CODE&gt;FE_OVERFLOW&lt;/CODE&gt;) or underflow (&lt;CODE&gt;FE_UNDERFLOW&lt;/CODE&gt;) are
         raised before inexact (&lt;CODE&gt;FE_INEXACT&lt;/CODE&gt;).  Whether for overflow or
         underflow the inexact exception is also raised is also implementation
         dependent.
         &lt;br&gt;&lt;br&gt; The function returns zero in case the operation was successful, a
         non-zero value otherwise.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fetestexcept" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int excepts"/>
      </prototype>
      <headers>
        <header filename = "fenv.h"/>
      </headers>
        <synopsis>
        Test whether the exception flags indicated by the parameter &lt;VAR&gt;except&lt;/VAR&gt;
         are currently set.  If any of them are, a nonzero value is returned
         which specifies which exceptions are set.  Otherwise the result is zero.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fegetexceptflag" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="fexcept_t *flagp"/>
        <parameter content="int excepts"/>
      </prototype>
      <headers>
        <header filename = "fenv.h"/>
      </headers>
        <synopsis>
        This function stores in the variable pointed to by &lt;VAR&gt;flagp&lt;/VAR&gt; an
         implementation-defined value representing the current setting of the
         exception flags indicated by &lt;VAR&gt;excepts&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The function returns zero in case the operation was successful, a
         non-zero value otherwise.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fesetexceptflag" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const fexcept_t *flagp"/>
        <parameter content="int excepts"/>
      </prototype>
      <headers>
        <header filename = "fenv.h"/>
      </headers>
        <synopsis>
        This function restores the flags for the exceptions indicated by
         &lt;VAR&gt;excepts&lt;/VAR&gt; to the values stored in the variable pointed to by
         &lt;VAR&gt;flagp&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The function returns zero in case the operation was successful, a
         non-zero value otherwise.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fegetround" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
        <header filename = "fenv.h"/>
      </headers>
        <synopsis>
        Returns the currently selected rounding mode, represented by one of the
         values of the defined rounding mode macros.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fesetround" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int round"/>
      </prototype>
      <headers>
        <header filename = "fenv.h"/>
      </headers>
        <synopsis>
        Changes the currently selected rounding mode to &lt;VAR&gt;round&lt;/VAR&gt;.  If
         &lt;VAR&gt;round&lt;/VAR&gt; does not correspond to one of the supported rounding modes
         nothing is changed.  &lt;CODE&gt;fesetround&lt;/CODE&gt; returns zero if it changed the
         rounding mode, a nonzero value if the mode is not supported.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fegetenv" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="fenv_t *envp"/>
      </prototype>
      <headers>
        <header filename = "fenv.h"/>
      </headers>
        <synopsis>
        Store the floating-point environment in the variable pointed to by
         &lt;VAR&gt;envp&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The function returns zero in case the operation was successful, a
         non-zero value otherwise.
        </synopsis>
    </function>
  </construct>
  <construct id="function-feholdexcept" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="fenv_t *envp"/>
      </prototype>
      <headers>
        <header filename = "fenv.h"/>
      </headers>
        <synopsis>
        Store the current floating-point environment in the object pointed to by
         &lt;VAR&gt;envp&lt;/VAR&gt;.  Then clear all exception flags, and set the FPU to trap no
         exceptions.  Not all FPUs support trapping no exceptions; if
         &lt;CODE&gt;feholdexcept&lt;/CODE&gt; cannot set this mode, it returns nonzero value.  If it
         succeeds, it returns zero.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fesetenv" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const fenv_t *envp"/>
      </prototype>
      <headers>
        <header filename = "fenv.h"/>
      </headers>
        <synopsis>
        Set the floating-point environment to that described by &lt;VAR&gt;envp&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The function returns zero in case the operation was successful, a
         non-zero value otherwise.
        </synopsis>
    </function>
  </construct>
  <construct id="function-feupdateenv" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const fenv_t *envp"/>
      </prototype>
      <headers>
        <header filename = "fenv.h"/>
      </headers>
        <synopsis>
        Like &lt;CODE&gt;fesetenv&lt;/CODE&gt;, this function sets the floating-point environment
         to that described by &lt;VAR&gt;envp&lt;/VAR&gt;.  However, if any exceptions were
         flagged in the status word before &lt;CODE&gt;feupdateenv&lt;/CODE&gt; was called, they
         remain flagged after the call.  In other words, after &lt;CODE&gt;feupdateenv&lt;/CODE&gt;
         is called, the status word is the bitwise OR of the previous status word
         and the one saved in &lt;VAR&gt;envp&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The function returns zero in case the operation was successful, a
         non-zero value otherwise.
        </synopsis>
    </function>
  </construct>
  <construct id="function-feenableexcept" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int excepts"/>
      </prototype>
      <headers>
        <header filename = "fenv.h"/>
      </headers>
        <synopsis>
        This functions enables traps for each of the exceptions as indicated by
         the parameter &lt;VAR&gt;except&lt;/VAR&gt;.  The individual excepetions are described in
         Status bit operations.  Only the specified exceptions are
         enabled, the status of the other exceptions is not changed.
         &lt;br&gt;&lt;br&gt; The function returns the previous enabled exceptions in case the
         operation was successful, &lt;CODE&gt;-1&lt;/CODE&gt; otherwise.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fedisableexcept" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int excepts"/>
      </prototype>
      <headers>
        <header filename = "fenv.h"/>
      </headers>
        <synopsis>
        This functions disables traps for each of the exceptions as indicated by
         the parameter &lt;VAR&gt;except&lt;/VAR&gt;.  The individual excepetions are described in
         Status bit operations.  Only the specified exceptions are
         disabled, the status of the other exceptions is not changed.
         &lt;br&gt;&lt;br&gt; The function returns the previous enabled exceptions in case the
         operation was successful, &lt;CODE&gt;-1&lt;/CODE&gt; otherwise.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fegetexcept" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int excepts"/>
      </prototype>
      <headers>
        <header filename = "fenv.h"/>
      </headers>
        <synopsis>
        The function returns a bitmask of all currently enabled exceptions.  It
         returns &lt;CODE&gt;-1&lt;/CODE&gt; in case of failure.
        </synopsis>
    </function>
  </construct>
  <construct id="function-abs" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int number"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        These functions return the absolute value of &lt;VAR&gt;number&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; Most computers use a two's complement integer representation, in which
         the absolute value of &lt;CODE&gt;INT_MIN&lt;/CODE&gt; (the smallest possible &lt;CODE&gt;int&lt;/CODE&gt;)
         cannot be represented; thus, &lt;CODE&gt;abs (INT_MIN)&lt;/CODE&gt; is not defined.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;llabs&lt;/CODE&gt; and &lt;CODE&gt;imaxdiv&lt;/CODE&gt; are new to ISO C99.
         &lt;br&gt;&lt;br&gt; See Integers for a description of the &lt;CODE&gt;intmax_t&lt;/CODE&gt; type.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-labs" type="function">
    <function returntype="long int">
      <prototype>
        <parameter content="long int number"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        These functions return the absolute value of &lt;VAR&gt;number&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; Most computers use a two's complement integer representation, in which
         the absolute value of &lt;CODE&gt;INT_MIN&lt;/CODE&gt; (the smallest possible &lt;CODE&gt;int&lt;/CODE&gt;)
         cannot be represented; thus, &lt;CODE&gt;abs (INT_MIN)&lt;/CODE&gt; is not defined.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;llabs&lt;/CODE&gt; and &lt;CODE&gt;imaxdiv&lt;/CODE&gt; are new to ISO C99.
         &lt;br&gt;&lt;br&gt; See Integers for a description of the &lt;CODE&gt;intmax_t&lt;/CODE&gt; type.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-llabs" type="function">
    <function returntype="long long int">
      <prototype>
        <parameter content="long long int number"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        These functions return the absolute value of &lt;VAR&gt;number&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; Most computers use a two's complement integer representation, in which
         the absolute value of &lt;CODE&gt;INT_MIN&lt;/CODE&gt; (the smallest possible &lt;CODE&gt;int&lt;/CODE&gt;)
         cannot be represented; thus, &lt;CODE&gt;abs (INT_MIN)&lt;/CODE&gt; is not defined.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;llabs&lt;/CODE&gt; and &lt;CODE&gt;imaxdiv&lt;/CODE&gt; are new to ISO C99.
         &lt;br&gt;&lt;br&gt; See Integers for a description of the &lt;CODE&gt;intmax_t&lt;/CODE&gt; type.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-imaxabs" type="function">
    <function returntype="intmax_t">
      <prototype>
        <parameter content="intmax_t number"/>
      </prototype>
      <headers>
        <header filename = "inttypes.h"/>
      </headers>
        <synopsis>
        These functions return the absolute value of &lt;VAR&gt;number&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; Most computers use a two's complement integer representation, in which
         the absolute value of &lt;CODE&gt;INT_MIN&lt;/CODE&gt; (the smallest possible &lt;CODE&gt;int&lt;/CODE&gt;)
         cannot be represented; thus, &lt;CODE&gt;abs (INT_MIN)&lt;/CODE&gt; is not defined.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;llabs&lt;/CODE&gt; and &lt;CODE&gt;imaxdiv&lt;/CODE&gt; are new to ISO C99.
         &lt;br&gt;&lt;br&gt; See Integers for a description of the &lt;CODE&gt;intmax_t&lt;/CODE&gt; type.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-fabs" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double number"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        This function returns the absolute value of the floating-point number
         &lt;VAR&gt;number&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fabsf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float number"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        This function returns the absolute value of the floating-point number
         &lt;VAR&gt;number&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fabsl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double number"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        This function returns the absolute value of the floating-point number
         &lt;VAR&gt;number&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cabs" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="complex double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the absolute  value of the complex number &lt;VAR&gt;z&lt;/VAR&gt;
         .  The absolute value of a complex number is:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         sqrt (creal (&lt;VAR&gt;z&lt;/VAR&gt;) * creal (&lt;VAR&gt;z&lt;/VAR&gt;) + cimag (&lt;VAR&gt;z&lt;/VAR&gt;) * cimag (&lt;VAR&gt;z&lt;/VAR&gt;))&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; This function should always be used instead of the direct formula
         because it takes special care to avoid losing precision.  It may also
         take advantage of hardware support for this operation. See &lt;CODE&gt;hypot&lt;/CODE&gt;
         in Exponents and Logarithms.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cabsf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="complex float z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the absolute  value of the complex number &lt;VAR&gt;z&lt;/VAR&gt;
         .  The absolute value of a complex number is:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         sqrt (creal (&lt;VAR&gt;z&lt;/VAR&gt;) * creal (&lt;VAR&gt;z&lt;/VAR&gt;) + cimag (&lt;VAR&gt;z&lt;/VAR&gt;) * cimag (&lt;VAR&gt;z&lt;/VAR&gt;))&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; This function should always be used instead of the direct formula
         because it takes special care to avoid losing precision.  It may also
         take advantage of hardware support for this operation. See &lt;CODE&gt;hypot&lt;/CODE&gt;
         in Exponents and Logarithms.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cabsl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="complex long double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the absolute  value of the complex number &lt;VAR&gt;z&lt;/VAR&gt;
         .  The absolute value of a complex number is:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         sqrt (creal (&lt;VAR&gt;z&lt;/VAR&gt;) * creal (&lt;VAR&gt;z&lt;/VAR&gt;) + cimag (&lt;VAR&gt;z&lt;/VAR&gt;) * cimag (&lt;VAR&gt;z&lt;/VAR&gt;))&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; This function should always be used instead of the direct formula
         because it takes special care to avoid losing precision.  It may also
         take advantage of hardware support for this operation. See &lt;CODE&gt;hypot&lt;/CODE&gt;
         in Exponents and Logarithms.
        </synopsis>
    </function>
  </construct>
  <construct id="function-frexp" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double value"/>
        <parameter content="int *exponent"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions are used to split the number &lt;VAR&gt;value&lt;/VAR&gt;
         into a normalized fraction and an exponent.
         &lt;br&gt;&lt;br&gt; If the argument &lt;VAR&gt;value&lt;/VAR&gt; is not zero, the return value is &lt;VAR&gt;value&lt;/VAR&gt;
         times a power of two, and is always in the range 1/2 (inclusive) to 1
         (exclusive).  The corresponding exponent is stored in
         &lt;CODE&gt;*&lt;VAR&gt;exponent&lt;/VAR&gt;&lt;/CODE&gt;; the return value multiplied by 2 raised to this
         exponent equals the original number &lt;VAR&gt;value&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; For example, &lt;CODE&gt;frexp (12.8, &amp;exponent)&lt;/CODE&gt; returns &lt;CODE&gt;0.8&lt;/CODE&gt; and
         stores &lt;CODE&gt;4&lt;/CODE&gt; in &lt;CODE&gt;exponent&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;value&lt;/VAR&gt; is zero, then the return value is zero and
         zero is stored in &lt;CODE&gt;*&lt;VAR&gt;exponent&lt;/VAR&gt;&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-frexpf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float value"/>
        <parameter content="int *exponent"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions are used to split the number &lt;VAR&gt;value&lt;/VAR&gt;
         into a normalized fraction and an exponent.
         &lt;br&gt;&lt;br&gt; If the argument &lt;VAR&gt;value&lt;/VAR&gt; is not zero, the return value is &lt;VAR&gt;value&lt;/VAR&gt;
         times a power of two, and is always in the range 1/2 (inclusive) to 1
         (exclusive).  The corresponding exponent is stored in
         &lt;CODE&gt;*&lt;VAR&gt;exponent&lt;/VAR&gt;&lt;/CODE&gt;; the return value multiplied by 2 raised to this
         exponent equals the original number &lt;VAR&gt;value&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; For example, &lt;CODE&gt;frexp (12.8, &amp;exponent)&lt;/CODE&gt; returns &lt;CODE&gt;0.8&lt;/CODE&gt; and
         stores &lt;CODE&gt;4&lt;/CODE&gt; in &lt;CODE&gt;exponent&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;value&lt;/VAR&gt; is zero, then the return value is zero and
         zero is stored in &lt;CODE&gt;*&lt;VAR&gt;exponent&lt;/VAR&gt;&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-frexpl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double value"/>
        <parameter content="int *exponent"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions are used to split the number &lt;VAR&gt;value&lt;/VAR&gt;
         into a normalized fraction and an exponent.
         &lt;br&gt;&lt;br&gt; If the argument &lt;VAR&gt;value&lt;/VAR&gt; is not zero, the return value is &lt;VAR&gt;value&lt;/VAR&gt;
         times a power of two, and is always in the range 1/2 (inclusive) to 1
         (exclusive).  The corresponding exponent is stored in
         &lt;CODE&gt;*&lt;VAR&gt;exponent&lt;/VAR&gt;&lt;/CODE&gt;; the return value multiplied by 2 raised to this
         exponent equals the original number &lt;VAR&gt;value&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; For example, &lt;CODE&gt;frexp (12.8, &amp;exponent)&lt;/CODE&gt; returns &lt;CODE&gt;0.8&lt;/CODE&gt; and
         stores &lt;CODE&gt;4&lt;/CODE&gt; in &lt;CODE&gt;exponent&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;value&lt;/VAR&gt; is zero, then the return value is zero and
         zero is stored in &lt;CODE&gt;*&lt;VAR&gt;exponent&lt;/VAR&gt;&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ldexp" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double value"/>
        <parameter content="int exponent"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the result of multiplying the floating-point
         number &lt;VAR&gt;value&lt;/VAR&gt; by 2 raised to the power &lt;VAR&gt;exponent&lt;/VAR&gt;.  (It can
         be used to reassemble floating-point numbers that were taken apart
         by &lt;CODE&gt;frexp&lt;/CODE&gt;.)
         &lt;br&gt;&lt;br&gt; For example, &lt;CODE&gt;ldexp (0.8, 4)&lt;/CODE&gt; returns &lt;CODE&gt;12.8&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ldexpf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float value"/>
        <parameter content="int exponent"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the result of multiplying the floating-point
         number &lt;VAR&gt;value&lt;/VAR&gt; by 2 raised to the power &lt;VAR&gt;exponent&lt;/VAR&gt;.  (It can
         be used to reassemble floating-point numbers that were taken apart
         by &lt;CODE&gt;frexp&lt;/CODE&gt;.)
         &lt;br&gt;&lt;br&gt; For example, &lt;CODE&gt;ldexp (0.8, 4)&lt;/CODE&gt; returns &lt;CODE&gt;12.8&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ldexpl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double value"/>
        <parameter content="int exponent"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the result of multiplying the floating-point
         number &lt;VAR&gt;value&lt;/VAR&gt; by 2 raised to the power &lt;VAR&gt;exponent&lt;/VAR&gt;.  (It can
         be used to reassemble floating-point numbers that were taken apart
         by &lt;CODE&gt;frexp&lt;/CODE&gt;.)
         &lt;br&gt;&lt;br&gt; For example, &lt;CODE&gt;ldexp (0.8, 4)&lt;/CODE&gt; returns &lt;CODE&gt;12.8&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-scalb" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double value"/>
        <parameter content="int exponent"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;scalb&lt;/CODE&gt; function is the BSD name for &lt;CODE&gt;ldexp&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-scalbf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float value"/>
        <parameter content="int exponent"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;scalb&lt;/CODE&gt; function is the BSD name for &lt;CODE&gt;ldexp&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-scalbl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double value"/>
        <parameter content="int exponent"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;scalb&lt;/CODE&gt; function is the BSD name for &lt;CODE&gt;ldexp&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-scalbn" type="function">
    <function returntype="long long int">
      <prototype>
        <parameter content="double x"/>
        <parameter content="int n"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;scalbn&lt;/CODE&gt; is identical to &lt;CODE&gt;scalb&lt;/CODE&gt;, except that the exponent
         &lt;VAR&gt;n&lt;/VAR&gt; is an &lt;CODE&gt;int&lt;/CODE&gt; instead of a floating-point number.
        </synopsis>
    </function>
  </construct>
  <construct id="function-scalbnf" type="function">
    <function returntype="long long int">
      <prototype>
        <parameter content="float x"/>
        <parameter content="int n"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;scalbn&lt;/CODE&gt; is identical to &lt;CODE&gt;scalb&lt;/CODE&gt;, except that the exponent
         &lt;VAR&gt;n&lt;/VAR&gt; is an &lt;CODE&gt;int&lt;/CODE&gt; instead of a floating-point number.
        </synopsis>
    </function>
  </construct>
  <construct id="function-scalbnl" type="function">
    <function returntype="long long int">
      <prototype>
        <parameter content="long double x"/>
        <parameter content="int n"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;scalbn&lt;/CODE&gt; is identical to &lt;CODE&gt;scalb&lt;/CODE&gt;, except that the exponent
         &lt;VAR&gt;n&lt;/VAR&gt; is an &lt;CODE&gt;int&lt;/CODE&gt; instead of a floating-point number.
        </synopsis>
    </function>
  </construct>
  <construct id="function-scalbln" type="function">
    <function returntype="long long int">
      <prototype>
        <parameter content="double x"/>
        <parameter content="long int n"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;scalbln&lt;/CODE&gt; is identical to &lt;CODE&gt;scalb&lt;/CODE&gt;, except that the exponent
         &lt;VAR&gt;n&lt;/VAR&gt; is a &lt;CODE&gt;long int&lt;/CODE&gt; instead of a floating-point number.
        </synopsis>
    </function>
  </construct>
  <construct id="function-scalblnf" type="function">
    <function returntype="long long int">
      <prototype>
        <parameter content="float x"/>
        <parameter content="long int n"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;scalbln&lt;/CODE&gt; is identical to &lt;CODE&gt;scalb&lt;/CODE&gt;, except that the exponent
         &lt;VAR&gt;n&lt;/VAR&gt; is a &lt;CODE&gt;long int&lt;/CODE&gt; instead of a floating-point number.
        </synopsis>
    </function>
  </construct>
  <construct id="function-scalblnl" type="function">
    <function returntype="long long int">
      <prototype>
        <parameter content="long double x"/>
        <parameter content="long int n"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;scalbln&lt;/CODE&gt; is identical to &lt;CODE&gt;scalb&lt;/CODE&gt;, except that the exponent
         &lt;VAR&gt;n&lt;/VAR&gt; is a &lt;CODE&gt;long int&lt;/CODE&gt; instead of a floating-point number.
        </synopsis>
    </function>
  </construct>
  <construct id="function-significand" type="function">
    <function returntype="long long int">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;significand&lt;/CODE&gt; returns the mantissa of &lt;VAR&gt;x&lt;/VAR&gt; scaled to the range
         [1, 2).
         It is equivalent to &lt;CODE&gt;scalb (&lt;VAR&gt;x&lt;/VAR&gt;, (double) -ilogb (&lt;VAR&gt;x&lt;/VAR&gt;))&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This function exists mainly for use in certain standardized tests
         of IEEE 754 conformance.
        </synopsis>
    </function>
  </construct>
  <construct id="function-significandf" type="function">
    <function returntype="long long int">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;significand&lt;/CODE&gt; returns the mantissa of &lt;VAR&gt;x&lt;/VAR&gt; scaled to the range
         [1, 2).
         It is equivalent to &lt;CODE&gt;scalb (&lt;VAR&gt;x&lt;/VAR&gt;, (double) -ilogb (&lt;VAR&gt;x&lt;/VAR&gt;))&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This function exists mainly for use in certain standardized tests
         of IEEE 754 conformance.
        </synopsis>
    </function>
  </construct>
  <construct id="function-significandl" type="function">
    <function returntype="long long int">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;significand&lt;/CODE&gt; returns the mantissa of &lt;VAR&gt;x&lt;/VAR&gt; scaled to the range
         [1, 2).
         It is equivalent to &lt;CODE&gt;scalb (&lt;VAR&gt;x&lt;/VAR&gt;, (double) -ilogb (&lt;VAR&gt;x&lt;/VAR&gt;))&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This function exists mainly for use in certain standardized tests
         of IEEE 754 conformance.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ceil" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions round &lt;VAR&gt;x&lt;/VAR&gt; upwards to the nearest integer,
         returning that value as a &lt;CODE&gt;double&lt;/CODE&gt;.  Thus, &lt;CODE&gt;ceil (1.5)&lt;/CODE&gt;
         is &lt;CODE&gt;2.0&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ceilf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions round &lt;VAR&gt;x&lt;/VAR&gt; upwards to the nearest integer,
         returning that value as a &lt;CODE&gt;double&lt;/CODE&gt;.  Thus, &lt;CODE&gt;ceil (1.5)&lt;/CODE&gt;
         is &lt;CODE&gt;2.0&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ceill" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions round &lt;VAR&gt;x&lt;/VAR&gt; upwards to the nearest integer,
         returning that value as a &lt;CODE&gt;double&lt;/CODE&gt;.  Thus, &lt;CODE&gt;ceil (1.5)&lt;/CODE&gt;
         is &lt;CODE&gt;2.0&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-floor" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions round &lt;VAR&gt;x&lt;/VAR&gt; downwards to the nearest
         integer, returning that value as a &lt;CODE&gt;double&lt;/CODE&gt;.  Thus, &lt;CODE&gt;floor
         (1.5)&lt;/CODE&gt; is &lt;CODE&gt;1.0&lt;/CODE&gt; and &lt;CODE&gt;floor (-1.5)&lt;/CODE&gt; is &lt;CODE&gt;-2.0&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-floorf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions round &lt;VAR&gt;x&lt;/VAR&gt; downwards to the nearest
         integer, returning that value as a &lt;CODE&gt;double&lt;/CODE&gt;.  Thus, &lt;CODE&gt;floor
         (1.5)&lt;/CODE&gt; is &lt;CODE&gt;1.0&lt;/CODE&gt; and &lt;CODE&gt;floor (-1.5)&lt;/CODE&gt; is &lt;CODE&gt;-2.0&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-floorl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions round &lt;VAR&gt;x&lt;/VAR&gt; downwards to the nearest
         integer, returning that value as a &lt;CODE&gt;double&lt;/CODE&gt;.  Thus, &lt;CODE&gt;floor
         (1.5)&lt;/CODE&gt; is &lt;CODE&gt;1.0&lt;/CODE&gt; and &lt;CODE&gt;floor (-1.5)&lt;/CODE&gt; is &lt;CODE&gt;-2.0&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-trunc" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;trunc&lt;/CODE&gt; functions round &lt;VAR&gt;x&lt;/VAR&gt; towards zero to the nearest
         integer (returned in floating-point format).  Thus, &lt;CODE&gt;trunc (1.5)&lt;/CODE&gt;
         is &lt;CODE&gt;1.0&lt;/CODE&gt; and &lt;CODE&gt;trunc (-1.5)&lt;/CODE&gt; is &lt;CODE&gt;-1.0&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-truncf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;trunc&lt;/CODE&gt; functions round &lt;VAR&gt;x&lt;/VAR&gt; towards zero to the nearest
         integer (returned in floating-point format).  Thus, &lt;CODE&gt;trunc (1.5)&lt;/CODE&gt;
         is &lt;CODE&gt;1.0&lt;/CODE&gt; and &lt;CODE&gt;trunc (-1.5)&lt;/CODE&gt; is &lt;CODE&gt;-1.0&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-truncl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;trunc&lt;/CODE&gt; functions round &lt;VAR&gt;x&lt;/VAR&gt; towards zero to the nearest
         integer (returned in floating-point format).  Thus, &lt;CODE&gt;trunc (1.5)&lt;/CODE&gt;
         is &lt;CODE&gt;1.0&lt;/CODE&gt; and &lt;CODE&gt;trunc (-1.5)&lt;/CODE&gt; is &lt;CODE&gt;-1.0&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-rint" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions round &lt;VAR&gt;x&lt;/VAR&gt; to an integer value according to the
         current rounding mode.  , for
         information about the various rounding modes.  The default
         rounding mode is to round to the nearest integer; some machines
         support other modes, but round-to-nearest is always used unless
         you explicitly select another.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;x&lt;/VAR&gt; was not initially an integer, these functions raise the
         inexact exception.
        </synopsis>
    </function>
  </construct>
  <construct id="function-rintf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions round &lt;VAR&gt;x&lt;/VAR&gt; to an integer value according to the
         current rounding mode.  , for
         information about the various rounding modes.  The default
         rounding mode is to round to the nearest integer; some machines
         support other modes, but round-to-nearest is always used unless
         you explicitly select another.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;x&lt;/VAR&gt; was not initially an integer, these functions raise the
         inexact exception.
        </synopsis>
    </function>
  </construct>
  <construct id="function-rintl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions round &lt;VAR&gt;x&lt;/VAR&gt; to an integer value according to the
         current rounding mode.  , for
         information about the various rounding modes.  The default
         rounding mode is to round to the nearest integer; some machines
         support other modes, but round-to-nearest is always used unless
         you explicitly select another.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;x&lt;/VAR&gt; was not initially an integer, these functions raise the
         inexact exception.
        </synopsis>
    </function>
  </construct>
  <construct id="function-nearbyint" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the same value as the &lt;CODE&gt;rint&lt;/CODE&gt; functions, but
         do not raise the inexact exception if &lt;VAR&gt;x&lt;/VAR&gt; is not an integer.
        </synopsis>
    </function>
  </construct>
  <construct id="function-nearbyintf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the same value as the &lt;CODE&gt;rint&lt;/CODE&gt; functions, but
         do not raise the inexact exception if &lt;VAR&gt;x&lt;/VAR&gt; is not an integer.
        </synopsis>
    </function>
  </construct>
  <construct id="function-nearbyintl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the same value as the &lt;CODE&gt;rint&lt;/CODE&gt; functions, but
         do not raise the inexact exception if &lt;VAR&gt;x&lt;/VAR&gt; is not an integer.
        </synopsis>
    </function>
  </construct>
  <construct id="function-round" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions are similar to &lt;CODE&gt;rint&lt;/CODE&gt;, but they round halfway
         cases away from zero instead of to the nearest integer (or other
         current rounding mode).
        </synopsis>
    </function>
  </construct>
  <construct id="function-roundf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions are similar to &lt;CODE&gt;rint&lt;/CODE&gt;, but they round halfway
         cases away from zero instead of to the nearest integer (or other
         current rounding mode).
        </synopsis>
    </function>
  </construct>
  <construct id="function-roundl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions are similar to &lt;CODE&gt;rint&lt;/CODE&gt;, but they round halfway
         cases away from zero instead of to the nearest integer (or other
         current rounding mode).
        </synopsis>
    </function>
  </construct>
  <construct id="function-lrint" type="function">
    <function returntype="long int">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions are just like &lt;CODE&gt;rint&lt;/CODE&gt;, but they return a
         &lt;CODE&gt;long int&lt;/CODE&gt; instead of a floating-point number.
        </synopsis>
    </function>
  </construct>
  <construct id="function-lrintf" type="function">
    <function returntype="long int">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions are just like &lt;CODE&gt;rint&lt;/CODE&gt;, but they return a
         &lt;CODE&gt;long int&lt;/CODE&gt; instead of a floating-point number.
        </synopsis>
    </function>
  </construct>
  <construct id="function-lrintl" type="function">
    <function returntype="long int">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions are just like &lt;CODE&gt;rint&lt;/CODE&gt;, but they return a
         &lt;CODE&gt;long int&lt;/CODE&gt; instead of a floating-point number.
        </synopsis>
    </function>
  </construct>
  <construct id="function-llrint" type="function">
    <function returntype="long long int">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions are just like &lt;CODE&gt;rint&lt;/CODE&gt;, but they return a
         &lt;CODE&gt;long long int&lt;/CODE&gt; instead of a floating-point number.
        </synopsis>
    </function>
  </construct>
  <construct id="function-llrintf" type="function">
    <function returntype="long long int">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions are just like &lt;CODE&gt;rint&lt;/CODE&gt;, but they return a
         &lt;CODE&gt;long long int&lt;/CODE&gt; instead of a floating-point number.
        </synopsis>
    </function>
  </construct>
  <construct id="function-llrintl" type="function">
    <function returntype="long long int">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions are just like &lt;CODE&gt;rint&lt;/CODE&gt;, but they return a
         &lt;CODE&gt;long long int&lt;/CODE&gt; instead of a floating-point number.
        </synopsis>
    </function>
  </construct>
  <construct id="function-lround" type="function">
    <function returntype="long int">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions are just like &lt;CODE&gt;round&lt;/CODE&gt;, but they return a
         &lt;CODE&gt;long int&lt;/CODE&gt; instead of a floating-point number.
        </synopsis>
    </function>
  </construct>
  <construct id="function-lroundf" type="function">
    <function returntype="long int">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions are just like &lt;CODE&gt;round&lt;/CODE&gt;, but they return a
         &lt;CODE&gt;long int&lt;/CODE&gt; instead of a floating-point number.
        </synopsis>
    </function>
  </construct>
  <construct id="function-lroundl" type="function">
    <function returntype="long int">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions are just like &lt;CODE&gt;round&lt;/CODE&gt;, but they return a
         &lt;CODE&gt;long int&lt;/CODE&gt; instead of a floating-point number.
        </synopsis>
    </function>
  </construct>
  <construct id="function-llround" type="function">
    <function returntype="long long int">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions are just like &lt;CODE&gt;round&lt;/CODE&gt;, but they return a
         &lt;CODE&gt;long long int&lt;/CODE&gt; instead of a floating-point number.
        </synopsis>
    </function>
  </construct>
  <construct id="function-llroundf" type="function">
    <function returntype="long long int">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions are just like &lt;CODE&gt;round&lt;/CODE&gt;, but they return a
         &lt;CODE&gt;long long int&lt;/CODE&gt; instead of a floating-point number.
        </synopsis>
    </function>
  </construct>
  <construct id="function-llroundl" type="function">
    <function returntype="long long int">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions are just like &lt;CODE&gt;round&lt;/CODE&gt;, but they return a
         &lt;CODE&gt;long long int&lt;/CODE&gt; instead of a floating-point number.
        </synopsis>
    </function>
  </construct>
  <construct id="function-modf" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double value"/>
        <parameter content="double *integer-part"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions break the argument &lt;VAR&gt;value&lt;/VAR&gt; into an integer part and a
         fractional part (between &lt;CODE&gt;-1&lt;/CODE&gt; and &lt;CODE&gt;1&lt;/CODE&gt;, exclusive).  Their sum
         equals &lt;VAR&gt;value&lt;/VAR&gt;.  Each of the parts has the same sign as &lt;VAR&gt;value&lt;/VAR&gt;,
         and the integer part is always rounded toward zero.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;modf&lt;/CODE&gt; stores the integer part in &lt;CODE&gt;*&lt;VAR&gt;integer-part&lt;/VAR&gt;&lt;/CODE&gt;, and
         returns the fractional part.  For example, &lt;CODE&gt;modf (2.5, &amp;intpart)&lt;/CODE&gt;
         returns &lt;CODE&gt;0.5&lt;/CODE&gt; and stores &lt;CODE&gt;2.0&lt;/CODE&gt; into &lt;CODE&gt;intpart&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-modff" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float value"/>
        <parameter content="float *integer-part"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions break the argument &lt;VAR&gt;value&lt;/VAR&gt; into an integer part and a
         fractional part (between &lt;CODE&gt;-1&lt;/CODE&gt; and &lt;CODE&gt;1&lt;/CODE&gt;, exclusive).  Their sum
         equals &lt;VAR&gt;value&lt;/VAR&gt;.  Each of the parts has the same sign as &lt;VAR&gt;value&lt;/VAR&gt;,
         and the integer part is always rounded toward zero.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;modf&lt;/CODE&gt; stores the integer part in &lt;CODE&gt;*&lt;VAR&gt;integer-part&lt;/VAR&gt;&lt;/CODE&gt;, and
         returns the fractional part.  For example, &lt;CODE&gt;modf (2.5, &amp;intpart)&lt;/CODE&gt;
         returns &lt;CODE&gt;0.5&lt;/CODE&gt; and stores &lt;CODE&gt;2.0&lt;/CODE&gt; into &lt;CODE&gt;intpart&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-modfl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double value"/>
        <parameter content="long double *integer-part"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions break the argument &lt;VAR&gt;value&lt;/VAR&gt; into an integer part and a
         fractional part (between &lt;CODE&gt;-1&lt;/CODE&gt; and &lt;CODE&gt;1&lt;/CODE&gt;, exclusive).  Their sum
         equals &lt;VAR&gt;value&lt;/VAR&gt;.  Each of the parts has the same sign as &lt;VAR&gt;value&lt;/VAR&gt;,
         and the integer part is always rounded toward zero.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;modf&lt;/CODE&gt; stores the integer part in &lt;CODE&gt;*&lt;VAR&gt;integer-part&lt;/VAR&gt;&lt;/CODE&gt;, and
         returns the fractional part.  For example, &lt;CODE&gt;modf (2.5, &amp;intpart)&lt;/CODE&gt;
         returns &lt;CODE&gt;0.5&lt;/CODE&gt; and stores &lt;CODE&gt;2.0&lt;/CODE&gt; into &lt;CODE&gt;intpart&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fmod" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double numerator"/>
        <parameter content="double denominator"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions compute the remainder from the division of
         &lt;VAR&gt;numerator&lt;/VAR&gt; by &lt;VAR&gt;denominator&lt;/VAR&gt;.  Specifically, the return value is
         &lt;CODE&gt;&lt;VAR&gt;numerator&lt;/VAR&gt; - &lt;VAR&gt;n&lt;/VAR&gt; * &lt;VAR&gt;denominator&lt;/VAR&gt;&lt;/CODE&gt;, where &lt;VAR&gt;n&lt;/VAR&gt;
         is the quotient of &lt;VAR&gt;numerator&lt;/VAR&gt; divided by &lt;VAR&gt;denominator&lt;/VAR&gt;, rounded
         towards zero to an integer.  Thus, &lt;CODE&gt;fmod (6.5, 2.3)&lt;/CODE&gt; returns
         &lt;CODE&gt;1.9&lt;/CODE&gt;, which is &lt;CODE&gt;6.5&lt;/CODE&gt; minus &lt;CODE&gt;4.6&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The result has the same sign as the &lt;VAR&gt;numerator&lt;/VAR&gt; and has magnitude
         less than the magnitude of the &lt;VAR&gt;denominator&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;denominator&lt;/VAR&gt; is zero, &lt;CODE&gt;fmod&lt;/CODE&gt; signals a domain error.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fmodf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float numerator"/>
        <parameter content="float denominator"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions compute the remainder from the division of
         &lt;VAR&gt;numerator&lt;/VAR&gt; by &lt;VAR&gt;denominator&lt;/VAR&gt;.  Specifically, the return value is
         &lt;CODE&gt;&lt;VAR&gt;numerator&lt;/VAR&gt; - &lt;VAR&gt;n&lt;/VAR&gt; * &lt;VAR&gt;denominator&lt;/VAR&gt;&lt;/CODE&gt;, where &lt;VAR&gt;n&lt;/VAR&gt;
         is the quotient of &lt;VAR&gt;numerator&lt;/VAR&gt; divided by &lt;VAR&gt;denominator&lt;/VAR&gt;, rounded
         towards zero to an integer.  Thus, &lt;CODE&gt;fmod (6.5, 2.3)&lt;/CODE&gt; returns
         &lt;CODE&gt;1.9&lt;/CODE&gt;, which is &lt;CODE&gt;6.5&lt;/CODE&gt; minus &lt;CODE&gt;4.6&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The result has the same sign as the &lt;VAR&gt;numerator&lt;/VAR&gt; and has magnitude
         less than the magnitude of the &lt;VAR&gt;denominator&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;denominator&lt;/VAR&gt; is zero, &lt;CODE&gt;fmod&lt;/CODE&gt; signals a domain error.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fmodl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double numerator"/>
        <parameter content="long double denominator"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions compute the remainder from the division of
         &lt;VAR&gt;numerator&lt;/VAR&gt; by &lt;VAR&gt;denominator&lt;/VAR&gt;.  Specifically, the return value is
         &lt;CODE&gt;&lt;VAR&gt;numerator&lt;/VAR&gt; - &lt;VAR&gt;n&lt;/VAR&gt; * &lt;VAR&gt;denominator&lt;/VAR&gt;&lt;/CODE&gt;, where &lt;VAR&gt;n&lt;/VAR&gt;
         is the quotient of &lt;VAR&gt;numerator&lt;/VAR&gt; divided by &lt;VAR&gt;denominator&lt;/VAR&gt;, rounded
         towards zero to an integer.  Thus, &lt;CODE&gt;fmod (6.5, 2.3)&lt;/CODE&gt; returns
         &lt;CODE&gt;1.9&lt;/CODE&gt;, which is &lt;CODE&gt;6.5&lt;/CODE&gt; minus &lt;CODE&gt;4.6&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The result has the same sign as the &lt;VAR&gt;numerator&lt;/VAR&gt; and has magnitude
         less than the magnitude of the &lt;VAR&gt;denominator&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;denominator&lt;/VAR&gt; is zero, &lt;CODE&gt;fmod&lt;/CODE&gt; signals a domain error.
        </synopsis>
    </function>
  </construct>
  <construct id="function-drem" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double numerator"/>
        <parameter content="double denominator"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions are like &lt;CODE&gt;fmod&lt;/CODE&gt; except that they round the
         internal quotient &lt;VAR&gt;n&lt;/VAR&gt; to the nearest integer instead of towards zero
         to an integer.  For example, &lt;CODE&gt;drem (6.5, 2.3)&lt;/CODE&gt; returns &lt;CODE&gt;-0.4&lt;/CODE&gt;,
         which is &lt;CODE&gt;6.5&lt;/CODE&gt; minus &lt;CODE&gt;6.9&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The absolute value of the result is less than or equal to half the
         absolute value of the &lt;VAR&gt;denominator&lt;/VAR&gt;.  The difference between
         &lt;CODE&gt;fmod (&lt;VAR&gt;numerator&lt;/VAR&gt;, &lt;VAR&gt;denominator&lt;/VAR&gt;)&lt;/CODE&gt; and &lt;CODE&gt;drem
         (&lt;VAR&gt;numerator&lt;/VAR&gt;, &lt;VAR&gt;denominator&lt;/VAR&gt;)&lt;/CODE&gt; is always either
         &lt;VAR&gt;denominator&lt;/VAR&gt;, minus &lt;VAR&gt;denominator&lt;/VAR&gt;, or zero.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;denominator&lt;/VAR&gt; is zero, &lt;CODE&gt;drem&lt;/CODE&gt; signals a domain error.
        </synopsis>
    </function>
  </construct>
  <construct id="function-dremf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float numerator"/>
        <parameter content="float denominator"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions are like &lt;CODE&gt;fmod&lt;/CODE&gt; except that they round the
         internal quotient &lt;VAR&gt;n&lt;/VAR&gt; to the nearest integer instead of towards zero
         to an integer.  For example, &lt;CODE&gt;drem (6.5, 2.3)&lt;/CODE&gt; returns &lt;CODE&gt;-0.4&lt;/CODE&gt;,
         which is &lt;CODE&gt;6.5&lt;/CODE&gt; minus &lt;CODE&gt;6.9&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The absolute value of the result is less than or equal to half the
         absolute value of the &lt;VAR&gt;denominator&lt;/VAR&gt;.  The difference between
         &lt;CODE&gt;fmod (&lt;VAR&gt;numerator&lt;/VAR&gt;, &lt;VAR&gt;denominator&lt;/VAR&gt;)&lt;/CODE&gt; and &lt;CODE&gt;drem
         (&lt;VAR&gt;numerator&lt;/VAR&gt;, &lt;VAR&gt;denominator&lt;/VAR&gt;)&lt;/CODE&gt; is always either
         &lt;VAR&gt;denominator&lt;/VAR&gt;, minus &lt;VAR&gt;denominator&lt;/VAR&gt;, or zero.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;denominator&lt;/VAR&gt; is zero, &lt;CODE&gt;drem&lt;/CODE&gt; signals a domain error.
        </synopsis>
    </function>
  </construct>
  <construct id="function-dreml" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double numerator"/>
        <parameter content="long double denominator"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions are like &lt;CODE&gt;fmod&lt;/CODE&gt; except that they round the
         internal quotient &lt;VAR&gt;n&lt;/VAR&gt; to the nearest integer instead of towards zero
         to an integer.  For example, &lt;CODE&gt;drem (6.5, 2.3)&lt;/CODE&gt; returns &lt;CODE&gt;-0.4&lt;/CODE&gt;,
         which is &lt;CODE&gt;6.5&lt;/CODE&gt; minus &lt;CODE&gt;6.9&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The absolute value of the result is less than or equal to half the
         absolute value of the &lt;VAR&gt;denominator&lt;/VAR&gt;.  The difference between
         &lt;CODE&gt;fmod (&lt;VAR&gt;numerator&lt;/VAR&gt;, &lt;VAR&gt;denominator&lt;/VAR&gt;)&lt;/CODE&gt; and &lt;CODE&gt;drem
         (&lt;VAR&gt;numerator&lt;/VAR&gt;, &lt;VAR&gt;denominator&lt;/VAR&gt;)&lt;/CODE&gt; is always either
         &lt;VAR&gt;denominator&lt;/VAR&gt;, minus &lt;VAR&gt;denominator&lt;/VAR&gt;, or zero.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;denominator&lt;/VAR&gt; is zero, &lt;CODE&gt;drem&lt;/CODE&gt; signals a domain error.
        </synopsis>
    </function>
  </construct>
  <construct id="function-remainder" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double numerator"/>
        <parameter content="double denominator"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        This function is another name for &lt;CODE&gt;drem&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-remainderf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float numerator"/>
        <parameter content="float denominator"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        This function is another name for &lt;CODE&gt;drem&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-remainderl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double numerator"/>
        <parameter content="long double denominator"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        This function is another name for &lt;CODE&gt;drem&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-copysign" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
        <parameter content="double y"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return &lt;VAR&gt;x&lt;/VAR&gt; but with the sign of &lt;VAR&gt;y&lt;/VAR&gt;.  They work
         even if &lt;VAR&gt;x&lt;/VAR&gt; or &lt;VAR&gt;y&lt;/VAR&gt; are NaN or zero.  Both of these can carry a
         sign (although not all implementations support it) and this is one of
         the few operations that can tell the difference.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;copysign&lt;/CODE&gt; never raises an exception.
         &lt;br&gt;&lt;br&gt; This function is defined in IEC 559 (and the appendix with
         recommended functions in IEEE 754/IEEE 854).
        </synopsis>
    </function>
  </construct>
  <construct id="function-copysignf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
        <parameter content="float y"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return &lt;VAR&gt;x&lt;/VAR&gt; but with the sign of &lt;VAR&gt;y&lt;/VAR&gt;.  They work
         even if &lt;VAR&gt;x&lt;/VAR&gt; or &lt;VAR&gt;y&lt;/VAR&gt; are NaN or zero.  Both of these can carry a
         sign (although not all implementations support it) and this is one of
         the few operations that can tell the difference.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;copysign&lt;/CODE&gt; never raises an exception.
         &lt;br&gt;&lt;br&gt; This function is defined in IEC 559 (and the appendix with
         recommended functions in IEEE 754/IEEE 854).
        </synopsis>
    </function>
  </construct>
  <construct id="function-copysignl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
        <parameter content="long double y"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return &lt;VAR&gt;x&lt;/VAR&gt; but with the sign of &lt;VAR&gt;y&lt;/VAR&gt;.  They work
         even if &lt;VAR&gt;x&lt;/VAR&gt; or &lt;VAR&gt;y&lt;/VAR&gt; are NaN or zero.  Both of these can carry a
         sign (although not all implementations support it) and this is one of
         the few operations that can tell the difference.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;copysign&lt;/CODE&gt; never raises an exception.
         &lt;br&gt;&lt;br&gt; This function is defined in IEC 559 (and the appendix with
         recommended functions in IEEE 754/IEEE 854).
        </synopsis>
    </function>
  </construct>
  <construct id="function-signbit" type="function">
    <function returntype="int">
      <prototype>
        <parameter content=" x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;signbit&lt;/CODE&gt; is a generic macro which can work on all floating-point
         types.  It returns a nonzero value if the value of &lt;VAR&gt;x&lt;/VAR&gt; has its sign
         bit set.
         &lt;br&gt;&lt;br&gt; This is not the same as &lt;CODE&gt;x &lt; 0.0&lt;/CODE&gt;, because IEEE 754 floating
         point allows zero to be signed.  The comparison &lt;CODE&gt;-0.0 &lt; 0.0&lt;/CODE&gt; is
         false, but &lt;CODE&gt;signbit (-0.0)&lt;/CODE&gt; will return a nonzero value.
        </synopsis>
    </function>
  </construct>
  <construct id="function-nextafter" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
        <parameter content="double y"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;nextafter&lt;/CODE&gt; function returns the next representable neighbor of
         &lt;VAR&gt;x&lt;/VAR&gt; in the direction towards &lt;VAR&gt;y&lt;/VAR&gt;.  The size of the step between
         &lt;VAR&gt;x&lt;/VAR&gt; and the result depends on the type of the result.  If
         &lt;VAR&gt;x&lt;/VAR&gt; = &lt;VAR&gt;y&lt;/VAR&gt; the function simply returns &lt;VAR&gt;y&lt;/VAR&gt;.  If either
         value is &lt;CODE&gt;NaN&lt;/CODE&gt;, &lt;CODE&gt;NaN&lt;/CODE&gt; is returned.  Otherwise
         a value corresponding to the value of the least significant bit in the
         mantissa is added or subtracted, depending on the direction.
         &lt;CODE&gt;nextafter&lt;/CODE&gt; will signal overflow or underflow if the result goes
         outside of the range of normalized numbers.
         &lt;br&gt;&lt;br&gt; This function is defined in IEC 559 (and the appendix with
         recommended functions in IEEE 754/IEEE 854).
        </synopsis>
    </function>
  </construct>
  <construct id="function-nextafterf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
        <parameter content="float y"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;nextafter&lt;/CODE&gt; function returns the next representable neighbor of
         &lt;VAR&gt;x&lt;/VAR&gt; in the direction towards &lt;VAR&gt;y&lt;/VAR&gt;.  The size of the step between
         &lt;VAR&gt;x&lt;/VAR&gt; and the result depends on the type of the result.  If
         &lt;VAR&gt;x&lt;/VAR&gt; = &lt;VAR&gt;y&lt;/VAR&gt; the function simply returns &lt;VAR&gt;y&lt;/VAR&gt;.  If either
         value is &lt;CODE&gt;NaN&lt;/CODE&gt;, &lt;CODE&gt;NaN&lt;/CODE&gt; is returned.  Otherwise
         a value corresponding to the value of the least significant bit in the
         mantissa is added or subtracted, depending on the direction.
         &lt;CODE&gt;nextafter&lt;/CODE&gt; will signal overflow or underflow if the result goes
         outside of the range of normalized numbers.
         &lt;br&gt;&lt;br&gt; This function is defined in IEC 559 (and the appendix with
         recommended functions in IEEE 754/IEEE 854).
        </synopsis>
    </function>
  </construct>
  <construct id="function-nextafterl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
        <parameter content="long double y"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;nextafter&lt;/CODE&gt; function returns the next representable neighbor of
         &lt;VAR&gt;x&lt;/VAR&gt; in the direction towards &lt;VAR&gt;y&lt;/VAR&gt;.  The size of the step between
         &lt;VAR&gt;x&lt;/VAR&gt; and the result depends on the type of the result.  If
         &lt;VAR&gt;x&lt;/VAR&gt; = &lt;VAR&gt;y&lt;/VAR&gt; the function simply returns &lt;VAR&gt;y&lt;/VAR&gt;.  If either
         value is &lt;CODE&gt;NaN&lt;/CODE&gt;, &lt;CODE&gt;NaN&lt;/CODE&gt; is returned.  Otherwise
         a value corresponding to the value of the least significant bit in the
         mantissa is added or subtracted, depending on the direction.
         &lt;CODE&gt;nextafter&lt;/CODE&gt; will signal overflow or underflow if the result goes
         outside of the range of normalized numbers.
         &lt;br&gt;&lt;br&gt; This function is defined in IEC 559 (and the appendix with
         recommended functions in IEEE 754/IEEE 854).
        </synopsis>
    </function>
  </construct>
  <construct id="function-nexttoward" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
        <parameter content="long double y"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions are identical to the corresponding versions of
         &lt;CODE&gt;nextafter&lt;/CODE&gt; except that their second argument is a &lt;CODE&gt;long
         double&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-nexttowardf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
        <parameter content="long double y"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions are identical to the corresponding versions of
         &lt;CODE&gt;nextafter&lt;/CODE&gt; except that their second argument is a &lt;CODE&gt;long
         double&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-nexttowardl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
        <parameter content="long double y"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions are identical to the corresponding versions of
         &lt;CODE&gt;nextafter&lt;/CODE&gt; except that their second argument is a &lt;CODE&gt;long
         double&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-nan" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="const char *tagp"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;nan&lt;/CODE&gt; function returns a representation of NaN, provided that
         NaN is supported by the target platform.
         &lt;CODE&gt;nan ("&lt;VAR&gt;n-char-sequence&lt;/VAR&gt;")&lt;/CODE&gt; is equivalent to
         &lt;CODE&gt;strtod ("NAN(&lt;VAR&gt;n-char-sequence&lt;/VAR&gt;)")&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The argument &lt;VAR&gt;tagp&lt;/VAR&gt; is used in an unspecified manner.  On IEEE
         754 systems, there are many representations of NaN, and &lt;VAR&gt;tagp&lt;/VAR&gt;
         selects one.  On other systems it may do nothing.
        </synopsis>
    </function>
  </construct>
  <construct id="function-nanf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="const char *tagp"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;nan&lt;/CODE&gt; function returns a representation of NaN, provided that
         NaN is supported by the target platform.
         &lt;CODE&gt;nan ("&lt;VAR&gt;n-char-sequence&lt;/VAR&gt;")&lt;/CODE&gt; is equivalent to
         &lt;CODE&gt;strtod ("NAN(&lt;VAR&gt;n-char-sequence&lt;/VAR&gt;)")&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The argument &lt;VAR&gt;tagp&lt;/VAR&gt; is used in an unspecified manner.  On IEEE
         754 systems, there are many representations of NaN, and &lt;VAR&gt;tagp&lt;/VAR&gt;
         selects one.  On other systems it may do nothing.
        </synopsis>
    </function>
  </construct>
  <construct id="function-nanl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="const char *tagp"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;nan&lt;/CODE&gt; function returns a representation of NaN, provided that
         NaN is supported by the target platform.
         &lt;CODE&gt;nan ("&lt;VAR&gt;n-char-sequence&lt;/VAR&gt;")&lt;/CODE&gt; is equivalent to
         &lt;CODE&gt;strtod ("NAN(&lt;VAR&gt;n-char-sequence&lt;/VAR&gt;)")&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The argument &lt;VAR&gt;tagp&lt;/VAR&gt; is used in an unspecified manner.  On IEEE
         754 systems, there are many representations of NaN, and &lt;VAR&gt;tagp&lt;/VAR&gt;
         selects one.  On other systems it may do nothing.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fmin" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
        <parameter content="double y"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fmin&lt;/CODE&gt; function returns the lesser of the two values &lt;VAR&gt;x&lt;/VAR&gt;
         and &lt;VAR&gt;y&lt;/VAR&gt;.  It is similar to the expression
         &lt;pre&gt;&lt;br&gt;
         ((x) &lt; (y) ? (x) : (y))&lt;br&gt;
         &lt;/pre&gt;
         except that &lt;VAR&gt;x&lt;/VAR&gt; and &lt;VAR&gt;y&lt;/VAR&gt; are only evaluated once.
         &lt;br&gt;&lt;br&gt; If an argument is NaN, the other argument is returned.  If both arguments
         are NaN, NaN is returned.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fminf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
        <parameter content="float y"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fmin&lt;/CODE&gt; function returns the lesser of the two values &lt;VAR&gt;x&lt;/VAR&gt;
         and &lt;VAR&gt;y&lt;/VAR&gt;.  It is similar to the expression
         &lt;pre&gt;&lt;br&gt;
         ((x) &lt; (y) ? (x) : (y))&lt;br&gt;
         &lt;/pre&gt;
         except that &lt;VAR&gt;x&lt;/VAR&gt; and &lt;VAR&gt;y&lt;/VAR&gt; are only evaluated once.
         &lt;br&gt;&lt;br&gt; If an argument is NaN, the other argument is returned.  If both arguments
         are NaN, NaN is returned.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fminl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
        <parameter content="long double y"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fmin&lt;/CODE&gt; function returns the lesser of the two values &lt;VAR&gt;x&lt;/VAR&gt;
         and &lt;VAR&gt;y&lt;/VAR&gt;.  It is similar to the expression
         &lt;pre&gt;&lt;br&gt;
         ((x) &lt; (y) ? (x) : (y))&lt;br&gt;
         &lt;/pre&gt;
         except that &lt;VAR&gt;x&lt;/VAR&gt; and &lt;VAR&gt;y&lt;/VAR&gt; are only evaluated once.
         &lt;br&gt;&lt;br&gt; If an argument is NaN, the other argument is returned.  If both arguments
         are NaN, NaN is returned.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fmax" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
        <parameter content="double y"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fmax&lt;/CODE&gt; function returns the greater of the two values &lt;VAR&gt;x&lt;/VAR&gt;
         and &lt;VAR&gt;y&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If an argument is NaN, the other argument is returned.  If both arguments
         are NaN, NaN is returned.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fmaxf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
        <parameter content="float y"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fmax&lt;/CODE&gt; function returns the greater of the two values &lt;VAR&gt;x&lt;/VAR&gt;
         and &lt;VAR&gt;y&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If an argument is NaN, the other argument is returned.  If both arguments
         are NaN, NaN is returned.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fmaxl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
        <parameter content="long double y"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fmax&lt;/CODE&gt; function returns the greater of the two values &lt;VAR&gt;x&lt;/VAR&gt;
         and &lt;VAR&gt;y&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If an argument is NaN, the other argument is returned.  If both arguments
         are NaN, NaN is returned.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fdim" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
        <parameter content="double y"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fdim&lt;/CODE&gt; function returns the positive difference between
         &lt;VAR&gt;x&lt;/VAR&gt; and &lt;VAR&gt;y&lt;/VAR&gt;.  The positive difference is &lt;VAR&gt;x&lt;/VAR&gt; -
         &lt;VAR&gt;y&lt;/VAR&gt; if &lt;VAR&gt;x&lt;/VAR&gt; is greater than &lt;VAR&gt;y&lt;/VAR&gt;, and 0 otherwise.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;x&lt;/VAR&gt;, &lt;VAR&gt;y&lt;/VAR&gt;, or both are NaN, NaN is returned.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fdimf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
        <parameter content="float y"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fdim&lt;/CODE&gt; function returns the positive difference between
         &lt;VAR&gt;x&lt;/VAR&gt; and &lt;VAR&gt;y&lt;/VAR&gt;.  The positive difference is &lt;VAR&gt;x&lt;/VAR&gt; -
         &lt;VAR&gt;y&lt;/VAR&gt; if &lt;VAR&gt;x&lt;/VAR&gt; is greater than &lt;VAR&gt;y&lt;/VAR&gt;, and 0 otherwise.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;x&lt;/VAR&gt;, &lt;VAR&gt;y&lt;/VAR&gt;, or both are NaN, NaN is returned.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fdiml" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
        <parameter content="long double y"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fdim&lt;/CODE&gt; function returns the positive difference between
         &lt;VAR&gt;x&lt;/VAR&gt; and &lt;VAR&gt;y&lt;/VAR&gt;.  The positive difference is &lt;VAR&gt;x&lt;/VAR&gt; -
         &lt;VAR&gt;y&lt;/VAR&gt; if &lt;VAR&gt;x&lt;/VAR&gt; is greater than &lt;VAR&gt;y&lt;/VAR&gt;, and 0 otherwise.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;x&lt;/VAR&gt;, &lt;VAR&gt;y&lt;/VAR&gt;, or both are NaN, NaN is returned.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fma" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
        <parameter content="double y"/>
        <parameter content="double z"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>

         The &lt;CODE&gt;fma&lt;/CODE&gt; function performs floating-point multiply-add.  This is
         the operation (&lt;VAR&gt;x&lt;/VAR&gt;  &lt;VAR&gt;y&lt;/VAR&gt;) + &lt;VAR&gt;z&lt;/VAR&gt;, but the
         intermediate result is not rounded to the destination type.  This can
         sometimes improve the precision of a calculation.
         &lt;br&gt;&lt;br&gt; This function was introduced because some processors have a special
         instruction to perform multiply-add.  The C compiler cannot use it
         directly, because the expression &lt;samp&gt;x*y + z&lt;/samp&gt; is defined to round the
         intermediate result.  &lt;CODE&gt;fma&lt;/CODE&gt; lets you choose when you want to round
         only once.
         &lt;br&gt;&lt;br&gt;
         On processors which do not implement multiply-add in hardware,
         &lt;CODE&gt;fma&lt;/CODE&gt; can be very slow since it must avoid intermediate rounding.
         &lt;TT&gt;math.h&lt;/TT&gt; defines the symbols &lt;CODE&gt;FP_FAST_FMA&lt;/CODE&gt;,
         &lt;CODE&gt;FP_FAST_FMAF&lt;/CODE&gt;, and &lt;CODE&gt;FP_FAST_FMAL&lt;/CODE&gt; when the corresponding
         version of &lt;CODE&gt;fma&lt;/CODE&gt; is no slower than the expression &lt;samp&gt;x*y + z&lt;/samp&gt;.
         In the GNU C library, this always means the operation is implemented in
         hardware.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fmaf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
        <parameter content="float y"/>
        <parameter content="float z"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>

         The &lt;CODE&gt;fma&lt;/CODE&gt; function performs floating-point multiply-add.  This is
         the operation (&lt;VAR&gt;x&lt;/VAR&gt;  &lt;VAR&gt;y&lt;/VAR&gt;) + &lt;VAR&gt;z&lt;/VAR&gt;, but the
         intermediate result is not rounded to the destination type.  This can
         sometimes improve the precision of a calculation.
         &lt;br&gt;&lt;br&gt; This function was introduced because some processors have a special
         instruction to perform multiply-add.  The C compiler cannot use it
         directly, because the expression &lt;samp&gt;x*y + z&lt;/samp&gt; is defined to round the
         intermediate result.  &lt;CODE&gt;fma&lt;/CODE&gt; lets you choose when you want to round
         only once.
         &lt;br&gt;&lt;br&gt;
         On processors which do not implement multiply-add in hardware,
         &lt;CODE&gt;fma&lt;/CODE&gt; can be very slow since it must avoid intermediate rounding.
         &lt;TT&gt;math.h&lt;/TT&gt; defines the symbols &lt;CODE&gt;FP_FAST_FMA&lt;/CODE&gt;,
         &lt;CODE&gt;FP_FAST_FMAF&lt;/CODE&gt;, and &lt;CODE&gt;FP_FAST_FMAL&lt;/CODE&gt; when the corresponding
         version of &lt;CODE&gt;fma&lt;/CODE&gt; is no slower than the expression &lt;samp&gt;x*y + z&lt;/samp&gt;.
         In the GNU C library, this always means the operation is implemented in
         hardware.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fmal" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
        <parameter content="long double y"/>
        <parameter content="long double z"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>

         The &lt;CODE&gt;fma&lt;/CODE&gt; function performs floating-point multiply-add.  This is
         the operation (&lt;VAR&gt;x&lt;/VAR&gt;  &lt;VAR&gt;y&lt;/VAR&gt;) + &lt;VAR&gt;z&lt;/VAR&gt;, but the
         intermediate result is not rounded to the destination type.  This can
         sometimes improve the precision of a calculation.
         &lt;br&gt;&lt;br&gt; This function was introduced because some processors have a special
         instruction to perform multiply-add.  The C compiler cannot use it
         directly, because the expression &lt;samp&gt;x*y + z&lt;/samp&gt; is defined to round the
         intermediate result.  &lt;CODE&gt;fma&lt;/CODE&gt; lets you choose when you want to round
         only once.
         &lt;br&gt;&lt;br&gt;
         On processors which do not implement multiply-add in hardware,
         &lt;CODE&gt;fma&lt;/CODE&gt; can be very slow since it must avoid intermediate rounding.
         &lt;TT&gt;math.h&lt;/TT&gt; defines the symbols &lt;CODE&gt;FP_FAST_FMA&lt;/CODE&gt;,
         &lt;CODE&gt;FP_FAST_FMAF&lt;/CODE&gt;, and &lt;CODE&gt;FP_FAST_FMAL&lt;/CODE&gt; when the corresponding
         version of &lt;CODE&gt;fma&lt;/CODE&gt; is no slower than the expression &lt;samp&gt;x*y + z&lt;/samp&gt;.
         In the GNU C library, this always means the operation is implemented in
         hardware.
        </synopsis>
    </function>
  </construct>
  <construct id="function-creal" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="complex double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the real part of the complex number &lt;VAR&gt;z&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-crealf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="complex float z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the real part of the complex number &lt;VAR&gt;z&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-creall" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="complex long double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the real part of the complex number &lt;VAR&gt;z&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cimag" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="complex double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the imaginary part of the complex number &lt;VAR&gt;z&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cimagf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="complex float z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the imaginary part of the complex number &lt;VAR&gt;z&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cimagl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="complex long double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the imaginary part of the complex number &lt;VAR&gt;z&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-conj" type="function">
    <function returntype="complex double">
      <prototype>
        <parameter content="complex double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the conjugate value of the complex number
         &lt;VAR&gt;z&lt;/VAR&gt;.  The conjugate of a complex number has the same real part and a
         negated imaginary part.  In other words, &lt;samp&gt;conj(a + bi) = a + -bi&lt;/samp&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-conjf" type="function">
    <function returntype="complex float">
      <prototype>
        <parameter content="complex float z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the conjugate value of the complex number
         &lt;VAR&gt;z&lt;/VAR&gt;.  The conjugate of a complex number has the same real part and a
         negated imaginary part.  In other words, &lt;samp&gt;conj(a + bi) = a + -bi&lt;/samp&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-conjl" type="function">
    <function returntype="complex long double">
      <prototype>
        <parameter content="complex long double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the conjugate value of the complex number
         &lt;VAR&gt;z&lt;/VAR&gt;.  The conjugate of a complex number has the same real part and a
         negated imaginary part.  In other words, &lt;samp&gt;conj(a + bi) = a + -bi&lt;/samp&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-carg" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="complex double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the argument of the complex number &lt;VAR&gt;z&lt;/VAR&gt;.
         The argument of a complex number is the angle in the complex plane
         between the positive real axis and a line passing through zero and the
         number.  This angle is measured in the usual fashion and ranges from 0
         to 2.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;carg&lt;/CODE&gt; has a branch cut along the positive real axis.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cargf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="complex float z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the argument of the complex number &lt;VAR&gt;z&lt;/VAR&gt;.
         The argument of a complex number is the angle in the complex plane
         between the positive real axis and a line passing through zero and the
         number.  This angle is measured in the usual fashion and ranges from 0
         to 2.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;carg&lt;/CODE&gt; has a branch cut along the positive real axis.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cargl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="complex long double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the argument of the complex number &lt;VAR&gt;z&lt;/VAR&gt;.
         The argument of a complex number is the angle in the complex plane
         between the positive real axis and a line passing through zero and the
         number.  This angle is measured in the usual fashion and ranges from 0
         to 2.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;carg&lt;/CODE&gt; has a branch cut along the positive real axis.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cproj" type="function">
    <function returntype="complex double">
      <prototype>
        <parameter content="complex double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the projection of the complex value &lt;VAR&gt;z&lt;/VAR&gt; onto
         the Riemann sphere.  Values with a infinite imaginary part are projected
         to positive infinity on the real axis, even if the real part is NaN.  If
         the real part is infinite, the result is equivalent to
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         INFINITY + I * copysign (0.0, cimag (z))&lt;br&gt;
         &lt;/pre&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-cprojf" type="function">
    <function returntype="complex float">
      <prototype>
        <parameter content="complex float z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the projection of the complex value &lt;VAR&gt;z&lt;/VAR&gt; onto
         the Riemann sphere.  Values with a infinite imaginary part are projected
         to positive infinity on the real axis, even if the real part is NaN.  If
         the real part is infinite, the result is equivalent to
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         INFINITY + I * copysign (0.0, cimag (z))&lt;br&gt;
         &lt;/pre&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-cprojl" type="function">
    <function returntype="complex long double">
      <prototype>
        <parameter content="complex long double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the projection of the complex value &lt;VAR&gt;z&lt;/VAR&gt; onto
         the Riemann sphere.  Values with a infinite imaginary part are projected
         to positive infinity on the real axis, even if the real part is NaN.  If
         the real part is infinite, the result is equivalent to
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         INFINITY + I * copysign (0.0, cimag (z))&lt;br&gt;
         &lt;/pre&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-strtol" type="function">
    <function returntype="long int">
      <prototype>
        <parameter content="const char *restrict string"/>
        <parameter content="char **restrict tailptr"/>
        <parameter content="int base"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;strtol&lt;/CODE&gt; (``string-to-long'') function converts the initial
         part of &lt;VAR&gt;string&lt;/VAR&gt; to a signed integer, which is returned as a value
         of type &lt;CODE&gt;long int&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This function attempts to decompose &lt;VAR&gt;string&lt;/VAR&gt; as follows:
         &lt;br&gt;&lt;br&gt; &lt;OL&gt;
         &lt;LI&gt;
         A (possibly empty) sequence of whitespace characters.  Which characters
         are whitespace is determined by the &lt;CODE&gt;isspace&lt;/CODE&gt; function
         .  These are discarded.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         An optional plus or minus sign (&lt;samp&gt;+&lt;/samp&gt; or &lt;samp&gt;-&lt;/samp&gt;).
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         A nonempty sequence of digits in the radix specified by &lt;VAR&gt;base&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;base&lt;/VAR&gt; is zero, decimal radix is assumed unless the series of
         digits begins with &lt;samp&gt;0&lt;/samp&gt; (specifying octal radix), or &lt;samp&gt;0x&lt;/samp&gt; or
         &lt;samp&gt;0X&lt;/samp&gt; (specifying hexadecimal radix); in other words, the same
         syntax used for integer constants in C.
         &lt;br&gt;&lt;br&gt; Otherwise &lt;VAR&gt;base&lt;/VAR&gt; must have a value between &lt;CODE&gt;2&lt;/CODE&gt; and &lt;CODE&gt;36&lt;/CODE&gt;.
         If &lt;VAR&gt;base&lt;/VAR&gt; is &lt;CODE&gt;16&lt;/CODE&gt;, the digits may optionally be preceded by
         &lt;samp&gt;0x&lt;/samp&gt; or &lt;samp&gt;0X&lt;/samp&gt;.  If base has no legal value the value returned
         is &lt;CODE&gt;0l&lt;/CODE&gt; and the global variable &lt;CODE&gt;errno&lt;/CODE&gt; is set to &lt;CODE&gt;EINVAL&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         Any remaining characters in the string.  If &lt;VAR&gt;tailptr&lt;/VAR&gt; is not a null
         pointer, &lt;CODE&gt;strtol&lt;/CODE&gt; stores a pointer to this tail in
         &lt;CODE&gt;*&lt;VAR&gt;tailptr&lt;/VAR&gt;&lt;/CODE&gt;.
         &lt;/OL&gt;
         &lt;br&gt;&lt;br&gt; If the string is empty, contains only whitespace, or does not contain an
         initial substring that has the expected syntax for an integer in the
         specified &lt;VAR&gt;base&lt;/VAR&gt;, no conversion is performed.  In this case,
         &lt;CODE&gt;strtol&lt;/CODE&gt; returns a value of zero and the value stored in
         &lt;CODE&gt;*&lt;VAR&gt;tailptr&lt;/VAR&gt;&lt;/CODE&gt; is the value of &lt;VAR&gt;string&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; In a locale other than the standard &lt;CODE&gt;"C"&lt;/CODE&gt; locale, this function
         may recognize additional implementation-dependent syntax.
         &lt;br&gt;&lt;br&gt; If the string has valid syntax for an integer but the value is not
         representable because of overflow, &lt;CODE&gt;strtol&lt;/CODE&gt; returns either
         &lt;CODE&gt;LONG_MAX&lt;/CODE&gt; or &lt;CODE&gt;LONG_MIN&lt;/CODE&gt; , as
         appropriate for the sign of the value.  It also sets &lt;CODE&gt;errno&lt;/CODE&gt;
         to &lt;CODE&gt;ERANGE&lt;/CODE&gt; to indicate there was overflow.
         &lt;br&gt;&lt;br&gt; You should not check for errors by examining the return value of
         &lt;CODE&gt;strtol&lt;/CODE&gt;, because the string might be a valid representation of
         &lt;CODE&gt;0l&lt;/CODE&gt;, &lt;CODE&gt;LONG_MAX&lt;/CODE&gt;, or &lt;CODE&gt;LONG_MIN&lt;/CODE&gt;.  Instead, check whether
         &lt;VAR&gt;tailptr&lt;/VAR&gt; points to what you expect after the number
         (e.g. &lt;CODE&gt;'\0'&lt;/CODE&gt; if the string should end after the number).  You also
         need to clear &lt;VAR&gt;errno&lt;/VAR&gt; before the call and check it afterward, in
         case there was overflow.
         &lt;br&gt;&lt;br&gt; There is an example at the end of this section.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcstol" type="function">
    <function returntype="long int">
      <prototype>
        <parameter content="const wchar_t *restrict string"/>
        <parameter content="wchar_t **restrict tailptr"/>
        <parameter content="int base"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wcstol&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;strtol&lt;/CODE&gt; function
         in nearly all aspects but handles wide character strings.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;wcstol&lt;/CODE&gt; function was introduced in Amendment 1 of ISO C90.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strtoul" type="function">
    <function returntype="unsigned long int">
      <prototype>
        <parameter content="const char *retrict string"/>
        <parameter content="char **restrict tailptr"/>
        <parameter content="int base"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;strtoul&lt;/CODE&gt; (``string-to-unsigned-long'') function is like
         &lt;CODE&gt;strtol&lt;/CODE&gt; except it converts to an &lt;CODE&gt;unsigned long int&lt;/CODE&gt; value.
         The syntax is the same as described above for &lt;CODE&gt;strtol&lt;/CODE&gt;.  The value
         returned on overflow is &lt;CODE&gt;ULONG_MAX&lt;/CODE&gt; .
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;string&lt;/VAR&gt; depicts a negative number, &lt;CODE&gt;strtoul&lt;/CODE&gt; acts the same
         as &lt;VAR&gt;strtol&lt;/VAR&gt; but casts the result to an unsigned integer.  That means
         for example that &lt;CODE&gt;strtoul&lt;/CODE&gt; on &lt;CODE&gt;"-1"&lt;/CODE&gt; returns &lt;CODE&gt;ULONG_MAX&lt;/CODE&gt;
         and an input more negative than &lt;CODE&gt;LONG_MIN&lt;/CODE&gt; returns
         (&lt;CODE&gt;ULONG_MAX&lt;/CODE&gt; + 1) / 2.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;strtoul&lt;/CODE&gt; sets &lt;VAR&gt;errno&lt;/VAR&gt; to &lt;CODE&gt;EINVAL&lt;/CODE&gt; if &lt;VAR&gt;base&lt;/VAR&gt; is out of
         range, or &lt;CODE&gt;ERANGE&lt;/CODE&gt; on overflow.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcstoul" type="function">
    <function returntype="unsigned long int">
      <prototype>
        <parameter content="const wchar_t *restrict string"/>
        <parameter content="wchar_t **restrict tailptr"/>
        <parameter content="int base"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wcstoul&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;strtoul&lt;/CODE&gt; function
         in nearly all aspects but handles wide character strings.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;wcstoul&lt;/CODE&gt; function was introduced in Amendment 1 of ISO C90.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strtoll" type="function">
    <function returntype="long long int">
      <prototype>
        <parameter content="const char *restrict string"/>
        <parameter content="char **restrict tailptr"/>
        <parameter content="int base"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;strtoll&lt;/CODE&gt; function is like &lt;CODE&gt;strtol&lt;/CODE&gt; except that it returns
         a &lt;CODE&gt;long long int&lt;/CODE&gt; value, and accepts numbers with a correspondingly
         larger range.
         &lt;br&gt;&lt;br&gt; If the string has valid syntax for an integer but the value is not
         representable because of overflow, &lt;CODE&gt;strtoll&lt;/CODE&gt; returns either
         &lt;CODE&gt;LONG_LONG_MAX&lt;/CODE&gt; or &lt;CODE&gt;LONG_LONG_MIN&lt;/CODE&gt; , as
         appropriate for the sign of the value.  It also sets &lt;CODE&gt;errno&lt;/CODE&gt; to
         &lt;CODE&gt;ERANGE&lt;/CODE&gt; to indicate there was overflow.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;strtoll&lt;/CODE&gt; function was introduced in ISO C99.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcstoll" type="function">
    <function returntype="long long int">
      <prototype>
        <parameter content="const wchar_t *restrict string"/>
        <parameter content="wchar_t **restrict tailptr"/>
        <parameter content="int base"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wcstoll&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;strtoll&lt;/CODE&gt; function
         in nearly all aspects but handles wide character strings.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;wcstoll&lt;/CODE&gt; function was introduced in Amendment 1 of ISO C90.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strtoq" type="function">
    <function returntype="long long int">
      <prototype>
        <parameter content="const char *restrict string"/>
        <parameter content="char **restrict tailptr"/>
        <parameter content="int base"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;strtoq&lt;/CODE&gt; (``string-to-quad-word'') is the BSD name for &lt;CODE&gt;strtoll&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcstoq" type="function">
    <function returntype="long long int">
      <prototype>
        <parameter content="const wchar_t *restrict string"/>
        <parameter content="wchar_t **restrict tailptr"/>
        <parameter content="int base"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wcstoq&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;strtoq&lt;/CODE&gt; function
         in nearly all aspects but handles wide character strings.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;wcstoq&lt;/CODE&gt; function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strtoull" type="function">
    <function returntype="unsigned long long int">
      <prototype>
        <parameter content="const char *restrict string"/>
        <parameter content="char **restrict tailptr"/>
        <parameter content="int base"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;strtoull&lt;/CODE&gt; function is related to &lt;CODE&gt;strtoll&lt;/CODE&gt; the same way
         &lt;CODE&gt;strtoul&lt;/CODE&gt; is related to &lt;CODE&gt;strtol&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;strtoull&lt;/CODE&gt; function was introduced in ISO C99.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcstoull" type="function">
    <function returntype="unsigned long long int">
      <prototype>
        <parameter content="const wchar_t *restrict string"/>
        <parameter content="wchar_t **restrict tailptr"/>
        <parameter content="int base"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wcstoull&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;strtoull&lt;/CODE&gt; function
         in nearly all aspects but handles wide character strings.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;wcstoull&lt;/CODE&gt; function was introduced in Amendment 1 of ISO C90.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strtouq" type="function">
    <function returntype="unsigned long long int">
      <prototype>
        <parameter content="const char *restrict string"/>
        <parameter content="char **restrict tailptr"/>
        <parameter content="int base"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;strtouq&lt;/CODE&gt; is the BSD name for &lt;CODE&gt;strtoull&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcstouq" type="function">
    <function returntype="unsigned long long int">
      <prototype>
        <parameter content="const wchar_t *restrict string"/>
        <parameter content="wchar_t **restrict tailptr"/>
        <parameter content="int base"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wcstouq&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;strtouq&lt;/CODE&gt; function
         in nearly all aspects but handles wide character strings.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;wcstouq&lt;/CODE&gt; function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strtoimax" type="function">
    <function returntype="intmax_t">
      <prototype>
        <parameter content="const char *restrict string"/>
        <parameter content="char **restrict tailptr"/>
        <parameter content="int base"/>
      </prototype>
      <headers>
        <header filename = "inttypes.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;strtoimax&lt;/CODE&gt; function is like &lt;CODE&gt;strtol&lt;/CODE&gt; except that it returns
         a &lt;CODE&gt;intmax_t&lt;/CODE&gt; value, and accepts numbers of a corresponding range.
         &lt;br&gt;&lt;br&gt; If the string has valid syntax for an integer but the value is not
         representable because of overflow, &lt;CODE&gt;strtoimax&lt;/CODE&gt; returns either
         &lt;CODE&gt;INTMAX_MAX&lt;/CODE&gt; or &lt;CODE&gt;INTMAX_MIN&lt;/CODE&gt; , as
         appropriate for the sign of the value.  It also sets &lt;CODE&gt;errno&lt;/CODE&gt; to
         &lt;CODE&gt;ERANGE&lt;/CODE&gt; to indicate there was overflow.
         &lt;br&gt;&lt;br&gt; See Integers for a description of the &lt;CODE&gt;intmax_t&lt;/CODE&gt; type.  The
         &lt;CODE&gt;strtoimax&lt;/CODE&gt; function was introduced in ISO C99.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcstoimax" type="function">
    <function returntype="intmax_t">
      <prototype>
        <parameter content="const wchar_t *restrict string"/>
        <parameter content="wchar_t **restrict tailptr"/>
        <parameter content="int base"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wcstoimax&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;strtoimax&lt;/CODE&gt; function
         in nearly all aspects but handles wide character strings.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;wcstoimax&lt;/CODE&gt; function was introduced in ISO C99.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strtoumax" type="function">
    <function returntype="uintmax_t">
      <prototype>
        <parameter content="const char *restrict string"/>
        <parameter content="char **restrict tailptr"/>
        <parameter content="int base"/>
      </prototype>
      <headers>
        <header filename = "inttypes.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;strtoumax&lt;/CODE&gt; function is related to &lt;CODE&gt;strtoimax&lt;/CODE&gt;
         the same way that &lt;CODE&gt;strtoul&lt;/CODE&gt; is related to &lt;CODE&gt;strtol&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; See Integers for a description of the &lt;CODE&gt;intmax_t&lt;/CODE&gt; type.  The
         &lt;CODE&gt;strtoumax&lt;/CODE&gt; function was introduced in ISO C99.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcstoumax" type="function">
    <function returntype="uintmax_t">
      <prototype>
        <parameter content="const wchar_t *restrict string"/>
        <parameter content="wchar_t **restrict tailptr"/>
        <parameter content="int base"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wcstoumax&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;strtoumax&lt;/CODE&gt; function
         in nearly all aspects but handles wide character strings.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;wcstoumax&lt;/CODE&gt; function was introduced in ISO C99.
        </synopsis>
    </function>
  </construct>
  <construct id="function-atol" type="function">
    <function returntype="long int">
      <prototype>
        <parameter content="const char *string"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        This function is similar to the &lt;CODE&gt;strtol&lt;/CODE&gt; function with a &lt;VAR&gt;base&lt;/VAR&gt;
         argument of &lt;CODE&gt;10&lt;/CODE&gt;, except that it need not detect overflow errors.
         The &lt;CODE&gt;atol&lt;/CODE&gt; function is provided mostly for compatibility with
         existing code; using &lt;CODE&gt;strtol&lt;/CODE&gt; is more robust.
        </synopsis>
    </function>
  </construct>
  <construct id="function-atoi" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *string"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        This function is like &lt;CODE&gt;atol&lt;/CODE&gt;, except that it returns an &lt;CODE&gt;int&lt;/CODE&gt;.
         The &lt;CODE&gt;atoi&lt;/CODE&gt; function is also considered obsolete; use &lt;CODE&gt;strtol&lt;/CODE&gt;
         instead.
        </synopsis>
    </function>
  </construct>
  <construct id="function-atoll" type="function">
    <function returntype="long long int">
      <prototype>
        <parameter content="const char *string"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;atol&lt;/CODE&gt;, except it returns a &lt;CODE&gt;long
         long int&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;atoll&lt;/CODE&gt; function was introduced in ISO C99.  It too is
         obsolete (despite having just been added); use &lt;CODE&gt;strtoll&lt;/CODE&gt; instead.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strtod" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="const char *restrict string"/>
        <parameter content="char **restrict tailptr"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;strtod&lt;/CODE&gt; (``string-to-double'') function converts the initial
         part of &lt;VAR&gt;string&lt;/VAR&gt; to a floating-point number, which is returned as a
         value of type &lt;CODE&gt;double&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This function attempts to decompose &lt;VAR&gt;string&lt;/VAR&gt; as follows:
         &lt;br&gt;&lt;br&gt; &lt;OL&gt;
         &lt;LI&gt;
         A (possibly empty) sequence of whitespace characters.  Which characters
         are whitespace is determined by the &lt;CODE&gt;isspace&lt;/CODE&gt; function
         .  These are discarded.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         An optional plus or minus sign (&lt;samp&gt;+&lt;/samp&gt; or &lt;samp&gt;-&lt;/samp&gt;).
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; A floating point number in decimal or hexadecimal format.  The
         decimal format is:
         &lt;UL&gt;
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         A nonempty sequence of digits optionally containing a decimal-point
         character---normally &lt;samp&gt;.&lt;/samp&gt;, but it depends on the locale
         .
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         An optional exponent part, consisting of a character &lt;samp&gt;e&lt;/samp&gt; or
         &lt;samp&gt;E&lt;/samp&gt;, an optional sign, and a sequence of digits.
         &lt;br&gt;&lt;br&gt; &lt;/UL&gt;
         &lt;br&gt;&lt;br&gt; The hexadecimal format is as follows:
         &lt;UL&gt;
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         A 0x or 0X followed by a nonempty sequence of hexadecimal digits
         optionally containing a decimal-point character---normally &lt;samp&gt;.&lt;/samp&gt;, but
         it depends on the locale .
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         An optional binary-exponent part, consisting of a character &lt;samp&gt;p&lt;/samp&gt; or
         &lt;samp&gt;P&lt;/samp&gt;, an optional sign, and a sequence of digits.
         &lt;br&gt;&lt;br&gt; &lt;/UL&gt;
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         Any remaining characters in the string.  If &lt;VAR&gt;tailptr&lt;/VAR&gt; is not a null
         pointer, a pointer to this tail of the string is stored in
         &lt;CODE&gt;*&lt;VAR&gt;tailptr&lt;/VAR&gt;&lt;/CODE&gt;.
         &lt;/OL&gt;
         &lt;br&gt;&lt;br&gt; If the string is empty, contains only whitespace, or does not contain an
         initial substring that has the expected syntax for a floating-point
         number, no conversion is performed.  In this case, &lt;CODE&gt;strtod&lt;/CODE&gt; returns
         a value of zero and the value returned in &lt;CODE&gt;*&lt;VAR&gt;tailptr&lt;/VAR&gt;&lt;/CODE&gt; is the
         value of &lt;VAR&gt;string&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; In a locale other than the standard &lt;CODE&gt;"C"&lt;/CODE&gt; or &lt;CODE&gt;"POSIX"&lt;/CODE&gt; locales,
         this function may recognize additional locale-dependent syntax.
         &lt;br&gt;&lt;br&gt; If the string has valid syntax for a floating-point number but the value
         is outside the range of a &lt;CODE&gt;double&lt;/CODE&gt;, &lt;CODE&gt;strtod&lt;/CODE&gt; will signal
         overflow or underflow as described in Math Error Reporting.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;strtod&lt;/CODE&gt; recognizes four special input strings.  The strings
         &lt;CODE&gt;"inf"&lt;/CODE&gt; and &lt;CODE&gt;"infinity"&lt;/CODE&gt; are converted to infinity{},
         or to the largest representable value if the floating-point format
         doesn't support infinities.  You can prepend a &lt;CODE&gt;"+"&lt;/CODE&gt; or &lt;CODE&gt;"-"&lt;/CODE&gt;
         to specify the sign.  Case is ignored when scanning these strings.
         &lt;br&gt;&lt;br&gt; The strings &lt;CODE&gt;"nan"&lt;/CODE&gt; and &lt;CODE&gt;"nan(&lt;VAR&gt;chars&lt;/VAR&gt;&lt;/CODE&gt;)" are converted
         to NaN.  Again, case is ignored.  If &lt;VAR&gt;chars&lt;/VAR&gt; are provided, they
         are used in some unspecified fashion to select a particular
         representation of NaN (there can be several).
         &lt;br&gt;&lt;br&gt; Since zero is a valid result as well as the value returned on error, you
         should check for errors in the same way as for &lt;CODE&gt;strtol&lt;/CODE&gt;, by
         examining &lt;VAR&gt;errno&lt;/VAR&gt; and &lt;VAR&gt;tailptr&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strtof" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="const char *string"/>
        <parameter content="char **tailptr"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        These functions are analogous to &lt;CODE&gt;strtod&lt;/CODE&gt;, but return &lt;CODE&gt;float&lt;/CODE&gt;
         and &lt;CODE&gt;long double&lt;/CODE&gt; values respectively.  They report errors in the
         same way as &lt;CODE&gt;strtod&lt;/CODE&gt;.  &lt;CODE&gt;strtof&lt;/CODE&gt; can be substantially faster
         than &lt;CODE&gt;strtod&lt;/CODE&gt;, but has less precision; conversely, &lt;CODE&gt;strtold&lt;/CODE&gt;
         can be much slower but has more precision (on systems where &lt;CODE&gt;long
         double&lt;/CODE&gt; is a separate type).
         &lt;br&gt;&lt;br&gt; These functions have been GNU extensions and are new to ISO C99.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strtold" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="const char *string"/>
        <parameter content="char **tailptr"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        These functions are analogous to &lt;CODE&gt;strtod&lt;/CODE&gt;, but return &lt;CODE&gt;float&lt;/CODE&gt;
         and &lt;CODE&gt;long double&lt;/CODE&gt; values respectively.  They report errors in the
         same way as &lt;CODE&gt;strtod&lt;/CODE&gt;.  &lt;CODE&gt;strtof&lt;/CODE&gt; can be substantially faster
         than &lt;CODE&gt;strtod&lt;/CODE&gt;, but has less precision; conversely, &lt;CODE&gt;strtold&lt;/CODE&gt;
         can be much slower but has more precision (on systems where &lt;CODE&gt;long
         double&lt;/CODE&gt; is a separate type).
         &lt;br&gt;&lt;br&gt; These functions have been GNU extensions and are new to ISO C99.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcstod" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="const wchar_t *restrict string"/>
        <parameter content="wchar_t **restrict tailptr"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wcstod&lt;/CODE&gt;, &lt;CODE&gt;wcstof&lt;/CODE&gt;, and &lt;CODE&gt;wcstol&lt;/CODE&gt; functions are
         equivalent in nearly all aspect to the &lt;CODE&gt;strtod&lt;/CODE&gt;, &lt;CODE&gt;strtof&lt;/CODE&gt;, and
         &lt;CODE&gt;strtold&lt;/CODE&gt; functions but it handles wide character string.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;wcstod&lt;/CODE&gt; function was introduced in Amendment 1 of ISO
         C90.  The &lt;CODE&gt;wcstof&lt;/CODE&gt; and &lt;CODE&gt;wcstold&lt;/CODE&gt; functions were introduced in
         ISO C99.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcstof" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="const wchar_t *string"/>
        <parameter content="wchar_t **tailptr"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wcstod&lt;/CODE&gt;, &lt;CODE&gt;wcstof&lt;/CODE&gt;, and &lt;CODE&gt;wcstol&lt;/CODE&gt; functions are
         equivalent in nearly all aspect to the &lt;CODE&gt;strtod&lt;/CODE&gt;, &lt;CODE&gt;strtof&lt;/CODE&gt;, and
         &lt;CODE&gt;strtold&lt;/CODE&gt; functions but it handles wide character string.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;wcstod&lt;/CODE&gt; function was introduced in Amendment 1 of ISO
         C90.  The &lt;CODE&gt;wcstof&lt;/CODE&gt; and &lt;CODE&gt;wcstold&lt;/CODE&gt; functions were introduced in
         ISO C99.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcstold" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="const wchar_t *string"/>
        <parameter content="wchar_t **tailptr"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wcstod&lt;/CODE&gt;, &lt;CODE&gt;wcstof&lt;/CODE&gt;, and &lt;CODE&gt;wcstol&lt;/CODE&gt; functions are
         equivalent in nearly all aspect to the &lt;CODE&gt;strtod&lt;/CODE&gt;, &lt;CODE&gt;strtof&lt;/CODE&gt;, and
         &lt;CODE&gt;strtold&lt;/CODE&gt; functions but it handles wide character string.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;wcstod&lt;/CODE&gt; function was introduced in Amendment 1 of ISO
         C90.  The &lt;CODE&gt;wcstof&lt;/CODE&gt; and &lt;CODE&gt;wcstold&lt;/CODE&gt; functions were introduced in
         ISO C99.
        </synopsis>
    </function>
  </construct>
  <construct id="function-atof" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="const char *string"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        This function is similar to the &lt;CODE&gt;strtod&lt;/CODE&gt; function, except that it
         need not detect overflow and underflow errors.  The &lt;CODE&gt;atof&lt;/CODE&gt; function
         is provided mostly for compatibility with existing code; using
         &lt;CODE&gt;strtod&lt;/CODE&gt; is more robust.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ecvt" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="double value"/>
        <parameter content="int ndigit"/>
        <parameter content="int *decpt"/>
        <parameter content="int *neg"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The function &lt;CODE&gt;ecvt&lt;/CODE&gt; converts the floating-point number &lt;VAR&gt;value&lt;/VAR&gt;
         to a string with at most &lt;VAR&gt;ndigit&lt;/VAR&gt; decimal digits.  The
         returned string contains no decimal point or sign. The first digit of
         the string is non-zero (unless &lt;VAR&gt;value&lt;/VAR&gt; is actually zero) and the
         last digit is rounded to nearest.  &lt;CODE&gt;*&lt;VAR&gt;decpt&lt;/VAR&gt;&lt;/CODE&gt; is set to the
         index in the string of the first digit after the decimal point.
         &lt;CODE&gt;*&lt;VAR&gt;neg&lt;/VAR&gt;&lt;/CODE&gt; is set to a nonzero value if &lt;VAR&gt;value&lt;/VAR&gt; is negative,
         zero otherwise.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;ndigit&lt;/VAR&gt; decimal digits would exceed the precision of a
         &lt;CODE&gt;double&lt;/CODE&gt; it is reduced to a system-specific value.
         &lt;br&gt;&lt;br&gt; The returned string is statically allocated and overwritten by each call
         to &lt;CODE&gt;ecvt&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;value&lt;/VAR&gt; is zero, it is implementation defined whether
         &lt;CODE&gt;*&lt;VAR&gt;decpt&lt;/VAR&gt;&lt;/CODE&gt; is &lt;CODE&gt;0&lt;/CODE&gt; or &lt;CODE&gt;1&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; For example: &lt;CODE&gt;ecvt (12.3, 5, &amp;d, &amp;n)&lt;/CODE&gt; returns &lt;CODE&gt;"12300"&lt;/CODE&gt;
         and sets &lt;VAR&gt;d&lt;/VAR&gt; to &lt;CODE&gt;2&lt;/CODE&gt; and &lt;VAR&gt;n&lt;/VAR&gt; to &lt;CODE&gt;0&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fcvt" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="double value"/>
        <parameter content="int ndigit"/>
        <parameter content="int *decpt"/>
        <parameter content="int *neg"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The function &lt;CODE&gt;fcvt&lt;/CODE&gt; is like &lt;CODE&gt;ecvt&lt;/CODE&gt;, but &lt;VAR&gt;ndigit&lt;/VAR&gt; specifies
         the number of digits after the decimal point.  If &lt;VAR&gt;ndigit&lt;/VAR&gt; is less
         than zero, &lt;VAR&gt;value&lt;/VAR&gt; is rounded to the &lt;VAR&gt;ndigit&lt;/VAR&gt;+1'th place to the
         left of the decimal point.  For example, if &lt;VAR&gt;ndigit&lt;/VAR&gt; is &lt;CODE&gt;-1&lt;/CODE&gt;,
         &lt;VAR&gt;value&lt;/VAR&gt; will be rounded to the nearest 10.  If &lt;VAR&gt;ndigit&lt;/VAR&gt; is
         negative and larger than the number of digits to the left of the decimal
         point in &lt;VAR&gt;value&lt;/VAR&gt;, &lt;VAR&gt;value&lt;/VAR&gt; will be rounded to one significant digit.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;ndigit&lt;/VAR&gt; decimal digits would exceed the precision of a
         &lt;CODE&gt;double&lt;/CODE&gt; it is reduced to a system-specific value.
         &lt;br&gt;&lt;br&gt; The returned string is statically allocated and overwritten by each call
         to &lt;CODE&gt;fcvt&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-gcvt" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="double value"/>
        <parameter content="int ndigit"/>
        <parameter content="char *buf"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;gcvt&lt;/CODE&gt; is functionally equivalent to &lt;samp&gt;sprintf(buf, "%*g",
         ndigit, value&lt;/samp&gt;.  It is provided only for compatibility's sake.  It
         returns &lt;VAR&gt;buf&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;ndigit&lt;/VAR&gt; decimal digits would exceed the precision of a
         &lt;CODE&gt;double&lt;/CODE&gt; it is reduced to a system-specific value.
        </synopsis>
    </function>
  </construct>
  <construct id="function-qecvt" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="long double value"/>
        <parameter content="int ndigit"/>
        <parameter content="int *decpt"/>
        <parameter content="int *neg"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        This function is equivalent to &lt;CODE&gt;ecvt&lt;/CODE&gt; except that it takes a
         &lt;CODE&gt;long double&lt;/CODE&gt; for the first parameter and that &lt;VAR&gt;ndigit&lt;/VAR&gt; is
         restricted by the precision of a &lt;CODE&gt;long double&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-qfcvt" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="long double value"/>
        <parameter content="int ndigit"/>
        <parameter content="int *decpt"/>
        <parameter content="int *neg"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        This function is equivalent to &lt;CODE&gt;fcvt&lt;/CODE&gt; except that it
         takes a &lt;CODE&gt;long double&lt;/CODE&gt; for the first parameter and that &lt;VAR&gt;ndigit&lt;/VAR&gt; is
         restricted by the precision of a &lt;CODE&gt;long double&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-qgcvt" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="long double value"/>
        <parameter content="int ndigit"/>
        <parameter content="char *buf"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        This function is equivalent to &lt;CODE&gt;gcvt&lt;/CODE&gt; except that it takes a
         &lt;CODE&gt;long double&lt;/CODE&gt; for the first parameter and that &lt;VAR&gt;ndigit&lt;/VAR&gt; is
         restricted by the precision of a &lt;CODE&gt;long double&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ecvt_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="double value"/>
        <parameter content="int ndigit"/>
        <parameter content="int *decpt"/>
        <parameter content="int *neg"/>
        <parameter content="char *buf"/>
        <parameter content="size_t len"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;ecvt_r&lt;/CODE&gt; function is the same as &lt;CODE&gt;ecvt&lt;/CODE&gt;, except
         that it places its result into the user-specified buffer pointed to by
         &lt;VAR&gt;buf&lt;/VAR&gt;, with length &lt;VAR&gt;len&lt;/VAR&gt;.  The return value is &lt;CODE&gt;-1&lt;/CODE&gt; in
         case of an error and zero otherwise.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fcvt_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="double value"/>
        <parameter content="int ndigit"/>
        <parameter content="int *decpt"/>
        <parameter content="int *neg"/>
        <parameter content="char *buf"/>
        <parameter content="size_t len"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fcvt_r&lt;/CODE&gt; function is the same as &lt;CODE&gt;fcvt&lt;/CODE&gt;, except that it
         places its result into the user-specified buffer pointed to by
         &lt;VAR&gt;buf&lt;/VAR&gt;, with length &lt;VAR&gt;len&lt;/VAR&gt;.  The return value is &lt;CODE&gt;-1&lt;/CODE&gt; in
         case of an error and zero otherwise.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-qecvt_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="long double value"/>
        <parameter content="int ndigit"/>
        <parameter content="int *decpt"/>
        <parameter content="int *neg"/>
        <parameter content="char *buf"/>
        <parameter content="size_t len"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;qecvt_r&lt;/CODE&gt; function is the same as &lt;CODE&gt;qecvt&lt;/CODE&gt;, except
         that it places its result into the user-specified buffer pointed to by
         &lt;VAR&gt;buf&lt;/VAR&gt;, with length &lt;VAR&gt;len&lt;/VAR&gt;.  The return value is &lt;CODE&gt;-1&lt;/CODE&gt; in
         case of an error and zero otherwise.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-qfcvt_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="long double value"/>
        <parameter content="int ndigit"/>
        <parameter content="int *decpt"/>
        <parameter content="int *neg"/>
        <parameter content="char *buf"/>
        <parameter content="size_t len"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;qfcvt_r&lt;/CODE&gt; function is the same as &lt;CODE&gt;qfcvt&lt;/CODE&gt;, except
         that it places its result into the user-specified buffer pointed to by
         &lt;VAR&gt;buf&lt;/VAR&gt;, with length &lt;VAR&gt;len&lt;/VAR&gt;.  The return value is &lt;CODE&gt;-1&lt;/CODE&gt; in
         case of an error and zero otherwise.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-wchar_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="dtype-wint_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="dtype-mbstate_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="function-mbsinit" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const mbstate_t *ps"/>
      </prototype>
      <headers>
        <header filename = "stddef.h"/>
        <header filename = "wchar.h"/>
        <header filename = "limits.h"/>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;mbsinit&lt;/CODE&gt; function determines whether the state object pointed
         to by &lt;VAR&gt;ps&lt;/VAR&gt; is in the initial state.  If &lt;VAR&gt;ps&lt;/VAR&gt; is a null pointer or
         the object is in the initial state the return value is nonzero.  Otherwise
         it is zero.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;mbsinit&lt;/CODE&gt; was introduced in Amendment 1 to ISO C90 and is
         declared in &lt;TT&gt;wchar.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-btowc" type="function">
    <function returntype="wint_t">
      <prototype>
        <parameter content="int c"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;btowc&lt;/CODE&gt; function (``byte to wide character'') converts a valid
         single byte character &lt;VAR&gt;c&lt;/VAR&gt; in the initial shift state into the wide
         character equivalent using the conversion rules from the currently
         selected locale of the &lt;CODE&gt;LC_CTYPE&lt;/CODE&gt; category.
         &lt;br&gt;&lt;br&gt; If &lt;CODE&gt;(unsigned char) &lt;VAR&gt;c&lt;/VAR&gt;&lt;/CODE&gt; is no valid single byte multibyte
         character or if &lt;VAR&gt;c&lt;/VAR&gt; is &lt;CODE&gt;EOF&lt;/CODE&gt;, the function returns &lt;CODE&gt;WEOF&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; Please note the restriction of &lt;VAR&gt;c&lt;/VAR&gt; being tested for validity only in
         the initial shift state.  No &lt;CODE&gt;mbstate_t&lt;/CODE&gt; object is used from
         which the state information is taken, and the function also does not use
         any static state.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;btowc&lt;/CODE&gt; function was introduced in Amendment 1 to ISO C90
         and is declared in &lt;TT&gt;wchar.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wctob" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="wint_t c"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wctob&lt;/CODE&gt; function (``wide character to byte'') takes as the
         parameter a valid wide character.  If the multibyte representation for
         this character in the initial state is exactly one byte long, the return
         value of this function is this character.  Otherwise the return value is
         &lt;CODE&gt;EOF&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;wctob&lt;/CODE&gt; was introduced in Amendment 1 to ISO C90 and
         is declared in &lt;TT&gt;wchar.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-mbrtowc" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="wchar_t *restrict pwc"/>
        <parameter content="const char *restrict s"/>
        <parameter content="size_t n"/>
        <parameter content="mbstate_t *restrict ps"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>

         The &lt;CODE&gt;mbrtowc&lt;/CODE&gt; function (``multibyte restartable to wide
         character'') converts the next multibyte character in the string pointed
         to by &lt;VAR&gt;s&lt;/VAR&gt; into a wide character and stores it in the wide character
         string pointed to by &lt;VAR&gt;pwc&lt;/VAR&gt;.  The conversion is performed according
         to the locale currently selected for the &lt;CODE&gt;LC_CTYPE&lt;/CODE&gt; category.  If
         the conversion for the character set used in the locale requires a state,
         the multibyte string is interpreted in the state represented by the
         object pointed to by &lt;VAR&gt;ps&lt;/VAR&gt;.  If &lt;VAR&gt;ps&lt;/VAR&gt; is a null pointer, a static,
         internal state variable used only by the &lt;CODE&gt;mbrtowc&lt;/CODE&gt; function is
         used.
         &lt;br&gt;&lt;br&gt; If the next multibyte character corresponds to the NUL wide character,
         the return value of the function is 0 and the state object is
         afterwards in the initial state.  If the next &lt;VAR&gt;n&lt;/VAR&gt; or fewer bytes
         form a correct multibyte character, the return value is the number of
         bytes starting from &lt;VAR&gt;s&lt;/VAR&gt; that form the multibyte character.  The
         conversion state is updated according to the bytes consumed in the
         conversion.  In both cases the wide character (either the &lt;CODE&gt;L'\0'&lt;/CODE&gt;
         or the one found in the conversion) is stored in the string pointed to
         by &lt;VAR&gt;pwc&lt;/VAR&gt; if &lt;VAR&gt;pwc&lt;/VAR&gt; is not null.
         &lt;br&gt;&lt;br&gt; If the first &lt;VAR&gt;n&lt;/VAR&gt; bytes of the multibyte string possibly form a valid
         multibyte character but there are more than &lt;VAR&gt;n&lt;/VAR&gt; bytes needed to
         complete it, the return value of the function is &lt;CODE&gt;(size_t) -2&lt;/CODE&gt; and
         no value is stored.  Please note that this can happen even if &lt;VAR&gt;n&lt;/VAR&gt;
         has a value greater than or equal to &lt;CODE&gt;MB_CUR_MAX&lt;/CODE&gt; since the input
         might contain redundant shift sequences.
         &lt;br&gt;&lt;br&gt; If the first &lt;CODE&gt;n&lt;/CODE&gt; bytes of the multibyte string cannot possibly form
         a valid multibyte character, no value is stored, the global variable
         &lt;CODE&gt;errno&lt;/CODE&gt; is set to the value &lt;CODE&gt;EILSEQ&lt;/CODE&gt;, and the function returns
         &lt;CODE&gt;(size_t) -1&lt;/CODE&gt;.  The conversion state is afterwards undefined.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;mbrtowc&lt;/CODE&gt; was introduced in Amendment 1 to ISO C90 and
         is declared in &lt;TT&gt;wchar.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-mbrlen" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="const char *restrict s"/>
        <parameter content="size_t n"/>
        <parameter content="mbstate_t *ps"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;mbrlen&lt;/CODE&gt; function (``multibyte restartable length'') computes
         the number of at most &lt;VAR&gt;n&lt;/VAR&gt; bytes starting at &lt;VAR&gt;s&lt;/VAR&gt;, which form the
         next valid and complete multibyte character.
         &lt;br&gt;&lt;br&gt; If the next multibyte character corresponds to the NUL wide character,
         the return value is 0.  If the next &lt;VAR&gt;n&lt;/VAR&gt; bytes form a valid
         multibyte character, the number of bytes belonging to this multibyte
         character byte sequence is returned.
         &lt;br&gt;&lt;br&gt; If the first &lt;VAR&gt;n&lt;/VAR&gt; bytes possibly form a valid multibyte
         character but the character is incomplete, the return value is
         &lt;CODE&gt;(size_t) -2&lt;/CODE&gt;.  Otherwise the multibyte character sequence is invalid
         and the return value is &lt;CODE&gt;(size_t) -1&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The multibyte sequence is interpreted in the state represented by the
         object pointed to by &lt;VAR&gt;ps&lt;/VAR&gt;.  If &lt;VAR&gt;ps&lt;/VAR&gt; is a null pointer, a state
         object local to &lt;CODE&gt;mbrlen&lt;/CODE&gt; is used.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;mbrlen&lt;/CODE&gt; was introduced in Amendment 1 to ISO C90 and
         is declared in &lt;TT&gt;wchar.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcrtomb" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="char *restrict s"/>
        <parameter content="wchar_t wc"/>
        <parameter content="mbstate_t *restrict ps"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wcrtomb&lt;/CODE&gt; function (``wide character restartable to
         multibyte'') converts a single wide character into a multibyte string
         corresponding to that wide character.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;s&lt;/VAR&gt; is a null pointer, the function resets the state stored in
         the objects pointed to by &lt;VAR&gt;ps&lt;/VAR&gt; (or the internal &lt;CODE&gt;mbstate_t&lt;/CODE&gt;
         object) to the initial state.  This can also be achieved by a call like
         this:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         wcrtombs (temp_buf, L'\0', ps)&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt;
         since, if &lt;VAR&gt;s&lt;/VAR&gt; is a null pointer, &lt;CODE&gt;wcrtomb&lt;/CODE&gt; performs as if it
         writes into an internal buffer, which is guaranteed to be large enough.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;wc&lt;/VAR&gt; is the NUL wide character, &lt;CODE&gt;wcrtomb&lt;/CODE&gt; emits, if
         necessary, a shift sequence to get the state &lt;VAR&gt;ps&lt;/VAR&gt; into the initial
         state followed by a single NUL byte, which is stored in the string
         &lt;VAR&gt;s&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; Otherwise a byte sequence (possibly including shift sequences) is written
         into the string &lt;VAR&gt;s&lt;/VAR&gt;.  This only happens if &lt;VAR&gt;wc&lt;/VAR&gt; is a valid wide
         character (i.e., it has a multibyte representation in the character set
         selected by locale of the &lt;CODE&gt;LC_CTYPE&lt;/CODE&gt; category).  If &lt;VAR&gt;wc&lt;/VAR&gt; is no
         valid wide character, nothing is stored in the strings &lt;VAR&gt;s&lt;/VAR&gt;,
         &lt;CODE&gt;errno&lt;/CODE&gt; is set to &lt;CODE&gt;EILSEQ&lt;/CODE&gt;, the conversion state in &lt;VAR&gt;ps&lt;/VAR&gt;
         is undefined and the return value is &lt;CODE&gt;(size_t) -1&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; If no error occurred the function returns the number of bytes stored in
         the string &lt;VAR&gt;s&lt;/VAR&gt;.  This includes all bytes representing shift
         sequences.
         &lt;br&gt;&lt;br&gt; One word about the interface of the function: there is no parameter
         specifying the length of the array &lt;VAR&gt;s&lt;/VAR&gt;.  Instead the function
         assumes that there are at least &lt;CODE&gt;MB_CUR_MAX&lt;/CODE&gt; bytes available since
         this is the maximum length of any byte sequence representing a single
         character.  So the caller has to make sure that there is enough space
         available, otherwise buffer overruns can occur.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;wcrtomb&lt;/CODE&gt; was introduced in Amendment 1 to ISO C90 and is
         declared in &lt;TT&gt;wchar.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-mbsrtowcs" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="wchar_t *restrict dst"/>
        <parameter content="const char **restrict src"/>
        <parameter content="size_t len"/>
        <parameter content="mbstate_t *restrict ps"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;mbsrtowcs&lt;/CODE&gt; function (``multibyte string restartable to wide
         character string'') converts an NUL-terminated multibyte character
         string at &lt;CODE&gt;*&lt;VAR&gt;src&lt;/VAR&gt;&lt;/CODE&gt; into an equivalent wide character string,
         including the NUL wide character at the end.  The conversion is started
         using the state information from the object pointed to by &lt;VAR&gt;ps&lt;/VAR&gt; or
         from an internal object of &lt;CODE&gt;mbsrtowcs&lt;/CODE&gt; if &lt;VAR&gt;ps&lt;/VAR&gt; is a null
         pointer.  Before returning, the state object is updated to match the state
         after the last converted character.  The state is the initial state if the
         terminating NUL byte is reached and converted.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;dst&lt;/VAR&gt; is not a null pointer, the result is stored in the array
         pointed to by &lt;VAR&gt;dst&lt;/VAR&gt;; otherwise, the conversion result is not
         available since it is stored in an internal buffer.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;len&lt;/VAR&gt; wide characters are stored in the array &lt;VAR&gt;dst&lt;/VAR&gt; before
         reaching the end of the input string, the conversion stops and &lt;VAR&gt;len&lt;/VAR&gt;
         is returned.  If &lt;VAR&gt;dst&lt;/VAR&gt; is a null pointer, &lt;VAR&gt;len&lt;/VAR&gt; is never checked.
         &lt;br&gt;&lt;br&gt; Another reason for a premature return from the function call is if the
         input string contains an invalid multibyte sequence.  In this case the
         global variable &lt;CODE&gt;errno&lt;/CODE&gt; is set to &lt;CODE&gt;EILSEQ&lt;/CODE&gt; and the function
         returns &lt;CODE&gt;(size_t) -1&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt; In all other cases the function returns the number of wide characters
         converted during this call.  If &lt;VAR&gt;dst&lt;/VAR&gt; is not null, &lt;CODE&gt;mbsrtowcs&lt;/CODE&gt;
         stores in the pointer pointed to by &lt;VAR&gt;src&lt;/VAR&gt; either a null pointer (if
         the NUL byte in the input string was reached) or the address of the byte
         following the last converted multibyte character.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;mbsrtowcs&lt;/CODE&gt; was introduced in Amendment 1 to ISO C90 and is
         declared in &lt;TT&gt;wchar.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcsrtombs" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="char *restrict dst"/>
        <parameter content="const wchar_t **restrict src"/>
        <parameter content="size_t len"/>
        <parameter content="mbstate_t *restrict ps"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wcsrtombs&lt;/CODE&gt; function (``wide character string restartable to
         multibyte string'') converts the NUL-terminated wide character string at
         &lt;CODE&gt;*&lt;VAR&gt;src&lt;/VAR&gt;&lt;/CODE&gt; into an equivalent multibyte character string and
         stores the result in the array pointed to by &lt;VAR&gt;dst&lt;/VAR&gt;.  The NUL wide
         character is also converted.  The conversion starts in the state
         described in the object pointed to by &lt;VAR&gt;ps&lt;/VAR&gt; or by a state object
         locally to &lt;CODE&gt;wcsrtombs&lt;/CODE&gt; in case &lt;VAR&gt;ps&lt;/VAR&gt; is a null pointer.  If
         &lt;VAR&gt;dst&lt;/VAR&gt; is a null pointer, the conversion is performed as usual but the
         result is not available.  If all characters of the input string were
         successfully converted and if &lt;VAR&gt;dst&lt;/VAR&gt; is not a null pointer, the
         pointer pointed to by &lt;VAR&gt;src&lt;/VAR&gt; gets assigned a null pointer.
         &lt;br&gt;&lt;br&gt; If one of the wide characters in the input string has no valid multibyte
         character equivalent, the conversion stops early, sets the global
         variable &lt;CODE&gt;errno&lt;/CODE&gt; to &lt;CODE&gt;EILSEQ&lt;/CODE&gt;, and returns &lt;CODE&gt;(size_t) -1&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; Another reason for a premature stop is if &lt;VAR&gt;dst&lt;/VAR&gt; is not a null
         pointer and the next converted character would require more than
         &lt;VAR&gt;len&lt;/VAR&gt; bytes in total to the array &lt;VAR&gt;dst&lt;/VAR&gt;.  In this case (and if
         &lt;VAR&gt;dest&lt;/VAR&gt; is not a null pointer) the pointer pointed to by &lt;VAR&gt;src&lt;/VAR&gt; is
         assigned a value pointing to the wide character right after the last one
         successfully converted.
         &lt;br&gt;&lt;br&gt; Except in the case of an encoding error the return value of the
         &lt;CODE&gt;wcsrtombs&lt;/CODE&gt; function is the number of bytes in all the multibyte
         character sequences stored in &lt;VAR&gt;dst&lt;/VAR&gt;.  Before returning the state in
         the object pointed to by &lt;VAR&gt;ps&lt;/VAR&gt; (or the internal object in case
         &lt;VAR&gt;ps&lt;/VAR&gt; is a null pointer) is updated to reflect the state after the
         last conversion.  The state is the initial shift state in case the
         terminating NUL wide character was converted.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;wcsrtombs&lt;/CODE&gt; function was introduced in Amendment 1 to
         ISO C90 and is declared in &lt;TT&gt;wchar.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-mbsnrtowcs" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="wchar_t *restrict dst"/>
        <parameter content="const char **restrict src"/>
        <parameter content="size_t nmc"/>
        <parameter content="size_t len"/>
        <parameter content="mbstate_t *restrict ps"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;mbsnrtowcs&lt;/CODE&gt; function is very similar to the &lt;CODE&gt;mbsrtowcs&lt;/CODE&gt;
         function.  All the parameters are the same except for &lt;VAR&gt;nmc&lt;/VAR&gt;, which is
         new.  The return value is the same as for &lt;CODE&gt;mbsrtowcs&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This new parameter specifies how many bytes at most can be used from the
         multibyte character string.  In other words, the multibyte character
         string &lt;CODE&gt;*&lt;VAR&gt;src&lt;/VAR&gt;&lt;/CODE&gt; need not be NUL-terminated.  But if a NUL byte
         is found within the &lt;VAR&gt;nmc&lt;/VAR&gt; first bytes of the string, the conversion
         stops here.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.  It is meant to work around the
         problems mentioned above.  Now it is possible to convert a buffer with
         multibyte character text piece for piece without having to care about
         inserting NUL bytes and the effect of NUL bytes on the conversion state.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcsnrtombs" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="char *restrict dst"/>
        <parameter content="const wchar_t **restrict src"/>
        <parameter content="size_t nwc"/>
        <parameter content="size_t len"/>
        <parameter content="mbstate_t *restrict ps"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wcsnrtombs&lt;/CODE&gt; function implements the conversion from wide
         character strings to multibyte character strings.  It is similar to
         &lt;CODE&gt;wcsrtombs&lt;/CODE&gt; but, just like &lt;CODE&gt;mbsnrtowcs&lt;/CODE&gt;, it takes an extra
         parameter, which specifies the length of the input string.
         &lt;br&gt;&lt;br&gt; No more than &lt;VAR&gt;nwc&lt;/VAR&gt; wide characters from the input string
         &lt;CODE&gt;*&lt;VAR&gt;src&lt;/VAR&gt;&lt;/CODE&gt; are converted.  If the input string contains a NUL
         wide character in the first &lt;VAR&gt;nwc&lt;/VAR&gt; characters, the conversion stops at
         this place.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;wcsnrtombs&lt;/CODE&gt; function is a GNU extension and just like
         &lt;CODE&gt;mbsnrtowcs&lt;/CODE&gt; helps in situations where no NUL-terminated input
         strings are available.
        </synopsis>
    </function>
  </construct>
  <construct id="function-mbtowc" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="wchar_t *restrict result"/>
        <parameter content="const char *restrict string"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;mbtowc&lt;/CODE&gt; (``multibyte to wide character'') function when called
         with non-null &lt;VAR&gt;string&lt;/VAR&gt; converts the first multibyte character
         beginning at &lt;VAR&gt;string&lt;/VAR&gt; to its corresponding wide character code.  It
         stores the result in &lt;CODE&gt;*&lt;VAR&gt;result&lt;/VAR&gt;&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;mbtowc&lt;/CODE&gt; never examines more than &lt;VAR&gt;size&lt;/VAR&gt; bytes.  (The idea is
         to supply for &lt;VAR&gt;size&lt;/VAR&gt; the number of bytes of data you have in hand.)
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;mbtowc&lt;/CODE&gt; with non-null &lt;VAR&gt;string&lt;/VAR&gt; distinguishes three
         possibilities: the first &lt;VAR&gt;size&lt;/VAR&gt; bytes at &lt;VAR&gt;string&lt;/VAR&gt; start with
         valid multibyte characters, they start with an invalid byte sequence or
         just part of a character, or &lt;VAR&gt;string&lt;/VAR&gt; points to an empty string (a
         null character).
         &lt;br&gt;&lt;br&gt; For a valid multibyte character, &lt;CODE&gt;mbtowc&lt;/CODE&gt; converts it to a wide
         character and stores that in &lt;CODE&gt;*&lt;VAR&gt;result&lt;/VAR&gt;&lt;/CODE&gt;, and returns the
         number of bytes in that character (always at least 1 and never
         more than &lt;VAR&gt;size&lt;/VAR&gt;).
         &lt;br&gt;&lt;br&gt; For an invalid byte sequence, &lt;CODE&gt;mbtowc&lt;/CODE&gt; returns -1.  For an
         empty string, it returns 0, also storing &lt;CODE&gt;'\0'&lt;/CODE&gt; in
         &lt;CODE&gt;*&lt;VAR&gt;result&lt;/VAR&gt;&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; If the multibyte character code uses shift characters, then
         &lt;CODE&gt;mbtowc&lt;/CODE&gt; maintains and updates a shift state as it scans.  If you
         call &lt;CODE&gt;mbtowc&lt;/CODE&gt; with a null pointer for &lt;VAR&gt;string&lt;/VAR&gt;, that
         initializes the shift state to its standard initial value.  It also
         returns nonzero if the multibyte character code in use actually has a
         shift state.  .
        </synopsis>
    </function>
  </construct>
  <construct id="function-wctomb" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="char *string"/>
        <parameter content="wchar_t wchar"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wctomb&lt;/CODE&gt; (``wide character to multibyte'') function converts
         the wide character code &lt;VAR&gt;wchar&lt;/VAR&gt; to its corresponding multibyte
         character sequence, and stores the result in bytes starting at
         &lt;VAR&gt;string&lt;/VAR&gt;.  At most &lt;CODE&gt;MB_CUR_MAX&lt;/CODE&gt; characters are stored.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;wctomb&lt;/CODE&gt; with non-null &lt;VAR&gt;string&lt;/VAR&gt; distinguishes three
         possibilities for &lt;VAR&gt;wchar&lt;/VAR&gt;: a valid wide character code (one that can
         be translated to a multibyte character), an invalid code, and
         &lt;CODE&gt;L'\0'&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; Given a valid code, &lt;CODE&gt;wctomb&lt;/CODE&gt; converts it to a multibyte character,
         storing the bytes starting at &lt;VAR&gt;string&lt;/VAR&gt;.  Then it returns the number
         of bytes in that character (always at least 1 and never more
         than &lt;CODE&gt;MB_CUR_MAX&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;wchar&lt;/VAR&gt; is an invalid wide character code, &lt;CODE&gt;wctomb&lt;/CODE&gt; returns
         -1.  If &lt;VAR&gt;wchar&lt;/VAR&gt; is &lt;CODE&gt;L'\0'&lt;/CODE&gt;, it returns &lt;CODE&gt;0&lt;/CODE&gt;, also
         storing &lt;CODE&gt;'\0'&lt;/CODE&gt; in &lt;CODE&gt;*&lt;VAR&gt;string&lt;/VAR&gt;&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; If the multibyte character code uses shift characters, then
         &lt;CODE&gt;wctomb&lt;/CODE&gt; maintains and updates a shift state as it scans.  If you
         call &lt;CODE&gt;wctomb&lt;/CODE&gt; with a null pointer for &lt;VAR&gt;string&lt;/VAR&gt;, that
         initializes the shift state to its standard initial value.  It also
         returns nonzero if the multibyte character code in use actually has a
         shift state.  .
         &lt;br&gt;&lt;br&gt; Calling this function with a &lt;VAR&gt;wchar&lt;/VAR&gt; argument of zero when
         &lt;VAR&gt;string&lt;/VAR&gt; is not null has the side-effect of reinitializing the
         stored shift state &lt;EM&gt;as well as&lt;/EM&gt; storing the multibyte character
         &lt;CODE&gt;'\0'&lt;/CODE&gt; and returning 0.
        </synopsis>
    </function>
  </construct>
  <construct id="function-mblen" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *string"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;mblen&lt;/CODE&gt; function with a non-null &lt;VAR&gt;string&lt;/VAR&gt; argument returns
         the number of bytes that make up the multibyte character beginning at
         &lt;VAR&gt;string&lt;/VAR&gt;, never examining more than &lt;VAR&gt;size&lt;/VAR&gt; bytes.  (The idea is
         to supply for &lt;VAR&gt;size&lt;/VAR&gt; the number of bytes of data you have in hand.)
         &lt;br&gt;&lt;br&gt; The return value of &lt;CODE&gt;mblen&lt;/CODE&gt; distinguishes three possibilities: the
         first &lt;VAR&gt;size&lt;/VAR&gt; bytes at &lt;VAR&gt;string&lt;/VAR&gt; start with valid multibyte
         characters, they start with an invalid byte sequence or just part of a
         character, or &lt;VAR&gt;string&lt;/VAR&gt; points to an empty string (a null character).
         &lt;br&gt;&lt;br&gt; For a valid multibyte character, &lt;CODE&gt;mblen&lt;/CODE&gt; returns the number of
         bytes in that character (always at least &lt;CODE&gt;1&lt;/CODE&gt; and never more than
         &lt;VAR&gt;size&lt;/VAR&gt;).  For an invalid byte sequence, &lt;CODE&gt;mblen&lt;/CODE&gt; returns
         -1.  For an empty string, it returns 0.
         &lt;br&gt;&lt;br&gt; If the multibyte character code uses shift characters, then &lt;CODE&gt;mblen&lt;/CODE&gt;
         maintains and updates a shift state as it scans.  If you call
         &lt;CODE&gt;mblen&lt;/CODE&gt; with a null pointer for &lt;VAR&gt;string&lt;/VAR&gt;, that initializes the
         shift state to its standard initial value.  It also returns a nonzero
         value if the multibyte character code in use actually has a shift state.
         .
         &lt;br&gt;&lt;br&gt; The function &lt;CODE&gt;mblen&lt;/CODE&gt; is declared in &lt;TT&gt;stdlib.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-mbstowcs" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="wchar_t *wstring"/>
        <parameter content="const char *string"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;mbstowcs&lt;/CODE&gt; (``multibyte string to wide character string'')
         function converts the null-terminated string of multibyte characters
         &lt;VAR&gt;string&lt;/VAR&gt; to an array of wide character codes, storing not more than
         &lt;VAR&gt;size&lt;/VAR&gt; wide characters into the array beginning at &lt;VAR&gt;wstring&lt;/VAR&gt;.
         The terminating null character counts towards the size, so if &lt;VAR&gt;size&lt;/VAR&gt;
         is less than the actual number of wide characters resulting from
         &lt;VAR&gt;string&lt;/VAR&gt;, no terminating null character is stored.
         &lt;br&gt;&lt;br&gt; The conversion of characters from &lt;VAR&gt;string&lt;/VAR&gt; begins in the initial
         shift state.
         &lt;br&gt;&lt;br&gt; If an invalid multibyte character sequence is found, the &lt;CODE&gt;mbstowcs&lt;/CODE&gt;
         function returns a value of -1.  Otherwise, it returns the number
         of wide characters stored in the array &lt;VAR&gt;wstring&lt;/VAR&gt;.  This number does
         not include the terminating null character, which is present if the
         number is less than &lt;VAR&gt;size&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; Here is an example showing how to convert a string of multibyte
         characters, allocating enough space for the result.
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         wchar_t *&lt;br&gt;
         mbstowcs_alloc (const char *string)&lt;br&gt;
         {&lt;br&gt;
           size_t size = strlen (string) + 1;&lt;br&gt;
           wchar_t *buf = xmalloc (size * sizeof (wchar_t));&lt;br&gt;
         &lt;br&gt;&lt;br&gt;   size = mbstowcs (buf, string, size);&lt;br&gt;
           if (size == (size_t) -1)&lt;br&gt;
             return NULL;&lt;br&gt;
           buf = xrealloc (buf, (size + 1) * sizeof (wchar_t));&lt;br&gt;
           return buf;&lt;br&gt;
         }&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-wcstombs" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="char *string"/>
        <parameter content="const wchar_t *wstring"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wcstombs&lt;/CODE&gt; (``wide character string to multibyte string'')
         function converts the null-terminated wide character array &lt;VAR&gt;wstring&lt;/VAR&gt;
         into a string containing multibyte characters, storing not more than
         &lt;VAR&gt;size&lt;/VAR&gt; bytes starting at &lt;VAR&gt;string&lt;/VAR&gt;, followed by a terminating
         null character if there is room.  The conversion of characters begins in
         the initial shift state.
         &lt;br&gt;&lt;br&gt; The terminating null character counts towards the size, so if &lt;VAR&gt;size&lt;/VAR&gt;
         is less than or equal to the number of bytes needed in &lt;VAR&gt;wstring&lt;/VAR&gt;, no
         terminating null character is stored.
         &lt;br&gt;&lt;br&gt; If a code that does not correspond to a valid multibyte character is
         found, the &lt;CODE&gt;wcstombs&lt;/CODE&gt; function returns a value of -1.
         Otherwise, the return value is the number of bytes stored in the array
         &lt;VAR&gt;string&lt;/VAR&gt;.  This number does not include the terminating null character,
         which is present if the number is less than &lt;VAR&gt;size&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-iconv_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="function-iconv_open" type="function">
    <function returntype="iconv_t">
      <prototype>
        <parameter content="const char *tocode"/>
        <parameter content="const char *fromcode"/>
      </prototype>
      <headers>
        <header filename = "iconv.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;iconv_open&lt;/CODE&gt; function has to be used before starting a
         conversion.  The two parameters this function takes determine the
         source and destination character set for the conversion, and if the
         implementation has the possibility to perform such a conversion, the
         function returns a handle.
         &lt;br&gt;&lt;br&gt; If the wanted conversion is not available, the &lt;CODE&gt;iconv_open&lt;/CODE&gt; function
         returns &lt;CODE&gt;(iconv_t) -1&lt;/CODE&gt;. In this case the global variable
         &lt;CODE&gt;errno&lt;/CODE&gt; can have the following values:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EMFILE&lt;/CODE&gt;
&lt;DD&gt;
         The process already has &lt;CODE&gt;OPEN_MAX&lt;/CODE&gt; file descriptors open.
         &lt;LI&gt; ENFILE
         The system limit of open file is reached.
         &lt;LI&gt; ENOMEM
         Not enough memory to carry out the operation.
         &lt;LI&gt; EINVAL
         The conversion from &lt;VAR&gt;fromcode&lt;/VAR&gt; to &lt;VAR&gt;tocode&lt;/VAR&gt; is not supported.

         &lt;br&gt;&lt;br&gt; It is not possible to use the same descriptor in different threads to
         perform independent conversions.  The data structures associated
         with the descriptor include information about the conversion state.
         This must not be messed up by using it in different conversions.
         &lt;br&gt;&lt;br&gt; An &lt;CODE&gt;iconv&lt;/CODE&gt; descriptor is like a file descriptor as for every use a
         new descriptor must be created.  The descriptor does not stand for all
         of the conversions from &lt;VAR&gt;fromset&lt;/VAR&gt; to &lt;VAR&gt;toset&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The GNU C library implementation of &lt;CODE&gt;iconv_open&lt;/CODE&gt; has one
         significant extension to other implementations.  To ease the extension
         of the set of available conversions, the implementation allows storing
         the necessary files with data and code in an arbitrary number of
         directories.  How this extension must be written will be explained below
         .  Here it is only important to say
         that all directories mentioned in the &lt;CODE&gt;GCONV_PATH&lt;/CODE&gt; environment
         variable are considered only if they contain a file &lt;TT&gt;gconv-modules&lt;/TT&gt;.
         These directories need not necessarily be created by the system
         administrator.  In fact, this extension is introduced to help users
         writing and using their own, new conversions.  Of course, this does not
         work for security reasons in SUID binaries; in this case only the system
         directory is considered and this normally is
         &lt;TT&gt;&lt;VAR&gt;prefix&lt;/VAR&gt;/lib/gconv&lt;/TT&gt;.  The &lt;CODE&gt;GCONV_PATH&lt;/CODE&gt; environment
         variable is examined exactly once at the first call of the
         &lt;CODE&gt;iconv_open&lt;/CODE&gt; function.  Later modifications of the variable have no
         effect.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;iconv_open&lt;/CODE&gt; function was introduced early in the X/Open
         Portability Guide, version 2.  It is supported by all commercial
         Unices as it is required for the Unix branding.  However, the quality and
         completeness of the implementation varies widely.  The &lt;CODE&gt;iconv_open&lt;/CODE&gt;
         function is declared in &lt;TT&gt;iconv.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-iconv_close" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="iconv_t cd"/>
      </prototype>
      <headers>
        <header filename = "iconv.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;iconv_close&lt;/CODE&gt; function frees all resources associated with the
         handle &lt;VAR&gt;cd&lt;/VAR&gt;, which must have been returned by a successful call to
         the &lt;CODE&gt;iconv_open&lt;/CODE&gt; function.
         &lt;br&gt;&lt;br&gt; If the function call was successful the return value is 0.
         Otherwise it is -1 and &lt;CODE&gt;errno&lt;/CODE&gt; is set appropriately.
         Defined error are:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The conversion descriptor is invalid.

         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;iconv_close&lt;/CODE&gt; function was introduced together with the rest
         of the &lt;CODE&gt;iconv&lt;/CODE&gt; functions in XPG2 and is declared in &lt;TT&gt;iconv.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-iconv" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="iconv_t cd"/>
        <parameter content="char **inbuf"/>
        <parameter content="size_t *inbytesleft"/>
        <parameter content="char **outbuf"/>
        <parameter content="size_t *outbytesleft"/>
      </prototype>
      <headers>
        <header filename = "iconv.h"/>
      </headers>
        <synopsis>

         The &lt;CODE&gt;iconv&lt;/CODE&gt; function converts the text in the input buffer
         according to the rules associated with the descriptor &lt;VAR&gt;cd&lt;/VAR&gt; and
         stores the result in the output buffer.  It is possible to call the
         function for the same text several times in a row since for stateful
         character sets the necessary state information is kept in the data
         structures associated with the descriptor.
         &lt;br&gt;&lt;br&gt; The input buffer is specified by &lt;CODE&gt;*&lt;VAR&gt;inbuf&lt;/VAR&gt;&lt;/CODE&gt; and it contains
         &lt;CODE&gt;*&lt;VAR&gt;inbytesleft&lt;/VAR&gt;&lt;/CODE&gt; bytes.  The extra indirection is necessary for
         communicating the used input back to the caller (see below).  It is
         important to note that the buffer pointer is of type &lt;CODE&gt;char&lt;/CODE&gt; and the
         length is measured in bytes even if the input text is encoded in wide
         characters.
         &lt;br&gt;&lt;br&gt; The output buffer is specified in a similar way.  &lt;CODE&gt;*&lt;VAR&gt;outbuf&lt;/VAR&gt;&lt;/CODE&gt;
         points to the beginning of the buffer with at least
         &lt;CODE&gt;*&lt;VAR&gt;outbytesleft&lt;/VAR&gt;&lt;/CODE&gt; bytes room for the result.  The buffer
         pointer again is of type &lt;CODE&gt;char&lt;/CODE&gt; and the length is measured in
         bytes.  If &lt;VAR&gt;outbuf&lt;/VAR&gt; or &lt;CODE&gt;*&lt;VAR&gt;outbuf&lt;/VAR&gt;&lt;/CODE&gt; is a null pointer, the
         conversion is performed but no output is available.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;inbuf&lt;/VAR&gt; is a null pointer, the &lt;CODE&gt;iconv&lt;/CODE&gt; function performs the
         necessary action to put the state of the conversion into the initial
         state.  This is obviously a no-op for non-stateful encodings, but if the
         encoding has a state, such a function call might put some byte sequences
         in the output buffer, which perform the necessary state changes.  The
         next call with &lt;VAR&gt;inbuf&lt;/VAR&gt; not being a null pointer then simply goes on
         from the initial state.  It is important that the programmer never makes
         any assumption as to whether the conversion has to deal with states.
         Even if the input and output character sets are not stateful, the
         implementation might still have to keep states.  This is due to the
         implementation chosen for the GNU C library as it is described below.
         Therefore an &lt;CODE&gt;iconv&lt;/CODE&gt; call to reset the state should always be
         performed if some protocol requires this for the output text.
         &lt;br&gt;&lt;br&gt; The conversion stops for one of three reasons. The first is that all
         characters from the input buffer are converted.  This actually can mean
         two things: either all bytes from the input buffer are consumed or
         there are some bytes at the end of the buffer that possibly can form a
         complete character but the input is incomplete.  The second reason for a
         stop is that the output buffer is full.  And the third reason is that
         the input contains invalid characters.
         &lt;br&gt;&lt;br&gt; In all of these cases the buffer pointers after the last successful
         conversion, for input and output buffer, are stored in &lt;VAR&gt;inbuf&lt;/VAR&gt; and
         &lt;VAR&gt;outbuf&lt;/VAR&gt;, and the available room in each buffer is stored in
         &lt;VAR&gt;inbytesleft&lt;/VAR&gt; and &lt;VAR&gt;outbytesleft&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; Since the character sets selected in the &lt;CODE&gt;iconv_open&lt;/CODE&gt; call can be
         almost arbitrary, there can be situations where the input buffer contains
         valid characters, which have no identical representation in the output
         character set.  The behavior in this situation is undefined.  The
         &lt;EM&gt;current&lt;/EM&gt; behavior of the GNU C library in this situation is to
         return with an error immediately.  This certainly is not the most
         desirable solution; therefore, future versions will provide better ones,
         but they are not yet finished.
         &lt;br&gt;&lt;br&gt; If all input from the input buffer is successfully converted and stored
         in the output buffer, the function returns the number of non-reversible
         conversions performed.  In all other cases the return value is
         &lt;CODE&gt;(size_t) -1&lt;/CODE&gt; and &lt;CODE&gt;errno&lt;/CODE&gt; is set appropriately.  In such cases
         the value pointed to by &lt;VAR&gt;inbytesleft&lt;/VAR&gt; is nonzero.
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EILSEQ&lt;/CODE&gt;
&lt;DD&gt;
         The conversion stopped because of an invalid byte sequence in the input.
         After the call, &lt;CODE&gt;*&lt;VAR&gt;inbuf&lt;/VAR&gt;&lt;/CODE&gt; points at the first byte of the
         invalid byte sequence.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; E2BIG
         The conversion stopped because it ran out of space in the output buffer.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         The conversion stopped because of an incomplete byte sequence at the end
         of the input buffer.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EBADF
         The &lt;VAR&gt;cd&lt;/VAR&gt; argument is invalid.

         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;iconv&lt;/CODE&gt; function was introduced in the XPG2 standard and is
         declared in the &lt;TT&gt;iconv.h&lt;/TT&gt; header.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-__gconv_step" type="struct">
    <structure>
        <synopsis>
        This data structure describes one conversion a module can perform.  For
         each function in a loaded module with conversion functions there is
         exactly one object of this type.  This object is shared by all users of
         the conversion (i.e., this object does not contain any information
         corresponding to an actual conversion; it only describes the conversion
         itself).
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="struct __gconv_loaded_object *__shlib_handle">
        </element>
        <element content="&lt;LI&gt;x const char *__modname">
        </element>
        <element content="&lt;LI&gt;x int __counter">
            <synopsis>
            All these elements of the structure are used internally in the C library
             to coordinate loading and unloading the shared.  One must not expect any
             of the other elements to be available or initialized.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="const char *__from_name">
        </element>
        <element content="&lt;LI&gt;x const char *__to_name">
            <synopsis>
            &lt;CODE&gt;__from_name&lt;/CODE&gt; and &lt;CODE&gt;__to_name&lt;/CODE&gt; contain the names of the source and
             destination character sets.  They can be used to identify the actual
             conversion to be carried out since one module might implement conversions
             for more than one character set and/or direction.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="gconv_fct __fct">
        </element>
        <element content="&lt;LI&gt;x gconv_init_fct __init_fct">
        </element>
        <element content="&lt;LI&gt;x gconv_end_fct __end_fct">
            <synopsis>
            These elements contain pointers to the functions in the loadable module.
             The interface will be explained below.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int __min_needed_from">
        </element>
        <element content="&lt;LI&gt;x int __max_needed_from">
        </element>
        <element content="&lt;LI&gt;x int __min_needed_to">
        </element>
        <element content="&lt;LI&gt;x int __max_needed_to;">
            <synopsis>
            These values have to be supplied in the init function of the module.  The
             &lt;CODE&gt;__min_needed_from&lt;/CODE&gt; value specifies how many bytes a character of
             the source character set at least needs.  The &lt;CODE&gt;__max_needed_from&lt;/CODE&gt;
             specifies the maximum value that also includes possible shift sequences.
             &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;__min_needed_to&lt;/CODE&gt; and &lt;CODE&gt;__max_needed_to&lt;/CODE&gt; values serve the
             same purpose as &lt;CODE&gt;__min_needed_from&lt;/CODE&gt; and &lt;CODE&gt;__max_needed_from&lt;/CODE&gt; but
             this time for the destination character set.
             &lt;br&gt;&lt;br&gt; It is crucial that these values be accurate since otherwise the
             conversion functions will have problems or not work at all.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int __stateful">
            <synopsis>
            This element must also be initialized by the init function.
             &lt;CODE&gt;int __stateful&lt;/CODE&gt; is nonzero if the source character set is stateful.
             Otherwise it is zero.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="struct-__gconv_step_data" type="struct">
    <structure>
        <synopsis>
        This is the data structure that contains the information specific to
         each use of the conversion functions.
         &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="char *__outbuf">
        </element>
        <element content="&lt;LI&gt;x char *__outbufend">
            <synopsis>
            These elements specify the output buffer for the conversion step.  The
             &lt;CODE&gt;__outbuf&lt;/CODE&gt; element points to the beginning of the buffer, and
             &lt;CODE&gt;__outbufend&lt;/CODE&gt; points to the byte following the last byte in the
             buffer.  The conversion function must not assume anything about the size
             of the buffer but it can be safely assumed the there is room for at
             least one complete character in the output buffer.
             &lt;br&gt;&lt;br&gt; Once the conversion is finished, if the conversion is the last step, the
             &lt;CODE&gt;__outbuf&lt;/CODE&gt; element must be modified to point after the last byte
             written into the buffer to signal how much output is available.  If this
             conversion step is not the last one, the element must not be modified.
             The &lt;CODE&gt;__outbufend&lt;/CODE&gt; element must not be modified.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int __is_last">
            <synopsis>
            This element is nonzero if this conversion step is the last one.  This
             information is necessary for the recursion.  See the description of the
             conversion function internals below.  This element must never be
             modified.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int __invocation_counter">
            <synopsis>
            The conversion function can use this element to see how many calls of
             the conversion function already happened.  Some character sets require a
             certain prolog when generating output, and by comparing this value with
             zero, one can find out whether it is the first call and whether,
             therefore, the prolog should be emitted.  This element must never be
             modified.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int __internal_use">
            <synopsis>
            This element is another one rarely used but needed in certain
             situations.  It is assigned a nonzero value in case the conversion
             functions are used to implement &lt;CODE&gt;mbsrtowcs&lt;/CODE&gt; et.al.: (i.e., the
             function is not used directly through the &lt;CODE&gt;iconv&lt;/CODE&gt; interface).
             &lt;br&gt;&lt;br&gt; This sometimes makes a difference as it is expected that the
             &lt;CODE&gt;iconv&lt;/CODE&gt; functions are used to translate entire texts while the
             &lt;CODE&gt;mbsrtowcs&lt;/CODE&gt; functions are normally used only to convert single
             strings and might be used multiple times to convert entire texts.
             &lt;br&gt;&lt;br&gt; But in this situation we would have problem complying with some rules of
             the character set specification.  Some character sets require a prolog,
             which must appear exactly once for an entire text.  If a number of
             &lt;CODE&gt;mbsrtowcs&lt;/CODE&gt; calls are used to convert the text, only the first call
             must add the prolog.  However, because there is no communication between the
             different calls of &lt;CODE&gt;mbsrtowcs&lt;/CODE&gt;, the conversion functions have no
             possibility to find this out.  The situation is different for sequences
             of &lt;CODE&gt;iconv&lt;/CODE&gt; calls since the handle allows access to the needed
             information.
             &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;int __internal_use&lt;/CODE&gt; element is mostly used together with
             &lt;CODE&gt;__invocation_counter&lt;/CODE&gt; as follows:
             &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
             if (!data-&gt;__internal_use&lt;br&gt;
                  &amp;&amp; data-&gt;__invocation_counter == 0)&lt;br&gt;
               /* Emit prolog.  */&lt;br&gt;
               &lt;small&gt;...&lt;/small&gt;&lt;br&gt;
             &lt;/pre&gt;
             &lt;br&gt;&lt;br&gt; This element must never be modified.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="mbstate_t *__statep">
            <synopsis>
            The &lt;CODE&gt;__statep&lt;/CODE&gt; element points to an object of type &lt;CODE&gt;mbstate_t&lt;/CODE&gt;
             .  The conversion of a stateful character
             set must use the object pointed to by &lt;CODE&gt;__statep&lt;/CODE&gt; to store
             information about the conversion state.  The &lt;CODE&gt;__statep&lt;/CODE&gt; element
             itself must never be modified.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-argp_parse" type="function">
    <function returntype="error_t">
      <prototype>
        <parameter content="const struct argp *argp"/>
        <parameter content="int argc"/>
        <parameter content="char **argv"/>
        <parameter content="unsigned flags"/>
        <parameter content="int *arg_index"/>
        <parameter content="void *input"/>
      </prototype>
      <headers>
        <header filename = "gconv.h"/>
        <header filename = "argp.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;argp_parse&lt;/CODE&gt; function parses the arguments in &lt;VAR&gt;argv&lt;/VAR&gt;, of
         length &lt;VAR&gt;argc&lt;/VAR&gt;, using the argp parser &lt;VAR&gt;argp&lt;/VAR&gt;.  .
         &lt;br&gt;&lt;br&gt; A value of zero is the same as a &lt;CODE&gt;struct argp&lt;/CODE&gt;containing all
         zeros.  &lt;VAR&gt;flags&lt;/VAR&gt; is a set of flag bits that modify the parsing
         behavior.  .  &lt;VAR&gt;input&lt;/VAR&gt; is passed through to the argp
         parser &lt;VAR&gt;argp&lt;/VAR&gt;, and has meaning defined by &lt;VAR&gt;argp&lt;/VAR&gt;.  A typical
         usage is to pass a pointer to a structure which is used for specifying
         parameters to the parser and passing back the results.
         &lt;br&gt;&lt;br&gt; Unless the &lt;CODE&gt;ARGP_NO_EXIT&lt;/CODE&gt; or &lt;CODE&gt;ARGP_NO_HELP&lt;/CODE&gt; flags are included
         in &lt;VAR&gt;flags&lt;/VAR&gt;, calling &lt;CODE&gt;argp_parse&lt;/CODE&gt; may result in the program
         exiting.  This behavior is true if an error is detected, or when an
         unknown option is encountered.  .
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;arg_index&lt;/VAR&gt; is non-null, the index of the first unparsed option
         in &lt;VAR&gt;argv&lt;/VAR&gt; is returned as a value.
         &lt;br&gt;&lt;br&gt; The return value is zero for successful parsing, or an error code
          if an error is detected.  Different argp parsers
         may return arbitrary error codes, but the standard error codes are:
         &lt;CODE&gt;ENOMEM&lt;/CODE&gt; if a memory allocation error occurred, or &lt;CODE&gt;EINVAL&lt;/CODE&gt; if
         an unknown option or option argument is encountered.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-argp" type="struct">
    <structure>
        <synopsis>
        This structure specifies how to parse a given set of options and
         arguments, perhaps in conjunction with other argp parsers.  It has the
         following fields:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="const struct argp_option *options">
            <synopsis>
            A pointer to a vector of &lt;CODE&gt;argp_option&lt;/CODE&gt; structures specifying which
             options this argp parser understands; it may be zero if there are no
             options at all.  .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="argp_parser_t parser">
            <synopsis>
            A pointer to a function that defines actions for this parser; it is
             called for each option parsed, and at other well-defined points in the
             parsing process.  A value of zero is the same as a pointer to a function
             that always returns &lt;CODE&gt;ARGP_ERR_UNKNOWN&lt;/CODE&gt;.  .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="const char *args_doc">
            <synopsis>
            If non-zero, a string describing what non-option arguments are called by
             this parser.  This is only used to print the &lt;samp&gt;Usage:&lt;/samp&gt; message.  If
             it contains newlines, the strings separated by them are considered
             alternative usage patterns and printed on separate lines.  Lines after
             the first are prefixed by &lt;samp&gt; or: &lt;/samp&gt; instead of &lt;samp&gt;Usage:&lt;/samp&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="const char *doc">
            <synopsis>
            If non-zero, a string containing extra text to be printed before and
             after the options in a long help message, with the two sections
             separated by a vertical tab (&lt;CODE&gt;'\v'&lt;/CODE&gt;, &lt;CODE&gt;'\013'&lt;/CODE&gt;) character.  By
             convention, the documentation before the options is just a short string
             explaining what the program does.  Documentation printed after the
             options describe behavior in more detail.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="const struct argp_child *children">
            <synopsis>
            A pointer to a vector of &lt;CODE&gt;argp_children&lt;/CODE&gt; structures.  This pointer
             specifies which additional argp parsers should be combined with this
             one.  .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="char *(*help_filter)(int &lt;VAR&gt;key&lt;/VAR&gt;, const char *&lt;VAR&gt;text&lt;/VAR&gt;, void *&lt;VAR&gt;input&lt;/VAR&gt;)">
            <synopsis>
            If non-zero, a pointer to a function that filters the output of help
             messages.  .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="struct-argp_option" type="struct">
    <structure>
        <synopsis>
        This structure specifies a single option that an argp parser
         understands, as well as how to parse and document that option.  It has
         the following fields:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="const char *name">
            <synopsis>
            The long name for this option, corresponding to the long option
             &lt;samp&gt;--&lt;VAR&gt;name&lt;/VAR&gt;&lt;/samp&gt;; this field may be zero if this option &lt;EM&gt;only&lt;/EM&gt;
             has a short name.  To specify multiple names for an option, additional
             entries may follow this one, with the &lt;CODE&gt;OPTION_ALIAS&lt;/CODE&gt; flag
             set.  .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int key">
            <synopsis>
            The integer key provided by the current option to the option parser.  If
             &lt;VAR&gt;key&lt;/VAR&gt; has a value that is a printable ascii character (i.e.,
             &lt;CODE&gt;isascii (&lt;VAR&gt;key&lt;/VAR&gt;)&lt;/CODE&gt; is true), it &lt;EM&gt;also&lt;/EM&gt; specifies a short
             option &lt;samp&gt;-&lt;VAR&gt;char&lt;/VAR&gt;&lt;/samp&gt;, where &lt;VAR&gt;char&lt;/VAR&gt; is the ascii character
             with the code &lt;VAR&gt;key&lt;/VAR&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="const char *arg">
            <synopsis>
            If non-zero, this is the name of an argument associated with this
             option, which must be provided (e.g., with the
             &lt;samp&gt;--&lt;VAR&gt;name&lt;/VAR&gt;=&lt;VAR&gt;value&lt;/VAR&gt;&lt;/samp&gt; or &lt;samp&gt;-&lt;VAR&gt;char&lt;/VAR&gt; &lt;VAR&gt;value&lt;/VAR&gt;&lt;/samp&gt;
             syntaxes), unless the &lt;CODE&gt;OPTION_ARG_OPTIONAL&lt;/CODE&gt; flag  is set, in which case it &lt;EM&gt;may&lt;/EM&gt; be provided.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int flags">
            <synopsis>
            Flags associated with this option, some of which are referred to above.
             .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="const char *doc">
            <synopsis>
            A documentation string for this option, for printing in help messages.
             &lt;br&gt;&lt;br&gt; If both the &lt;CODE&gt;name&lt;/CODE&gt; and &lt;CODE&gt;key&lt;/CODE&gt; fields are zero, this string
             will be printed tabbed left from the normal option column, making it
             useful as a group header.  This will be the first thing printed in its
             group.  In this usage, it's conventional to end the string with a
             &lt;samp&gt;:&lt;/samp&gt; character.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-argp_usage" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="const struct argp_state *state"/>
      </prototype>
      <headers>
        <header filename = "argp.h"/>
      </headers>
        <synopsis>
        Outputs the standard usage message for the argp parser referred to by
         &lt;VAR&gt;state&lt;/VAR&gt; to &lt;CODE&gt;&lt;VAR&gt;state&lt;/VAR&gt;-&gt;err_stream&lt;/CODE&gt; and terminate the program
         with &lt;CODE&gt;exit (argp_err_exit_status)&lt;/CODE&gt;.  .
        </synopsis>
    </function>
  </construct>
  <construct id="function-argp_error" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="const struct argp_state *state"/>
        <parameter content="const char *fmt"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "argp.h"/>
      </headers>
        <synopsis>
        Prints the printf format string &lt;VAR&gt;fmt&lt;/VAR&gt; and following args, preceded
         by the program name and &lt;samp&gt;:&lt;/samp&gt;, and followed by a &lt;samp&gt;Try &lt;small&gt;...&lt;/small&gt;
         --help&lt;/samp&gt; message, and terminates the program with an exit status of
         &lt;CODE&gt;argp_err_exit_status&lt;/CODE&gt;.  .
        </synopsis>
    </function>
  </construct>
  <construct id="function-argp_failure" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="const struct argp_state *state"/>
        <parameter content="int status"/>
        <parameter content="int errnum"/>
        <parameter content="const char *fmt"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "argp.h"/>
      </headers>
        <synopsis>
        Similar to the standard gnu error-reporting function &lt;CODE&gt;error&lt;/CODE&gt;, this
         prints the program name and &lt;samp&gt;:&lt;/samp&gt;, the printf format string
         &lt;VAR&gt;fmt&lt;/VAR&gt;, and the appropriate following args.  If it is non-zero, the
         standard unix error text for &lt;VAR&gt;errnum&lt;/VAR&gt; is printed.  If &lt;VAR&gt;status&lt;/VAR&gt; is
         non-zero, it terminates the program with that value as its exit status.
         &lt;br&gt;&lt;br&gt; The difference between &lt;CODE&gt;argp_failure&lt;/CODE&gt; and &lt;CODE&gt;argp_error&lt;/CODE&gt; is that
         &lt;CODE&gt;argp_error&lt;/CODE&gt; is for &lt;EM&gt;parsing errors&lt;/EM&gt;, whereas
         &lt;CODE&gt;argp_failure&lt;/CODE&gt; is for other problems that occur during parsing but
         don't reflect a syntactic problem with the input, such as illegal values
         for options, bad phase of the moon, etc.
        </synopsis>
    </function>
  </construct>
  <construct id="function-argp_state_help" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="const struct argp_state *state"/>
        <parameter content="FILE *stream"/>
        <parameter content="unsigned flags"/>
      </prototype>
      <headers>
        <header filename = "argp.h"/>
      </headers>
        <synopsis>
        Outputs a help message for the argp parser referred to by &lt;VAR&gt;state&lt;/VAR&gt;,
         to &lt;VAR&gt;stream&lt;/VAR&gt;.  The &lt;VAR&gt;flags&lt;/VAR&gt; argument determines what sort of help
         message is produced.  .
        </synopsis>
    </function>
  </construct>
  <construct id="struct-argp_state" type="struct">
    <structure>
        <synopsis>
        This structure has the following fields, which may be modified as noted:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="const struct argp *const root_argp">
            <synopsis>
            The top level argp parser being parsed.  Note that this is often
             &lt;EM&gt;not&lt;/EM&gt; the same &lt;CODE&gt;struct argp&lt;/CODE&gt; passed into &lt;CODE&gt;argp_parse&lt;/CODE&gt; by
             the invoking program.  .  It is an internal argp parser that
             contains options implemented by &lt;CODE&gt;argp_parse&lt;/CODE&gt; itself, such as
             &lt;samp&gt;--help&lt;/samp&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int argc">
        </element>
        <element content="&lt;LI&gt;x char **argv">
            <synopsis>
            The argument vector being parsed.  This may be modified.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int next">
            <synopsis>
            The index in &lt;CODE&gt;argv&lt;/CODE&gt; of the next argument to be parsed.  This may be
             modified.
             &lt;br&gt;&lt;br&gt; One way to consume all remaining arguments in the input is to set
             &lt;CODE&gt;&lt;VAR&gt;state&lt;/VAR&gt;-&gt;next = &lt;VAR&gt;state&lt;/VAR&gt;-&gt;argc&lt;/CODE&gt;, perhaps after recording
             the value of the &lt;CODE&gt;next&lt;/CODE&gt; field to find the consumed arguments.  The
             current option can be re-parsed immediately by decrementing this field,
             then modifying &lt;CODE&gt;&lt;VAR&gt;state&lt;/VAR&gt;-&gt;argv[&lt;VAR&gt;state&lt;/VAR&gt;-&gt;next]&lt;/CODE&gt; to reflect
             the option that should be reexamined.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="unsigned flags">
            <synopsis>
            The flags supplied to &lt;CODE&gt;argp_parse&lt;/CODE&gt;.  These may be modified, although
             some flags may only take effect when &lt;CODE&gt;argp_parse&lt;/CODE&gt; is first
             invoked.  .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="unsigned arg_num">
            <synopsis>
            While calling a parsing function with the &lt;VAR&gt;key&lt;/VAR&gt; argument
             &lt;CODE&gt;ARGP_KEY_ARG&lt;/CODE&gt;, this represents the number of the current arg,
             starting at 0.  It is incremented after each &lt;CODE&gt;ARGP_KEY_ARG&lt;/CODE&gt; call
             returns.  At all other times, this is the number of &lt;CODE&gt;ARGP_KEY_ARG&lt;/CODE&gt;
             arguments that have been processed.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int quoted">
            <synopsis>
            If non-zero, the index in &lt;CODE&gt;argv&lt;/CODE&gt; of the first argument following a
             special &lt;samp&gt;--&lt;/samp&gt; argument.  This prevents anything that follows from
             being interpreted as an option.  It is only set after argument parsing
             has proceeded past this point.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="void *input">
            <synopsis>
            An arbitrary pointer passed in from the caller of &lt;CODE&gt;argp_parse&lt;/CODE&gt;, in
             the &lt;VAR&gt;input&lt;/VAR&gt; argument.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="void **child_inputs">
            <synopsis>
            These are values that will be passed to child parsers.  This vector will
             be the same length as the number of children in the current parser.  Each
             child parser will be given the value of
             &lt;CODE&gt;&lt;VAR&gt;state&lt;/VAR&gt;-&gt;child_inputs[&lt;VAR&gt;i&lt;/VAR&gt;]&lt;/CODE&gt; as &lt;EM&gt;its&lt;/EM&gt;
             &lt;CODE&gt;&lt;VAR&gt;state&lt;/VAR&gt;-&gt;input&lt;/CODE&gt; field, where &lt;VAR&gt;i&lt;/VAR&gt; is the index of the child
             in the this parser's &lt;CODE&gt;children&lt;/CODE&gt; field.  .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="void *hook">
            <synopsis>
            For the parser function's use.  Initialized to 0, but otherwise ignored
             by argp.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="char *name">
            <synopsis>
            The name used when printing messages.  This is initialized to
             &lt;CODE&gt;argv[0]&lt;/CODE&gt;, or &lt;CODE&gt;program_invocation_name&lt;/CODE&gt; if &lt;CODE&gt;argv[0]&lt;/CODE&gt; is
             unavailable.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="FILE *err_stream">
        </element>
        <element content="&lt;LI&gt;x FILE *out_stream">
            <synopsis>
            The stdio streams used when argp prints.  Error messages are printed to
             &lt;CODE&gt;err_stream&lt;/CODE&gt;, all other output, such as &lt;samp&gt;--help&lt;/samp&gt; output) to
             &lt;CODE&gt;out_stream&lt;/CODE&gt;.  These are initialized to &lt;CODE&gt;stderr&lt;/CODE&gt; and
             &lt;CODE&gt;stdout&lt;/CODE&gt; respectively.  .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="struct-argp_child" type="struct">
    <structure>
        <synopsis>
        An entry in the list of subsidiary argp parsers pointed to by the
         &lt;CODE&gt;children&lt;/CODE&gt; field in a &lt;CODE&gt;struct argp&lt;/CODE&gt;.  The fields are as
         follows:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="const struct argp *argp">
            <synopsis>
            The child argp parser, or zero to end of the list.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int flags">
            <synopsis>
            Flags for this child.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="const char *header">
            <synopsis>
            If non-zero, this is an optional header to be printed within help output
             before the child options.  As a side-effect, a non-zero value forces the
             child options to be grouped together.  To achieve this effect without
             actually printing a header string, use a value of &lt;CODE&gt;""&lt;/CODE&gt;.  As with
             header strings specified in an option entry, the conventional value of
             the last character is &lt;samp&gt;:&lt;/samp&gt;.  .
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-argp_help" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="const struct argp *argp"/>
        <parameter content="FILE *stream"/>
        <parameter content="unsigned flags"/>
        <parameter content="char *name"/>
      </prototype>
      <headers>
        <header filename = "argp.h"/>
      </headers>
        <synopsis>
        This outputs a help message for the argp parser &lt;VAR&gt;argp&lt;/VAR&gt; to
         &lt;VAR&gt;stream&lt;/VAR&gt;.  The type of messages printed will be determined by
         &lt;VAR&gt;flags&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; Any options such as &lt;samp&gt;--help&lt;/samp&gt; that are implemented automatically by
         argp itself will &lt;EM&gt;not&lt;/EM&gt; be present in the help output; for this
         reason it is best to use &lt;CODE&gt;argp_state_help&lt;/CODE&gt; if calling from within
         an argp parser function.  .
        </synopsis>
    </function>
  </construct>
  <construct id="function-malloc" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        This function returns a pointer to a newly allocated block &lt;VAR&gt;size&lt;/VAR&gt;
         bytes long, or a null pointer if the block could not be allocated.
        </synopsis>
    </function>
  </construct>
  <construct id="function-free" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="void *ptr"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;free&lt;/CODE&gt; function deallocates the block of memory pointed at
         by &lt;VAR&gt;ptr&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cfree" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="void *ptr"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        This function does the same thing as &lt;CODE&gt;free&lt;/CODE&gt;.  It's provided for
         backward compatibility with SunOS; you should use &lt;CODE&gt;free&lt;/CODE&gt; instead.
        </synopsis>
    </function>
  </construct>
  <construct id="function-realloc" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="void *ptr"/>
        <parameter content="size_t newsize"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;realloc&lt;/CODE&gt; function changes the size of the block whose address is
         &lt;VAR&gt;ptr&lt;/VAR&gt; to be &lt;VAR&gt;newsize&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; Since the space after the end of the block may be in use, &lt;CODE&gt;realloc&lt;/CODE&gt;
         may find it necessary to copy the block to a new address where more free
         space is available.  The value of &lt;CODE&gt;realloc&lt;/CODE&gt; is the new address of the
         block.  If the block needs to be moved, &lt;CODE&gt;realloc&lt;/CODE&gt; copies the old
         contents.
         &lt;br&gt;&lt;br&gt; If you pass a null pointer for &lt;VAR&gt;ptr&lt;/VAR&gt;, &lt;CODE&gt;realloc&lt;/CODE&gt; behaves just
         like &lt;samp&gt;malloc (&lt;VAR&gt;newsize&lt;/VAR&gt;)&lt;/samp&gt;.  This can be convenient, but beware
         that older implementations (before ISO C) may not support this
         behavior, and will probably crash when &lt;CODE&gt;realloc&lt;/CODE&gt; is passed a null
         pointer.
        </synopsis>
    </function>
  </construct>
  <construct id="function-calloc" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="size_t count"/>
        <parameter content="size_t eltsize"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        This function allocates a block long enough to contain a vector of
         &lt;VAR&gt;count&lt;/VAR&gt; elements, each of size &lt;VAR&gt;eltsize&lt;/VAR&gt;.  Its contents are
         cleared to zero before &lt;CODE&gt;calloc&lt;/CODE&gt; returns.
        </synopsis>
    </function>
  </construct>
  <construct id="function-memalign" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="size_t boundary"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "malloc.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;memalign&lt;/CODE&gt; function allocates a block of &lt;VAR&gt;size&lt;/VAR&gt; bytes whose
         address is a multiple of &lt;VAR&gt;boundary&lt;/VAR&gt;.  The &lt;VAR&gt;boundary&lt;/VAR&gt; must be a
         power of two!  The function &lt;CODE&gt;memalign&lt;/CODE&gt; works by allocating a
         somewhat larger block, and then returning an address within the block
         that is on the specified boundary.
        </synopsis>
    </function>
  </construct>
  <construct id="function-posix_memalign" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="void **memptr"/>
        <parameter content="size_t alignment"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;posix_memalign&lt;/CODE&gt; function is similar to the &lt;CODE&gt;memalign&lt;/CODE&gt;
         function in that it returns a buffer of &lt;VAR&gt;size&lt;/VAR&gt; bytes aligned to a
         multiple of &lt;VAR&gt;alignment&lt;/VAR&gt;.  But it adds one requirement to the
         parameter &lt;VAR&gt;alignment&lt;/VAR&gt;: the value must be a power of two multiple of
         &lt;CODE&gt;sizeof (void *)&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; If the function succeeds in allocation memory a pointer to the allocated
         memory is returned in &lt;CODE&gt;*&lt;VAR&gt;memptr&lt;/VAR&gt;&lt;/CODE&gt; and the return value is zero.
         Otherwise the function returns an error value indicating the problem.
         &lt;br&gt;&lt;br&gt; This function was introduced in POSIX 1003.1d.
        </synopsis>
    </function>
  </construct>
  <construct id="function-valloc" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        Using &lt;CODE&gt;valloc&lt;/CODE&gt; is like using &lt;CODE&gt;memalign&lt;/CODE&gt; and passing the page size
         as the value of the second argument.  It is implemented like this:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         void *&lt;br&gt;
         valloc (size_t size)&lt;br&gt;
         {&lt;br&gt;
           return memalign (getpagesize (), size);&lt;br&gt;
         }&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; Query Memory Parameters for more information about the memory
         subsystem.
        </synopsis>
    </function>
  </construct>
  <construct id="function-mallopt" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int param"/>
        <parameter content="int value"/>
      </prototype>
        <synopsis>
        When calling &lt;CODE&gt;mallopt&lt;/CODE&gt;, the &lt;VAR&gt;param&lt;/VAR&gt; argument specifies the
         parameter to be set, and &lt;VAR&gt;value&lt;/VAR&gt; the new value to be set.  Possible
         choices for &lt;VAR&gt;param&lt;/VAR&gt;, as defined in &lt;TT&gt;malloc.h&lt;/TT&gt;, are:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;M_TRIM_THRESHOLD&lt;/CODE&gt;
&lt;DD&gt;
         This is the minimum size (in bytes) of the top-most, releasable chunk
         that will cause &lt;CODE&gt;sbrk&lt;/CODE&gt; to be called with a negative argument in
         order to return memory to the system.
         &lt;LI&gt; M_TOP_PAD
         This parameter determines the amount of extra memory to obtain from the
         system when a call to &lt;CODE&gt;sbrk&lt;/CODE&gt; is required.  It also specifies the
         number of bytes to retain when shrinking the heap by calling &lt;CODE&gt;sbrk&lt;/CODE&gt;
         with a negative argument.  This provides the necessary hysteresis in
         heap size such that excessive amounts of system calls can be avoided.
         &lt;LI&gt; M_MMAP_THRESHOLD
         All chunks larger than this value are allocated outside the normal
         heap, using the &lt;CODE&gt;mmap&lt;/CODE&gt; system call.  This way it is guaranteed
         that the memory for these chunks can be returned to the system on
         &lt;CODE&gt;free&lt;/CODE&gt;.  Note that requests smaller than this threshold might still
         be allocated via &lt;CODE&gt;mmap&lt;/CODE&gt;.
         &lt;LI&gt; M_MMAP_MAX
         The maximum number of chunks to allocate with &lt;CODE&gt;mmap&lt;/CODE&gt;.  Setting this
         to zero disables all use of &lt;CODE&gt;mmap&lt;/CODE&gt;.
         &lt;LI&gt; M_PERTURB
         If non-zero, memory blocks are filled with values depending on some
         low order bits of this parameter when they are allocated (except when
         allocated by &lt;CODE&gt;calloc&lt;/CODE&gt;) and freed.  This can be used to debug the
         use of uninitialized or freed heap memory.

         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-mcheck" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="void (*abortfn) (enum mcheck_status status)"/>
      </prototype>
      <headers>
        <header filename = "mcheck.h"/>
      </headers>
        <synopsis>
        Calling &lt;CODE&gt;mcheck&lt;/CODE&gt; tells &lt;CODE&gt;malloc&lt;/CODE&gt; to perform occasional
         consistency checks.  These will catch things such as writing
         past the end of a block that was allocated with &lt;CODE&gt;malloc&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;abortfn&lt;/VAR&gt; argument is the function to call when an inconsistency
         is found.  If you supply a null pointer, then &lt;CODE&gt;mcheck&lt;/CODE&gt; uses a
         default function which prints a message and calls &lt;CODE&gt;abort&lt;/CODE&gt;
         .  The function you supply is called with
         one argument, which says what sort of inconsistency was detected; its
         type is described below.
         &lt;br&gt;&lt;br&gt; It is too late to begin allocation checking once you have allocated
         anything with &lt;CODE&gt;malloc&lt;/CODE&gt;.  So &lt;CODE&gt;mcheck&lt;/CODE&gt; does nothing in that
         case.  The function returns &lt;CODE&gt;-1&lt;/CODE&gt; if you call it too late, and
         &lt;CODE&gt;0&lt;/CODE&gt; otherwise (when it is successful).
         &lt;br&gt;&lt;br&gt; The easiest way to arrange to call &lt;CODE&gt;mcheck&lt;/CODE&gt; early enough is to use
         the option &lt;samp&gt;-lmcheck&lt;/samp&gt; when you link your program; then you don't
         need to modify your program source at all.  Alternatively you might use
         a debugger to insert a call to &lt;CODE&gt;mcheck&lt;/CODE&gt; whenever the program is
         started, for example these gdb commands will automatically call &lt;CODE&gt;mcheck&lt;/CODE&gt;
         whenever the program starts:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         (gdb) break main&lt;br&gt;
         Breakpoint 1, main (argc=2, argv=0xbffff964) at whatever.c:10&lt;br&gt;
         (gdb) command 1&lt;br&gt;
         Type commands for when breakpoint 1 is hit, one per line.&lt;br&gt;
         End with a line saying just "end".&lt;br&gt;
         &gt;call mcheck(0)&lt;br&gt;
         &gt;continue&lt;br&gt;
         &gt;end&lt;br&gt;
         (gdb) &lt;small&gt;...&lt;/small&gt;&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; This will however only work if no initialization function of any object
         involved calls any of the &lt;CODE&gt;malloc&lt;/CODE&gt; functions since &lt;CODE&gt;mcheck&lt;/CODE&gt;
         must be called before the first such function.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-mprobe" type="function">
    <function returntype="enum mcheck_status">
      <prototype>
        <parameter content="void *pointer"/>
      </prototype>
        <synopsis>
        The &lt;CODE&gt;mprobe&lt;/CODE&gt; function lets you explicitly check for inconsistencies
         in a particular allocated block.  You must have already called
         &lt;CODE&gt;mcheck&lt;/CODE&gt; at the beginning of the program, to do its occasional
         checks; calling &lt;CODE&gt;mprobe&lt;/CODE&gt; requests an additional consistency check
         to be done at the time of the call.
         &lt;br&gt;&lt;br&gt; The argument &lt;VAR&gt;pointer&lt;/VAR&gt; must be a pointer returned by &lt;CODE&gt;malloc&lt;/CODE&gt;
         or &lt;CODE&gt;realloc&lt;/CODE&gt;.  &lt;CODE&gt;mprobe&lt;/CODE&gt; returns a value that says what
         inconsistency, if any, was found.  The values are described below.
        </synopsis>
    </function>
  </construct>
  <construct id="enum-mcheck_status" type="enum">
    <structure>
        <synopsis>
        This enumerated type describes what kind of inconsistency was detected
         in an allocated block, if any.  Here are the possible values:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="MCHECK_DISABLED">
            <synopsis>
            &lt;CODE&gt;mcheck&lt;/CODE&gt; was not called before the first allocation.
             No consistency checking can be done.
            </synopsis>
        </element>
        <element content="MCHECK_OK">
            <synopsis>
            No inconsistency detected.
            </synopsis>
        </element>
        <element content="MCHECK_HEAD">
            <synopsis>
            The data immediately before the block was modified.
             This commonly happens when an array index or pointer
             is decremented too far.
            </synopsis>
        </element>
        <element content="MCHECK_TAIL">
            <synopsis>
            The data immediately after the block was modified.
             This commonly happens when an array index or pointer
             is incremented too far.
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="struct-mallinfo" type="struct">
    <structure>
        <synopsis>
        This structure type is used to return information about the dynamic
         memory allocator.  It contains the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="int arena">
            <synopsis>
            This is the total size of memory allocated with &lt;CODE&gt;sbrk&lt;/CODE&gt; by
             &lt;CODE&gt;malloc&lt;/CODE&gt;, in bytes.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int ordblks">
            <synopsis>
            This is the number of chunks not in use.  (The memory allocator
             internally gets chunks of memory from the operating system, and then
             carves them up to satisfy individual &lt;CODE&gt;malloc&lt;/CODE&gt; requests; see
             Efficiency and Malloc.)
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int smblks">
            <synopsis>
            This field is unused.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int hblks">
            <synopsis>
            This is the total number of chunks allocated with &lt;CODE&gt;mmap&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int hblkhd">
            <synopsis>
            This is the total size of memory allocated with &lt;CODE&gt;mmap&lt;/CODE&gt;, in bytes.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int usmblks">
            <synopsis>
            This field is unused.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int fsmblks">
            <synopsis>
            This field is unused.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int uordblks">
            <synopsis>
            This is the total size of memory occupied by chunks handed out by
             &lt;CODE&gt;malloc&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int fordblks">
            <synopsis>
            This is the total size of memory occupied by free (not in use) chunks.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-mallinfo" type="function">
    <function returntype="struct mallinfo">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "malloc.h"/>
      </headers>
        <synopsis>
        This function returns information about the current dynamic memory usage
         in a structure of type &lt;CODE&gt;struct mallinfo&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-mtrace" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "mcheck.h"/>
      </headers>
        <synopsis>
        When the &lt;CODE&gt;mtrace&lt;/CODE&gt; function is called it looks for an environment
         variable named &lt;CODE&gt;MALLOC_TRACE&lt;/CODE&gt;.  This variable is supposed to
         contain a valid file name.  The user must have write access.  If the
         file already exists it is truncated.  If the environment variable is not
         set or it does not name a valid file which can be opened for writing
         nothing is done.  The behavior of &lt;CODE&gt;malloc&lt;/CODE&gt; etc. is not changed.
         For obvious reasons this also happens if the application is installed
         with the SUID or SGID bit set.
         &lt;br&gt;&lt;br&gt; If the named file is successfully opened, &lt;CODE&gt;mtrace&lt;/CODE&gt; installs special
         handlers for the functions &lt;CODE&gt;malloc&lt;/CODE&gt;, &lt;CODE&gt;realloc&lt;/CODE&gt;, and
         &lt;CODE&gt;free&lt;/CODE&gt; .  From then on, all uses of these
         functions are traced and protocolled into the file.  There is now of
         course a speed penalty for all calls to the traced functions so tracing
         should not be enabled during normal use.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension and generally not available on other
         systems.  The prototype can be found in &lt;TT&gt;mcheck.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-muntrace" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "mcheck.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;muntrace&lt;/CODE&gt; function can be called after &lt;CODE&gt;mtrace&lt;/CODE&gt; was used
         to enable tracing the &lt;CODE&gt;malloc&lt;/CODE&gt; calls.  If no (successful) call of
         &lt;CODE&gt;mtrace&lt;/CODE&gt; was made &lt;CODE&gt;muntrace&lt;/CODE&gt; does nothing.
         &lt;br&gt;&lt;br&gt; Otherwise it deinstalls the handlers for &lt;CODE&gt;malloc&lt;/CODE&gt;, &lt;CODE&gt;realloc&lt;/CODE&gt;,
         and &lt;CODE&gt;free&lt;/CODE&gt; and then closes the protocol file.  No calls are
         protocolled anymore and the program runs again at full speed.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension and generally not available on other
         systems.  The prototype can be found in &lt;TT&gt;mcheck.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-obstack" type="struct">
    <structure>
    </structure>
  </construct>
  <construct id="function-obstack_init" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="struct obstack *obstack-ptr"/>
      </prototype>
      <headers>
        <header filename = "obstack.h"/>
      </headers>
        <synopsis>
        Initialize obstack &lt;VAR&gt;obstack-ptr&lt;/VAR&gt; for allocation of objects.  This
         function calls the obstack's &lt;CODE&gt;obstack_chunk_alloc&lt;/CODE&gt; function.  If
         allocation of memory fails, the function pointed to by
         &lt;CODE&gt;obstack_alloc_failed_handler&lt;/CODE&gt; is called.  The &lt;CODE&gt;obstack_init&lt;/CODE&gt;
         function always returns 1 (Compatibility notice: Former versions of
         obstack returned 0 if allocation failed).
        </synopsis>
    </function>
  </construct>
  <construct id="function-obstack_alloc" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="struct obstack *obstack-ptr"/>
        <parameter content="int size"/>
      </prototype>
      <headers>
        <header filename = "obstack.h"/>
      </headers>
        <synopsis>
        This allocates an uninitialized block of &lt;VAR&gt;size&lt;/VAR&gt; bytes in an obstack
         and returns its address.  Here &lt;VAR&gt;obstack-ptr&lt;/VAR&gt; specifies which obstack
         to allocate the block in; it is the address of the &lt;CODE&gt;struct obstack&lt;/CODE&gt;
         object which represents the obstack.  Each obstack function or macro
         requires you to specify an &lt;VAR&gt;obstack-ptr&lt;/VAR&gt; as the first argument.
         &lt;br&gt;&lt;br&gt; This function calls the obstack's &lt;CODE&gt;obstack_chunk_alloc&lt;/CODE&gt; function if
         it needs to allocate a new chunk of memory; it calls
         &lt;CODE&gt;obstack_alloc_failed_handler&lt;/CODE&gt; if allocation of memory by
         &lt;CODE&gt;obstack_chunk_alloc&lt;/CODE&gt; failed.
        </synopsis>
    </function>
  </construct>
  <construct id="function-obstack_copy" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="struct obstack *obstack-ptr"/>
        <parameter content="void *address"/>
        <parameter content="int size"/>
      </prototype>
      <headers>
        <header filename = "obstack.h"/>
      </headers>
        <synopsis>
        This allocates a block and initializes it by copying &lt;VAR&gt;size&lt;/VAR&gt;
         bytes of data starting at &lt;VAR&gt;address&lt;/VAR&gt;.  It calls
         &lt;CODE&gt;obstack_alloc_failed_handler&lt;/CODE&gt; if allocation of memory by
         &lt;CODE&gt;obstack_chunk_alloc&lt;/CODE&gt; failed.
        </synopsis>
    </function>
  </construct>
  <construct id="function-obstack_copy0" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="struct obstack *obstack-ptr"/>
        <parameter content="void *address"/>
        <parameter content="int size"/>
      </prototype>
      <headers>
        <header filename = "obstack.h"/>
      </headers>
        <synopsis>
        Like &lt;CODE&gt;obstack_copy&lt;/CODE&gt;, but appends an extra byte containing a null
         character.  This extra byte is not counted in the argument &lt;VAR&gt;size&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-obstack_free" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="struct obstack *obstack-ptr"/>
        <parameter content="void *object"/>
      </prototype>
      <headers>
        <header filename = "obstack.h"/>
      </headers>
        <synopsis>
        If &lt;VAR&gt;object&lt;/VAR&gt; is a null pointer, everything allocated in the obstack
         is freed.  Otherwise, &lt;VAR&gt;object&lt;/VAR&gt; must be the address of an object
         allocated in the obstack.  Then &lt;VAR&gt;object&lt;/VAR&gt; is freed, along with
         everything allocated in &lt;VAR&gt;obstack&lt;/VAR&gt; since &lt;VAR&gt;object&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-obstack_blank" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="struct obstack *obstack-ptr"/>
        <parameter content="int size"/>
      </prototype>
      <headers>
        <header filename = "obstack.h"/>
      </headers>
        <synopsis>
        The most basic function for adding to a growing object is
         &lt;CODE&gt;obstack_blank&lt;/CODE&gt;, which adds space without initializing it.
        </synopsis>
    </function>
  </construct>
  <construct id="function-obstack_grow" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="struct obstack *obstack-ptr"/>
        <parameter content="void *data"/>
        <parameter content="int size"/>
      </prototype>
      <headers>
        <header filename = "obstack.h"/>
      </headers>
        <synopsis>
        To add a block of initialized space, use &lt;CODE&gt;obstack_grow&lt;/CODE&gt;, which is
         the growing-object analogue of &lt;CODE&gt;obstack_copy&lt;/CODE&gt;.  It adds &lt;VAR&gt;size&lt;/VAR&gt;
         bytes of data to the growing object, copying the contents from
         &lt;VAR&gt;data&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-obstack_grow0" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="struct obstack *obstack-ptr"/>
        <parameter content="void *data"/>
        <parameter content="int size"/>
      </prototype>
      <headers>
        <header filename = "obstack.h"/>
      </headers>
        <synopsis>
        This is the growing-object analogue of &lt;CODE&gt;obstack_copy0&lt;/CODE&gt;.  It adds
         &lt;VAR&gt;size&lt;/VAR&gt; bytes copied from &lt;VAR&gt;data&lt;/VAR&gt;, followed by an additional null
         character.
        </synopsis>
    </function>
  </construct>
  <construct id="function-obstack_1grow" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="struct obstack *obstack-ptr"/>
        <parameter content="char c"/>
      </prototype>
      <headers>
        <header filename = "obstack.h"/>
      </headers>
        <synopsis>
        To add one character at a time, use the function &lt;CODE&gt;obstack_1grow&lt;/CODE&gt;.
         It adds a single byte containing &lt;VAR&gt;c&lt;/VAR&gt; to the growing object.
        </synopsis>
    </function>
  </construct>
  <construct id="function-obstack_ptr_grow" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="struct obstack *obstack-ptr"/>
        <parameter content="void *data"/>
      </prototype>
      <headers>
        <header filename = "obstack.h"/>
      </headers>
        <synopsis>
        Adding the value of a pointer one can use the function
         &lt;CODE&gt;obstack_ptr_grow&lt;/CODE&gt;.  It adds &lt;CODE&gt;sizeof (void *)&lt;/CODE&gt; bytes
         containing the value of &lt;VAR&gt;data&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-obstack_int_grow" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="struct obstack *obstack-ptr"/>
        <parameter content="int data"/>
      </prototype>
      <headers>
        <header filename = "obstack.h"/>
      </headers>
        <synopsis>
        A single value of type &lt;CODE&gt;int&lt;/CODE&gt; can be added by using the
         &lt;CODE&gt;obstack_int_grow&lt;/CODE&gt; function.  It adds &lt;CODE&gt;sizeof (int)&lt;/CODE&gt; bytes to
         the growing object and initializes them with the value of &lt;VAR&gt;data&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-obstack_finish" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="struct obstack *obstack-ptr"/>
      </prototype>
      <headers>
        <header filename = "obstack.h"/>
      </headers>
        <synopsis>
        When you are finished growing the object, use the function
         &lt;CODE&gt;obstack_finish&lt;/CODE&gt; to close it off and return its final address.
         &lt;br&gt;&lt;br&gt; Once you have finished the object, the obstack is available for ordinary
         allocation or for growing another object.
         &lt;br&gt;&lt;br&gt; This function can return a null pointer under the same conditions as
         &lt;CODE&gt;obstack_alloc&lt;/CODE&gt; .
        </synopsis>
    </function>
  </construct>
  <construct id="function-obstack_object_size" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="struct obstack *obstack-ptr"/>
      </prototype>
      <headers>
        <header filename = "obstack.h"/>
      </headers>
        <synopsis>
        This function returns the current size of the growing object, in bytes.
         Remember to call this function &lt;EM&gt;before&lt;/EM&gt; finishing the object.
         After it is finished, &lt;CODE&gt;obstack_object_size&lt;/CODE&gt; will return zero.
        </synopsis>
    </function>
  </construct>
  <construct id="function-obstack_room" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="struct obstack *obstack-ptr"/>
      </prototype>
      <headers>
        <header filename = "obstack.h"/>
      </headers>
        <synopsis>
        This returns the number of bytes that can be added safely to the current
         growing object (or to an object about to be started) in obstack
         &lt;VAR&gt;obstack&lt;/VAR&gt; using the fast growth functions.
        </synopsis>
    </function>
  </construct>
  <construct id="function-obstack_1grow_fast" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="struct obstack *obstack-ptr"/>
        <parameter content="char c"/>
      </prototype>
      <headers>
        <header filename = "obstack.h"/>
      </headers>
        <synopsis>
        The function &lt;CODE&gt;obstack_1grow_fast&lt;/CODE&gt; adds one byte containing the
         character &lt;VAR&gt;c&lt;/VAR&gt; to the growing object in obstack &lt;VAR&gt;obstack-ptr&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-obstack_ptr_grow_fast" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="struct obstack *obstack-ptr"/>
        <parameter content="void *data"/>
      </prototype>
      <headers>
        <header filename = "obstack.h"/>
      </headers>
        <synopsis>
        The function &lt;CODE&gt;obstack_ptr_grow_fast&lt;/CODE&gt; adds &lt;CODE&gt;sizeof (void *)&lt;/CODE&gt;
         bytes containing the value of &lt;VAR&gt;data&lt;/VAR&gt; to the growing object in
         obstack &lt;VAR&gt;obstack-ptr&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-obstack_int_grow_fast" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="struct obstack *obstack-ptr"/>
        <parameter content="int data"/>
      </prototype>
      <headers>
        <header filename = "obstack.h"/>
      </headers>
        <synopsis>
        The function &lt;CODE&gt;obstack_int_grow_fast&lt;/CODE&gt; adds &lt;CODE&gt;sizeof (int)&lt;/CODE&gt; bytes
         containing the value of &lt;VAR&gt;data&lt;/VAR&gt; to the growing object in obstack
         &lt;VAR&gt;obstack-ptr&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-obstack_blank_fast" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="struct obstack *obstack-ptr"/>
        <parameter content="int size"/>
      </prototype>
      <headers>
        <header filename = "obstack.h"/>
      </headers>
        <synopsis>
        The function &lt;CODE&gt;obstack_blank_fast&lt;/CODE&gt; adds &lt;VAR&gt;size&lt;/VAR&gt; bytes to the
         growing object in obstack &lt;VAR&gt;obstack-ptr&lt;/VAR&gt; without initializing them.
        </synopsis>
    </function>
  </construct>
  <construct id="function-obstack_base" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="struct obstack *obstack-ptr"/>
      </prototype>
      <headers>
        <header filename = "obstack.h"/>
      </headers>
        <synopsis>
        This function returns the tentative address of the beginning of the
         currently growing object in &lt;VAR&gt;obstack-ptr&lt;/VAR&gt;.  If you finish the object
         immediately, it will have that address.  If you make it larger first, it
         may outgrow the current chunk---then its address will change!
         &lt;br&gt;&lt;br&gt; If no object is growing, this value says where the next object you
         allocate will start (once again assuming it fits in the current
         chunk).
        </synopsis>
    </function>
  </construct>
  <construct id="function-obstack_next_free" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="struct obstack *obstack-ptr"/>
      </prototype>
      <headers>
        <header filename = "obstack.h"/>
      </headers>
        <synopsis>
        This function returns the address of the first free byte in the current
         chunk of obstack &lt;VAR&gt;obstack-ptr&lt;/VAR&gt;.  This is the end of the currently
         growing object.  If no object is growing, &lt;CODE&gt;obstack_next_free&lt;/CODE&gt;
         returns the same value as &lt;CODE&gt;obstack_base&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-obstack_object_size" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="struct obstack *obstack-ptr"/>
      </prototype>
      <headers>
        <header filename = "obstack.h"/>
      </headers>
        <synopsis>
        This function returns the size in bytes of the currently growing object.
         This is equivalent to
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         obstack_next_free (&lt;VAR&gt;obstack-ptr&lt;/VAR&gt;) - obstack_base (&lt;VAR&gt;obstack-ptr&lt;/VAR&gt;)&lt;br&gt;
         &lt;/pre&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-alloca" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The return value of &lt;CODE&gt;alloca&lt;/CODE&gt; is the address of a block of &lt;VAR&gt;size&lt;/VAR&gt;
         bytes of memory, allocated in the stack frame of the calling function.
        </synopsis>
    </function>
  </construct>
  <construct id="function-brk" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="void *addr"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; &lt;CODE&gt;brk&lt;/CODE&gt; sets the high end of the calling process' data segment to
         &lt;VAR&gt;addr&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The address of the end of a segment is defined to be the address of the
         last byte in the segment plus 1.
         &lt;br&gt;&lt;br&gt; The function has no effect if &lt;VAR&gt;addr&lt;/VAR&gt; is lower than the low end of
         the data segment.  (This is considered success, by the way).
         &lt;br&gt;&lt;br&gt; The function fails if it would cause the data segment to overlap another
         segment or exceed the process' data storage limit .
         &lt;br&gt;&lt;br&gt; The function is named for a common historical case where data storage
         and the stack are in the same segment.  Data storage allocation grows
         upward from the bottom of the segment while the stack grows downward
         toward it from the top of the segment and the curtain between them is
         called the break.
         &lt;br&gt;&lt;br&gt; The return value is zero on success.  On failure, the return value is
         &lt;CODE&gt;-1&lt;/CODE&gt; and &lt;CODE&gt;errno&lt;/CODE&gt; is set accordingly.  The following &lt;CODE&gt;errno&lt;/CODE&gt;
         values are specific to this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;ENOMEM&lt;/CODE&gt;
&lt;DD&gt;
         The request would cause the data segment to overlap another segment or
         exceed the process' data storage limit.

         &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-mlock" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const void *addr"/>
        <parameter content="size_t len"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
        <header filename = "sys/mman.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; &lt;CODE&gt;mlock&lt;/CODE&gt; locks a range of the calling process' virtual pages.
         &lt;br&gt;&lt;br&gt; The range of memory starts at address &lt;VAR&gt;addr&lt;/VAR&gt; and is &lt;VAR&gt;len&lt;/VAR&gt; bytes
         long.  Actually, since you must lock whole pages, it is the range of
         pages that include any part of the specified range.
         &lt;br&gt;&lt;br&gt; When the function returns successfully, each of those pages is backed by
         (connected to) a real frame (is resident) and is marked to stay that
         way.  This means the function may cause page-ins and have to wait for
         them.
         &lt;br&gt;&lt;br&gt; When the function fails, it does not affect the lock status of any
         pages.
         &lt;br&gt;&lt;br&gt; The return value is zero if the function succeeds.  Otherwise, it is
         &lt;CODE&gt;-1&lt;/CODE&gt; and &lt;CODE&gt;errno&lt;/CODE&gt; is set accordingly.  &lt;CODE&gt;errno&lt;/CODE&gt; values
         specific to this function are:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;ENOMEM&lt;/CODE&gt;
&lt;DD&gt;
         &lt;OL&gt;
         &lt;LI&gt;
         At least some of the specified address range does not exist in the
         calling process' virtual address space.
         &lt;LI&gt;
         The locking would cause the process to exceed its locked page limit.
         &lt;/OL&gt;
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EPERM
         The calling process is not superuser.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         &lt;VAR&gt;len&lt;/VAR&gt; is not positive.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOSYS
         The kernel does not provide &lt;CODE&gt;mlock&lt;/CODE&gt; capability.
         &lt;br&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; You can lock &lt;EM&gt;all&lt;/EM&gt; a process' memory with &lt;CODE&gt;mlockall&lt;/CODE&gt;.  You
         unlock memory with &lt;CODE&gt;munlock&lt;/CODE&gt; or &lt;CODE&gt;munlockall&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; To avoid all page faults in a C program, you have to use
         &lt;CODE&gt;mlockall&lt;/CODE&gt;, because some of the memory a program uses is hidden
         from the C code, e.g. the stack and automatic variables, and you
         wouldn't know what address to tell &lt;CODE&gt;mlock&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-munlock" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const void *addr"/>
        <parameter content="size_t len"/>
      </prototype>
      <headers>
        <header filename = "sys/mman.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; &lt;CODE&gt;munlock&lt;/CODE&gt; unlocks a range of the calling process' virtual pages.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;munlock&lt;/CODE&gt; is the inverse of &lt;CODE&gt;mlock&lt;/CODE&gt; and functions completely
         analogously to &lt;CODE&gt;mlock&lt;/CODE&gt;, except that there is no &lt;CODE&gt;EPERM&lt;/CODE&gt;
         failure.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-mlockall" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int flags"/>
      </prototype>
      <headers>
        <header filename = "sys/mman.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; &lt;CODE&gt;mlockall&lt;/CODE&gt; locks all the pages in a process' virtual memory address
         space, and/or any that are added to it in the future.  This includes the
         pages of the code, data and stack segment, as well as shared libraries,
         user space kernel data, shared memory, and memory mapped files.
         &lt;br&gt;&lt;br&gt; &lt;VAR&gt;flags&lt;/VAR&gt; is a string of single bit flags represented by the following
         macros.  They tell &lt;CODE&gt;mlockall&lt;/CODE&gt; which of its functions you want.  All
         other bits must be zero.
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;MCL_CURRENT&lt;/CODE&gt;
&lt;DD&gt;
         Lock all pages which currently exist in the calling process' virtual
         address space.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;MCL_FUTURE&lt;/CODE&gt;
&lt;DD&gt;
         Set a mode such that any pages added to the process' virtual address
         space in the future will be locked from birth.  This mode does not
         affect future address spaces owned by the same process so exec, which
         replaces a process' address space, wipes out &lt;CODE&gt;MCL_FUTURE&lt;/CODE&gt;.
         .
         &lt;br&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; When the function returns successfully, and you specified
         &lt;CODE&gt;MCL_CURRENT&lt;/CODE&gt;, all of the process' pages are backed by (connected
         to) real frames (they are resident) and are marked to stay that way.
         This means the function may cause page-ins and have to wait for them.
         &lt;br&gt;&lt;br&gt; When the process is in &lt;CODE&gt;MCL_FUTURE&lt;/CODE&gt; mode because it successfully
         executed this function and specified &lt;CODE&gt;MCL_CURRENT&lt;/CODE&gt;, any system call
         by the process that requires space be added to its virtual address space
         fails with &lt;CODE&gt;errno&lt;/CODE&gt; = &lt;CODE&gt;ENOMEM&lt;/CODE&gt; if locking the additional space
         would cause the process to exceed its locked page limit.  In the case
         that the address space addition that can't be accommodated is stack
         expansion, the stack expansion fails and the kernel sends a
         &lt;CODE&gt;SIGSEGV&lt;/CODE&gt; signal to the process.
         &lt;br&gt;&lt;br&gt; When the function fails, it does not affect the lock status of any pages
         or the future locking mode.
         &lt;br&gt;&lt;br&gt; The return value is zero if the function succeeds.  Otherwise, it is
         &lt;CODE&gt;-1&lt;/CODE&gt; and &lt;CODE&gt;errno&lt;/CODE&gt; is set accordingly.  &lt;CODE&gt;errno&lt;/CODE&gt; values
         specific to this function are:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;LI&gt; ENOMEM
         &lt;OL&gt;
         &lt;LI&gt;
         At least some of the specified address range does not exist in the
         calling process' virtual address space.
         &lt;LI&gt;
         The locking would cause the process to exceed its locked page limit.
         &lt;/OL&gt;
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EPERM
         The calling process is not superuser.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         Undefined bits in &lt;VAR&gt;flags&lt;/VAR&gt; are not zero.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOSYS
         The kernel does not provide &lt;CODE&gt;mlockall&lt;/CODE&gt; capability.
         &lt;br&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; You can lock just specific pages with &lt;CODE&gt;mlock&lt;/CODE&gt;.  You unlock pages
         with &lt;CODE&gt;munlockall&lt;/CODE&gt; and &lt;CODE&gt;munlock&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-munlockall" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "sys/mman.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; &lt;CODE&gt;munlockall&lt;/CODE&gt; unlocks every page in the calling process' virtual
         address space and turn off &lt;CODE&gt;MCL_FUTURE&lt;/CODE&gt; future locking mode.
         &lt;br&gt;&lt;br&gt; The return value is zero if the function succeeds.  Otherwise, it is
         &lt;CODE&gt;-1&lt;/CODE&gt; and &lt;CODE&gt;errno&lt;/CODE&gt; is set accordingly.  The only way this
         function can fail is for generic reasons that all functions and system
         calls can fail, so there are no specific &lt;CODE&gt;errno&lt;/CODE&gt; values.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-getrusage" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int processes"/>
        <parameter content="struct rusage *rusage"/>
      </prototype>
      <headers>
        <header filename = "malloc.h"/>
        <header filename = "sys/resource.h"/>
      </headers>
        <synopsis>
        This function reports resource usage totals for processes specified by
         &lt;VAR&gt;processes&lt;/VAR&gt;, storing the information in &lt;CODE&gt;*&lt;VAR&gt;rusage&lt;/VAR&gt;&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; In most systems, &lt;VAR&gt;processes&lt;/VAR&gt; has only two valid values:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;RUSAGE_SELF&lt;/CODE&gt;
&lt;DD&gt;
         Just the current process.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;RUSAGE_CHILDREN&lt;/CODE&gt;
&lt;DD&gt;
         All child processes (direct and indirect) that have already terminated.

         &lt;br&gt;&lt;br&gt; In the GNU system, you can also inquire about a particular child process
         by specifying its process ID.
         &lt;br&gt;&lt;br&gt; The return value of &lt;CODE&gt;getrusage&lt;/CODE&gt; is zero for success, and &lt;CODE&gt;-1&lt;/CODE&gt;
         for failure.
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;LI&gt; EINVAL
         The argument &lt;VAR&gt;processes&lt;/VAR&gt; is not valid.

        </synopsis>
    </function>
  </construct>
  <construct id="struct-rusage" type="struct">
    <structure>
        <synopsis>
        This data type stores various resource usage statistics.  It has the
         following members, and possibly others:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="struct timeval ru_utime">
            <synopsis>
            Time spent executing user instructions.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="struct timeval ru_stime">
            <synopsis>
            Time spent in operating system code on behalf of &lt;VAR&gt;processes&lt;/VAR&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int ru_maxrss">
            <synopsis>
            The maximum resident set size used, in kilobytes.  That is, the maximum
             number of kilobytes of physical memory that &lt;VAR&gt;processes&lt;/VAR&gt; used
             simultaneously.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int ru_ixrss">
            <synopsis>
            An integral value expressed in kilobytes times ticks of execution, which
             indicates the amount of memory used by text that was shared with other
             processes.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int ru_idrss">
            <synopsis>
            An integral value expressed the same way, which is the amount of
             unshared memory used for data.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int ru_isrss">
            <synopsis>
            An integral value expressed the same way, which is the amount of
             unshared memory used for stack space.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int ru_minflt">
            <synopsis>
            The number of page faults which were serviced without requiring any I/O.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int ru_majflt">
            <synopsis>
            The number of page faults which were serviced by doing I/O.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int ru_nswap">
            <synopsis>
            The number of times &lt;VAR&gt;processes&lt;/VAR&gt; was swapped entirely out of main memory.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int ru_inblock">
            <synopsis>
            The number of times the file system had to read from the disk on behalf
             of &lt;VAR&gt;processes&lt;/VAR&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int ru_oublock">
            <synopsis>
            The number of times the file system had to write to the disk on behalf
             of &lt;VAR&gt;processes&lt;/VAR&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int ru_msgsnd">
            <synopsis>
            Number of IPC messages sent.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int ru_msgrcv">
            <synopsis>
            Number of IPC messages received.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int ru_nsignals">
            <synopsis>
            Number of signals received.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="long int ru_nvcsw">
            <synopsis>
            The number of times &lt;VAR&gt;processes&lt;/VAR&gt; voluntarily invoked a context switch
             (usually to wait for some service).
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-vtimes" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="struct vtimes current"/>
        <parameter content="struct vtimes child"/>
      </prototype>
      <headers>
        <header filename = "sys/resource.h"/>
        <header filename = "vtimes.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; &lt;CODE&gt;vtimes&lt;/CODE&gt; reports resource usage totals for a process.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;current&lt;/VAR&gt; is non-null, &lt;CODE&gt;vtimes&lt;/CODE&gt; stores resource usage totals for
         the invoking process alone in the structure to which it points.  If
         &lt;VAR&gt;child&lt;/VAR&gt; is non-null, &lt;CODE&gt;vtimes&lt;/CODE&gt; stores resource usage totals for all
         past children (which have terminated) of the invoking process in the structure
         to which it points.
         &lt;br&gt;&lt;br&gt; &lt;h4&gt;Data Type - struct vtimes&lt;/h4&gt;
         This data type contains information about the resource usage of a process.
         Each member corresponds to a member of the &lt;CODE&gt;struct rusage&lt;/CODE&gt; data type
         described above.
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;vm_utime&lt;/CODE&gt;
&lt;DD&gt;
         User CPU time.  Analogous to &lt;CODE&gt;ru_utime&lt;/CODE&gt; in &lt;CODE&gt;struct rusage&lt;/CODE&gt;
         &lt;LI&gt; vm_stime
         System CPU time.  Analogous to &lt;CODE&gt;ru_stime&lt;/CODE&gt; in &lt;CODE&gt;struct rusage&lt;/CODE&gt;
         &lt;LI&gt; vm_idsrss
         Data and stack memory.  The sum of the values that would be reported as
         &lt;CODE&gt;ru_idrss&lt;/CODE&gt; and &lt;CODE&gt;ru_isrss&lt;/CODE&gt; in &lt;CODE&gt;struct rusage&lt;/CODE&gt;
         &lt;LI&gt; vm_ixrss
         Shared memory.  Analogous to &lt;CODE&gt;ru_ixrss&lt;/CODE&gt; in &lt;CODE&gt;struct rusage&lt;/CODE&gt;
         &lt;LI&gt; vm_maxrss
         Maximent resident set size.  Analogous to &lt;CODE&gt;ru_maxrss&lt;/CODE&gt; in
         &lt;CODE&gt;struct rusage&lt;/CODE&gt;
         &lt;LI&gt; vm_majflt
         Major page faults.  Analogous to &lt;CODE&gt;ru_majflt&lt;/CODE&gt; in &lt;CODE&gt;struct rusage&lt;/CODE&gt;
         &lt;LI&gt; vm_minflt
         Minor page faults.  Analogous to &lt;CODE&gt;ru_minflt&lt;/CODE&gt; in &lt;CODE&gt;struct rusage&lt;/CODE&gt;
         &lt;LI&gt; vm_nswap
         Swap count.  Analogous to &lt;CODE&gt;ru_nswap&lt;/CODE&gt; in &lt;CODE&gt;struct rusage&lt;/CODE&gt;
         &lt;LI&gt; vm_inblk
         Disk reads.  Analogous to &lt;CODE&gt;ru_inblk&lt;/CODE&gt; in &lt;CODE&gt;struct rusage&lt;/CODE&gt;
         &lt;LI&gt; vm_oublk
         Disk writes.  Analogous to &lt;CODE&gt;ru_oublk&lt;/CODE&gt; in &lt;CODE&gt;struct rusage&lt;/CODE&gt;


         &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt; The return value is zero if the function succeeds; &lt;CODE&gt;-1&lt;/CODE&gt; otherwise.
         &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-getrlimit" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int resource"/>
        <parameter content="struct rlimit *rlp"/>
      </prototype>
      <headers>
        <header filename = "sys/resource.h"/>
      </headers>
        <synopsis>
        Read the current and maximum limits for the resource &lt;VAR&gt;resource&lt;/VAR&gt;
         and store them in &lt;CODE&gt;*&lt;VAR&gt;rlp&lt;/VAR&gt;&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; on success and &lt;CODE&gt;-1&lt;/CODE&gt; on failure.  The
         only possible &lt;CODE&gt;errno&lt;/CODE&gt; error condition is &lt;CODE&gt;EFAULT&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; on a
         32-bit system this function is in fact &lt;CODE&gt;getrlimit64&lt;/CODE&gt;.  Thus, the
         LFS interface transparently replaces the old interface.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getrlimit64" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int resource"/>
        <parameter content="struct rlimit64 *rlp"/>
      </prototype>
      <headers>
        <header filename = "sys/resource.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;getrlimit&lt;/CODE&gt; but its second parameter is
         a pointer to a variable of type &lt;CODE&gt;struct rlimit64&lt;/CODE&gt;, which allows it
         to read values which wouldn't fit in the member of a &lt;CODE&gt;struct
         rlimit&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; If the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; on a
         32-bit machine, this function is available under the name
         &lt;CODE&gt;getrlimit&lt;/CODE&gt; and so transparently replaces the old interface.
        </synopsis>
    </function>
  </construct>
  <construct id="function-setrlimit" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int resource"/>
        <parameter content="const struct rlimit *rlp"/>
      </prototype>
      <headers>
        <header filename = "sys/resource.h"/>
      </headers>
        <synopsis>
        Store the current and maximum limits for the resource &lt;VAR&gt;resource&lt;/VAR&gt;
         in &lt;CODE&gt;*&lt;VAR&gt;rlp&lt;/VAR&gt;&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; on success and &lt;CODE&gt;-1&lt;/CODE&gt; on failure.  The
         following &lt;CODE&gt;errno&lt;/CODE&gt; error condition is possible:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EPERM&lt;/CODE&gt;
&lt;DD&gt;
         &lt;OL&gt;
         &lt;LI&gt;
         The process tried to raise a current limit beyond the maximum limit.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         The process tried to raise a maximum limit, but is not superuser.
         &lt;/OL&gt;

         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; on a
         32-bit system this function is in fact &lt;CODE&gt;setrlimit64&lt;/CODE&gt;.  Thus, the
         LFS interface transparently replaces the old interface.
        </synopsis>
    </function>
  </construct>
  <construct id="function-setrlimit64" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int resource"/>
        <parameter content="const struct rlimit64 *rlp"/>
      </prototype>
      <headers>
        <header filename = "sys/resource.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;setrlimit&lt;/CODE&gt; but its second parameter is
         a pointer to a variable of type &lt;CODE&gt;struct rlimit64&lt;/CODE&gt; which allows it
         to set values which wouldn't fit in the member of a &lt;CODE&gt;struct
         rlimit&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; If the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; on a
         32-bit machine this function is available under the name
         &lt;CODE&gt;setrlimit&lt;/CODE&gt; and so transparently replaces the old interface.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-rlimit" type="struct">
    <structure>
        <synopsis>
        This structure is used with &lt;CODE&gt;getrlimit&lt;/CODE&gt; to receive limit values,
         and with &lt;CODE&gt;setrlimit&lt;/CODE&gt; to specify limit values for a particular process
         and resource.  It has two fields:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="rlim_t rlim_cur">
            <synopsis>
            The current limit
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="struct-rlimit64" type="struct">
    <structure>
        <synopsis>
        This structure is analogous to the &lt;CODE&gt;rlimit&lt;/CODE&gt; structure above, but
         its components have wider ranges.  It has two fields:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="rlim64_t rlim_cur">
            <synopsis>
            This is analogous to &lt;CODE&gt;rlimit.rlim_cur&lt;/CODE&gt;, but with a different type.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-ulimit" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int cmd"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "sys/resource.h"/>
        <header filename = "ulimit.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; &lt;CODE&gt;ulimit&lt;/CODE&gt; gets the current limit or sets the current and maximum
         limit for a particular resource for the calling process according to the
         command &lt;VAR&gt;cmd&lt;/VAR&gt;.a
         &lt;br&gt;&lt;br&gt; If you are getting a limit, the command argument is the only argument.
         If you are setting a limit, there is a second argument:
         &lt;CODE&gt;long int&lt;/CODE&gt; &lt;VAR&gt;limit&lt;/VAR&gt; which is the value to which you are setting
         the limit.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;cmd&lt;/VAR&gt; values and the operations they specify are:
         &lt;DL&gt;

         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;GETFSIZE&lt;/CODE&gt;
&lt;DD&gt;
         Get the current limit on the size of a file, in units of 512 bytes.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;SETFSIZE&lt;/CODE&gt;
&lt;DD&gt;
         Set the current and maximum limit on the size of a file to &lt;VAR&gt;limit&lt;/VAR&gt; *
         512 bytes.
         &lt;br&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; There are also some other &lt;VAR&gt;cmd&lt;/VAR&gt; values that may do things on some
         systems, but they are not supported.
         &lt;br&gt;&lt;br&gt; Only the superuser may increase a maximum limit.
         &lt;br&gt;&lt;br&gt; When you successfully get a limit, the return value of &lt;CODE&gt;ulimit&lt;/CODE&gt; is
         that limit, which is never negative.  When you successfully set a limit,
         the return value is zero.  When the function fails, the return value is
         &lt;CODE&gt;-1&lt;/CODE&gt; and &lt;CODE&gt;errno&lt;/CODE&gt; is set according to the reason:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;LI&gt; EPERM
         A process tried to increase a maximum limit, but is not superuser.

         &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-vlimit" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int resource"/>
        <parameter content="int limit"/>
      </prototype>
      <headers>
        <header filename = "sys/vlimit.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; &lt;CODE&gt;vlimit&lt;/CODE&gt; sets the current limit for a resource for a process.
         &lt;br&gt;&lt;br&gt; &lt;VAR&gt;resource&lt;/VAR&gt; identifies the resource:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;LIM_CPU&lt;/CODE&gt;
&lt;DD&gt;
         Maximum CPU time.  Same as &lt;CODE&gt;RLIMIT_CPU&lt;/CODE&gt; for &lt;CODE&gt;setrlimit&lt;/CODE&gt;.
         &lt;DT&gt;&lt;CODE&gt;LIM_FSIZE&lt;/CODE&gt;
&lt;DD&gt;
         Maximum file size.  Same as &lt;CODE&gt;RLIMIT_FSIZE&lt;/CODE&gt; for &lt;CODE&gt;setrlimit&lt;/CODE&gt;.
         &lt;LI&gt; LIM_DATA
         Maximum data memory.  Same as &lt;CODE&gt;RLIMIT_DATA&lt;/CODE&gt; for &lt;CODE&gt;setrlimit&lt;/CODE&gt;.
         &lt;LI&gt; LIM_STACK
         Maximum stack size.  Same as &lt;CODE&gt;RLIMIT_STACK&lt;/CODE&gt; for &lt;CODE&gt;setrlimit&lt;/CODE&gt;.
         &lt;LI&gt; LIM_CORE
         Maximum core file size.  Same as &lt;CODE&gt;RLIMIT_COR&lt;/CODE&gt; for &lt;CODE&gt;setrlimit&lt;/CODE&gt;.
         &lt;LI&gt; LIM_MAXRSS
         Maximum physical memory.  Same as &lt;CODE&gt;RLIMIT_RSS&lt;/CODE&gt; for &lt;CODE&gt;setrlimit&lt;/CODE&gt;.

         &lt;br&gt;&lt;br&gt; The return value is zero for success, and &lt;CODE&gt;-1&lt;/CODE&gt; with &lt;CODE&gt;errno&lt;/CODE&gt; set
         accordingly for failure:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;LI&gt; EPERM
         The process tried to set its current limit beyond its maximum limit.

         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="struct-sched_param" type="struct">
    <structure>
        <synopsis>
        This structure describes an absolute priority.
        </synopsis>
    </structure>
  </construct>
  <construct id="function-sched_setscheduler" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="pid_t pid"/>
        <parameter content="int policy"/>
        <parameter content="const struct sched_param *param"/>
      </prototype>
      <headers>
        <header filename = "sched.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; This function sets both the absolute priority and the scheduling policy
         for a process.
         &lt;br&gt;&lt;br&gt; It assigns the absolute priority value given by &lt;VAR&gt;param&lt;/VAR&gt; and the
         scheduling policy &lt;VAR&gt;policy&lt;/VAR&gt; to the process with Process ID &lt;VAR&gt;pid&lt;/VAR&gt;,
         or the calling process if &lt;VAR&gt;pid&lt;/VAR&gt; is zero.  If &lt;VAR&gt;policy&lt;/VAR&gt; is
         negative, &lt;CODE&gt;sched_setscheduler&lt;/CODE&gt; keeps the existing scheduling policy.
         &lt;br&gt;&lt;br&gt; The following macros represent the valid values for &lt;VAR&gt;policy&lt;/VAR&gt;:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;SCHED_OTHER&lt;/CODE&gt;
&lt;DD&gt;
         Traditional Scheduling
         &lt;DT&gt;&lt;CODE&gt;SCHED_FIFO&lt;/CODE&gt;
&lt;DD&gt;
         First In First Out
         &lt;LI&gt; SCHED_RR
         Round Robin

         &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt; On success, the return value is &lt;CODE&gt;0&lt;/CODE&gt;.  Otherwise, it is &lt;CODE&gt;-1&lt;/CODE&gt;
         and &lt;CODE&gt;ERRNO&lt;/CODE&gt; is set accordingly.  The &lt;CODE&gt;errno&lt;/CODE&gt; values specific
         to this function are:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;LI&gt; EPERM
         &lt;OL&gt;
         &lt;LI&gt;
         The calling process does not have &lt;CODE&gt;CAP_SYS_NICE&lt;/CODE&gt; permission and
         &lt;VAR&gt;policy&lt;/VAR&gt; is not &lt;CODE&gt;SCHED_OTHER&lt;/CODE&gt; (or it's negative and the
         existing policy is not &lt;CODE&gt;SCHED_OTHER&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         The calling process does not have &lt;CODE&gt;CAP_SYS_NICE&lt;/CODE&gt; permission and its
         owner is not the target process' owner.  I.e., the effective uid of the
         calling process is neither the effective nor the real uid of process
         &lt;VAR&gt;pid&lt;/VAR&gt;.
         &lt;/OL&gt;
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ESRCH
         There is no process with pid &lt;VAR&gt;pid&lt;/VAR&gt; and &lt;VAR&gt;pid&lt;/VAR&gt; is not zero.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         &lt;OL&gt;
         &lt;LI&gt;
         &lt;VAR&gt;policy&lt;/VAR&gt; does not identify an existing scheduling policy.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         The absolute priority value identified by *&lt;VAR&gt;param&lt;/VAR&gt; is outside the
         valid range for the scheduling policy &lt;VAR&gt;policy&lt;/VAR&gt; (or the existing
         scheduling policy if &lt;VAR&gt;policy&lt;/VAR&gt; is negative) or &lt;VAR&gt;param&lt;/VAR&gt; is
         null.  &lt;CODE&gt;sched_get_priority_max&lt;/CODE&gt; and &lt;CODE&gt;sched_get_priority_min&lt;/CODE&gt;
         tell you what the valid range is.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt;
         &lt;VAR&gt;pid&lt;/VAR&gt; is negative.
         &lt;/OL&gt;

         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-sched_getscheduler" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="pid_t pid"/>
      </prototype>
      <headers>
        <header filename = "sched.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; This function returns the scheduling policy assigned to the process with
         Process ID (pid) &lt;VAR&gt;pid&lt;/VAR&gt;, or the calling process if &lt;VAR&gt;pid&lt;/VAR&gt; is zero.
         &lt;br&gt;&lt;br&gt; The return value is the scheduling policy.  See
         &lt;CODE&gt;sched_setscheduler&lt;/CODE&gt; for the possible values.
         &lt;br&gt;&lt;br&gt; If the function fails, the return value is instead &lt;CODE&gt;-1&lt;/CODE&gt; and
         &lt;CODE&gt;errno&lt;/CODE&gt; is set accordingly.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;errno&lt;/CODE&gt; values specific to this function are:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;ESRCH&lt;/CODE&gt;
&lt;DD&gt;
         There is no process with pid &lt;VAR&gt;pid&lt;/VAR&gt; and it is not zero.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         &lt;VAR&gt;pid&lt;/VAR&gt; is negative.
         &lt;br&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; Note that this function is not an exact mate to &lt;CODE&gt;sched_setscheduler&lt;/CODE&gt;
         because while that function sets the scheduling policy and the absolute
         priority, this function gets only the scheduling policy.  To get the
         absolute priority, use &lt;CODE&gt;sched_getparam&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-sched_setparam" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="pid_t pid"/>
        <parameter content="const struct sched_param *param"/>
      </prototype>
      <headers>
        <header filename = "sched.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; This function sets a process' absolute priority.
         &lt;br&gt;&lt;br&gt; It is functionally identical to &lt;CODE&gt;sched_setscheduler&lt;/CODE&gt; with
         &lt;VAR&gt;policy&lt;/VAR&gt; = &lt;CODE&gt;-1&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-sched_getparam" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="pid_t pid"/>
        <parameter content="const struct sched_param *param"/>
      </prototype>
      <headers>
        <header filename = "sched.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; This function returns a process' absolute priority.
         &lt;br&gt;&lt;br&gt; &lt;VAR&gt;pid&lt;/VAR&gt; is the Process ID (pid) of the process whose absolute priority
         you want to know.
         &lt;br&gt;&lt;br&gt; &lt;VAR&gt;param&lt;/VAR&gt; is a pointer to a structure in which the function stores the
         absolute priority of the process.
         &lt;br&gt;&lt;br&gt; On success, the return value is &lt;CODE&gt;0&lt;/CODE&gt;.  Otherwise, it is &lt;CODE&gt;-1&lt;/CODE&gt;
         and &lt;CODE&gt;ERRNO&lt;/CODE&gt; is set accordingly.  The &lt;CODE&gt;errno&lt;/CODE&gt; values specific
         to this function are:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;ESRCH&lt;/CODE&gt;
&lt;DD&gt;
         There is no process with pid &lt;VAR&gt;pid&lt;/VAR&gt; and it is not zero.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         &lt;VAR&gt;pid&lt;/VAR&gt; is negative.
         &lt;br&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-sched_get_priority_min" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int *policy"/>
      </prototype>
      <headers>
        <header filename = "sched.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; This function returns the lowest absolute priority value that is
         allowable for a process with scheduling policy &lt;VAR&gt;policy&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; On Linux, it is 0 for SCHED_OTHER and 1 for everything else.
         &lt;br&gt;&lt;br&gt; On success, the return value is &lt;CODE&gt;0&lt;/CODE&gt;.  Otherwise, it is &lt;CODE&gt;-1&lt;/CODE&gt;
         and &lt;CODE&gt;ERRNO&lt;/CODE&gt; is set accordingly.  The &lt;CODE&gt;errno&lt;/CODE&gt; values specific
         to this function are:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EINVAL&lt;/CODE&gt;
&lt;DD&gt;
         &lt;VAR&gt;policy&lt;/VAR&gt; does not identify an existing scheduling policy.

         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-sched_get_priority_max" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int *policy"/>
      </prototype>
      <headers>
        <header filename = "sched.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; This function returns the highest absolute priority value that is
         allowable for a process that with scheduling policy &lt;VAR&gt;policy&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; On Linux, it is 0 for SCHED_OTHER and 99 for everything else.
         &lt;br&gt;&lt;br&gt; On success, the return value is &lt;CODE&gt;0&lt;/CODE&gt;.  Otherwise, it is &lt;CODE&gt;-1&lt;/CODE&gt;
         and &lt;CODE&gt;ERRNO&lt;/CODE&gt; is set accordingly.  The &lt;CODE&gt;errno&lt;/CODE&gt; values specific
         to this function are:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EINVAL&lt;/CODE&gt;
&lt;DD&gt;
         &lt;VAR&gt;policy&lt;/VAR&gt; does not identify an existing scheduling policy.

         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-sched_rr_get_interval" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="pid_t pid"/>
        <parameter content="struct timespec *interval"/>
      </prototype>
      <headers>
        <header filename = "sched.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; This function returns the length of the quantum (time slice) used with
         the Round Robin scheduling policy, if it is used, for the process with
         Process ID &lt;VAR&gt;pid&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; It returns the length of time as &lt;VAR&gt;interval&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; With a Linux kernel, the round robin time slice is always 150
         microseconds, and &lt;VAR&gt;pid&lt;/VAR&gt; need not even be a real pid.
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; on success and in the pathological case
         that it fails, the return value is &lt;CODE&gt;-1&lt;/CODE&gt; and &lt;CODE&gt;errno&lt;/CODE&gt; is set
         accordingly.  There is nothing specific that can go wrong with this
         function, so there are no specific &lt;CODE&gt;errno&lt;/CODE&gt; values.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-sched_yield" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "sched.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; This function voluntarily gives up the process' claim on the CPU.
         &lt;br&gt;&lt;br&gt; Technically, &lt;CODE&gt;sched_yield&lt;/CODE&gt; causes the calling process to be made
         immediately ready to run (as opposed to running, which is what it was
         before).  This means that if it has absolute priority higher than 0, it
         gets pushed onto the tail of the queue of processes that share its
         absolute priority and are ready to run, and it will run again when its
         turn next arrives.  If its absolute priority is 0, it is more
         complicated, but still has the effect of yielding the CPU to other
         processes.
         &lt;br&gt;&lt;br&gt; If there are no other processes that share the calling process' absolute
         priority, this function doesn't have any effect.
         &lt;br&gt;&lt;br&gt; To the extent that the containing program is oblivious to what other
         processes in the system are doing and how fast it executes, this
         function appears as a no-op.
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; on success and in the pathological case
         that it fails, the return value is &lt;CODE&gt;-1&lt;/CODE&gt; and &lt;CODE&gt;errno&lt;/CODE&gt; is set
         accordingly.  There is nothing specific that can go wrong with this
         function, so there are no specific &lt;CODE&gt;errno&lt;/CODE&gt; values.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-getpriority" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int class"/>
        <parameter content="int id"/>
      </prototype>
      <headers>
        <header filename = "sys/resource.h"/>
      </headers>
        <synopsis>
        Return the nice value of a set of processes; &lt;VAR&gt;class&lt;/VAR&gt; and &lt;VAR&gt;id&lt;/VAR&gt;
         specify which ones (see below).  If the processes specified do not all
         have the same nice value, this returns the lowest value that any of them
         has.
         &lt;br&gt;&lt;br&gt; On success, the return value is &lt;CODE&gt;0&lt;/CODE&gt;.  Otherwise, it is &lt;CODE&gt;-1&lt;/CODE&gt;
         and &lt;CODE&gt;ERRNO&lt;/CODE&gt; is set accordingly.  The &lt;CODE&gt;errno&lt;/CODE&gt; values specific
         to this function are:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;ESRCH&lt;/CODE&gt;
&lt;DD&gt;
         The combination of &lt;VAR&gt;class&lt;/VAR&gt; and &lt;VAR&gt;id&lt;/VAR&gt; does not match any existing
         process.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         The value of &lt;VAR&gt;class&lt;/VAR&gt; is not valid.

         &lt;br&gt;&lt;br&gt; If the return value is &lt;CODE&gt;-1&lt;/CODE&gt;, it could indicate failure, or it could
         be the nice value.  The only way to make certain is to set &lt;CODE&gt;errno =
         0&lt;/CODE&gt; before calling &lt;CODE&gt;getpriority&lt;/CODE&gt;, then use &lt;CODE&gt;errno != 0&lt;/CODE&gt;
         afterward as the criterion for failure.
        </synopsis>
    </function>
  </construct>
  <construct id="function-setpriority" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int class"/>
        <parameter content="int id"/>
        <parameter content="int niceval"/>
      </prototype>
      <headers>
        <header filename = "sys/resource.h"/>
      </headers>
        <synopsis>
        Set the nice value of a set of processes to &lt;VAR&gt;niceval&lt;/VAR&gt;; &lt;VAR&gt;class&lt;/VAR&gt;
         and &lt;VAR&gt;id&lt;/VAR&gt; specify which ones (see below).
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; on success, and &lt;CODE&gt;-1&lt;/CODE&gt; on
         failure.  The following &lt;CODE&gt;errno&lt;/CODE&gt; error condition are possible for
         this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;ESRCH&lt;/CODE&gt;
&lt;DD&gt;
         The combination of &lt;VAR&gt;class&lt;/VAR&gt; and &lt;VAR&gt;id&lt;/VAR&gt; does not match any existing
         process.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         The value of &lt;VAR&gt;class&lt;/VAR&gt; is not valid.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EPERM
         The call would set the nice value of a process which is owned by a different
         user than the calling process (i.e., the target process' real or effective
         uid does not match the calling process' effective uid) and the calling
         process does not have &lt;CODE&gt;CAP_SYS_NICE&lt;/CODE&gt; permission.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EACCES
         The call would lower the process' nice value and the process does not have
         &lt;CODE&gt;CAP_SYS_NICE&lt;/CODE&gt; permission.

         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-nice" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int increment"/>
      </prototype>
      <headers>
        <header filename = "sys/resource.h"/>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        Increment the nice value of the calling process by &lt;VAR&gt;increment&lt;/VAR&gt;.
         The return value is the new nice value on success, and &lt;CODE&gt;-1&lt;/CODE&gt; on
         failure.  In the case of failure, &lt;CODE&gt;errno&lt;/CODE&gt; will be set to the
         same values as for &lt;CODE&gt;setpriority&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt; Here is an equivalent definition of &lt;CODE&gt;nice&lt;/CODE&gt;:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         int&lt;br&gt;
         nice (int increment)&lt;br&gt;
         {&lt;br&gt;
           int result, old = getpriority (PRIO_PROCESS, 0);&lt;br&gt;
           result = setpriority (PRIO_PROCESS, 0, old + increment);&lt;br&gt;
           if (result != -1)&lt;br&gt;
               return old + increment;&lt;br&gt;
           else&lt;br&gt;
               return -1;&lt;br&gt;
         }&lt;br&gt;
         &lt;/pre&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-cpu_set_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="function-sched_getaffinity" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="pid_t pid"/>
        <parameter content="size_t cpusetsize"/>
        <parameter content="cpu_set_t *cpuset"/>
      </prototype>
      <headers>
        <header filename = "sched.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; This functions stores the CPU affinity mask for the process or thread
         with the ID &lt;VAR&gt;pid&lt;/VAR&gt; in the &lt;VAR&gt;cpusetsize&lt;/VAR&gt; bytes long bitmap
         pointed to by &lt;VAR&gt;cpuset&lt;/VAR&gt;.  If successful, the function always
         initializes all bits in the &lt;CODE&gt;cpu_set_t&lt;/CODE&gt; object and returns zero.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;pid&lt;/VAR&gt; does not correspond to a process or thread on the system
         the or the function fails for some other reason, it returns &lt;CODE&gt;-1&lt;/CODE&gt;
         and &lt;CODE&gt;errno&lt;/CODE&gt; is set to represent the error condition.
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;ESRCH&lt;/CODE&gt;
&lt;DD&gt;
         No process or thread with the given ID found.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EFAULT
         The pointer &lt;VAR&gt;cpuset&lt;/VAR&gt; is does not point to a valid object.

         &lt;br&gt;&lt;br&gt; This function is a GNU extension and is declared in &lt;TT&gt;sched.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-sched_setaffinity" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="pid_t pid"/>
        <parameter content="size_t cpusetsize"/>
        <parameter content="const cpu_set_t *cpuset"/>
      </prototype>
      <headers>
        <header filename = "sched.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; This function installs the &lt;VAR&gt;cpusetsize&lt;/VAR&gt; bytes long affinity mask
         pointed to by &lt;VAR&gt;cpuset&lt;/VAR&gt; for the process or thread with the ID &lt;VAR&gt;pid&lt;/VAR&gt;.
         If successful the function returns zero and the scheduler will in future
         take the affinity information into account.
         &lt;br&gt;&lt;br&gt; If the function fails it will return &lt;CODE&gt;-1&lt;/CODE&gt; and &lt;CODE&gt;errno&lt;/CODE&gt; is set
         to the error code:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;ESRCH&lt;/CODE&gt;
&lt;DD&gt;
         No process or thread with the given ID found.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EFAULT
         The pointer &lt;VAR&gt;cpuset&lt;/VAR&gt; is does not point to a valid object.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         The bitset is not valid.  This might mean that the affinity set might
         not leave a processor for the process or thread to run on.

         &lt;br&gt;&lt;br&gt; This function is a GNU extension and is declared in &lt;TT&gt;sched.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getpagesize" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getpagesize&lt;/CODE&gt; function returns the page size of the process.
         This value is fixed for the runtime of the process but can vary in
         different runs of the application.
         &lt;br&gt;&lt;br&gt; The function is declared in &lt;TT&gt;unistd.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-get_phys_pages" type="function">
    <function returntype="long int">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "sys/sysinfo.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;get_phys_pages&lt;/CODE&gt; function returns the total number of pages of
         physical the system has.  To get the amount of memory this number has to
         be multiplied by the page size.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-get_avphys_pages" type="function">
    <function returntype="long int">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "sys/sysinfo.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;get_phys_pages&lt;/CODE&gt; function returns the number of available pages of
         physical the system has.  To get the amount of memory this number has to
         be multiplied by the page size.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-get_nprocs_conf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "sys/sysinfo.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;get_nprocs_conf&lt;/CODE&gt; function returns the number of processors the
         operating system configured.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-get_nprocs" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "sys/sysinfo.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;get_nprocs&lt;/CODE&gt; function returns the number of available processors.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getloadavg" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="double loadavg[]"/>
        <parameter content="int nelem"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        This function gets the 1, 5 and 15 minute load averages of the
         system. The values are placed in &lt;VAR&gt;loadavg&lt;/VAR&gt;.  &lt;CODE&gt;getloadavg&lt;/CODE&gt; will
         place at most &lt;VAR&gt;nelem&lt;/VAR&gt; elements into the array but never more than
         three elements.  The return value is the number of elements written to
         &lt;VAR&gt;loadavg&lt;/VAR&gt;, or -1 on error.
         &lt;br&gt;&lt;br&gt; This function is declared in &lt;TT&gt;stdlib.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-isatty" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int filedes"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        This function returns &lt;CODE&gt;1&lt;/CODE&gt; if &lt;VAR&gt;filedes&lt;/VAR&gt; is a file descriptor
         associated with an open terminal device, and 0 otherwise.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ttyname" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="int filedes"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        If the file descriptor &lt;VAR&gt;filedes&lt;/VAR&gt; is associated with a terminal
         device, the &lt;CODE&gt;ttyname&lt;/CODE&gt; function returns a pointer to a
         statically-allocated, null-terminated string containing the file name of
         the terminal file.  The value is a null pointer if the file descriptor
         isn't associated with a terminal, or the file name cannot be determined.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ttyname_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="char *buf"/>
        <parameter content="size_t len"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;ttyname_r&lt;/CODE&gt; function is similar to the &lt;CODE&gt;ttyname&lt;/CODE&gt; function
         except that it places its result into the user-specified buffer starting
         at &lt;VAR&gt;buf&lt;/VAR&gt; with length &lt;VAR&gt;len&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The normal return value from &lt;CODE&gt;ttyname_r&lt;/CODE&gt; is 0.  Otherwise an
         error number is returned to indicate the error.  The following
         &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;filedes&lt;/VAR&gt; argument is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOTTY
         The &lt;VAR&gt;filedes&lt;/VAR&gt; is not associated with a terminal.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ERANGE
         The buffer length &lt;VAR&gt;len&lt;/VAR&gt; is too small to store the string to be
         returned.

        </synopsis>
    </function>
  </construct>
  <construct id="struct-termios" type="struct">
    <structure>
        <synopsis>
        Structure that records all the I/O attributes of a terminal.  The
         structure includes at least the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="tcflag_t c_iflag">
            <synopsis>
            A bit mask specifying flags for input modes; see Input Modes.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="tcflag_t c_oflag">
            <synopsis>
            A bit mask specifying flags for output modes; see Output Modes.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="tcflag_t c_cflag">
            <synopsis>
            A bit mask specifying flags for control modes; see Control Modes.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="tcflag_t c_lflag">
            <synopsis>
            A bit mask specifying flags for local modes; see Local Modes.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="dtype-tcflag_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="dtype-cc_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="function-tcgetattr" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="struct termios *termios-p"/>
      </prototype>
      <headers>
        <header filename = "termios.h"/>
      </headers>
        <synopsis>
        This function is used to examine the attributes of the terminal
         device with file descriptor &lt;VAR&gt;filedes&lt;/VAR&gt;.  The attributes are returned
         in the structure that &lt;VAR&gt;termios-p&lt;/VAR&gt; points to.
         &lt;br&gt;&lt;br&gt; If successful, &lt;CODE&gt;tcgetattr&lt;/CODE&gt; returns 0.  A return value of -1
         indicates an error.  The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are
         defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;filedes&lt;/VAR&gt; argument is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOTTY
         The &lt;VAR&gt;filedes&lt;/VAR&gt; is not associated with a terminal.

        </synopsis>
    </function>
  </construct>
  <construct id="function-tcsetattr" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="int when"/>
        <parameter content="const struct termios *termios-p"/>
      </prototype>
      <headers>
        <header filename = "termios.h"/>
      </headers>
        <synopsis>
        This function sets the attributes of the terminal device with file
         descriptor &lt;VAR&gt;filedes&lt;/VAR&gt;.  The new attributes are taken from the
         structure that &lt;VAR&gt;termios-p&lt;/VAR&gt; points to.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;when&lt;/VAR&gt; argument specifies how to deal with input and output
         already queued.  It can be one of the following values:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;TCSANOW&lt;/CODE&gt;
&lt;DD&gt;

         Make the change immediately.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;TCSADRAIN&lt;/CODE&gt;
&lt;DD&gt;

         Make the change after waiting until all queued output has been written.
         You should usually use this option when changing parameters that affect
         output.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; TCSAFLUSH

         This is like &lt;CODE&gt;TCSADRAIN&lt;/CODE&gt;, but also discards any queued input.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; TCSASOFT

         This is a flag bit that you can add to any of the above alternatives.
         Its meaning is to inhibit alteration of the state of the terminal
         hardware.  It is a BSD extension; it is only supported on BSD systems
         and the GNU system.
         &lt;br&gt;&lt;br&gt; Using &lt;CODE&gt;TCSASOFT&lt;/CODE&gt; is exactly the same as setting the &lt;CODE&gt;CIGNORE&lt;/CODE&gt;
         bit in the &lt;CODE&gt;c_cflag&lt;/CODE&gt; member of the structure &lt;VAR&gt;termios-p&lt;/VAR&gt; points
         to.  , for a description of &lt;CODE&gt;CIGNORE&lt;/CODE&gt;.

         &lt;br&gt;&lt;br&gt; If this function is called from a background process on its controlling
         terminal, normally all processes in the process group are sent a
         &lt;CODE&gt;SIGTTOU&lt;/CODE&gt; signal, in the same way as if the process were trying to
         write to the terminal.  The exception is if the calling process itself
         is ignoring or blocking &lt;CODE&gt;SIGTTOU&lt;/CODE&gt; signals, in which case the
         operation is performed and no signal is sent.  .
         &lt;br&gt;&lt;br&gt; If successful, &lt;CODE&gt;tcsetattr&lt;/CODE&gt; returns 0.  A return value of
         -1 indicates an error.  The following &lt;CODE&gt;errno&lt;/CODE&gt; error
         conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;LI&gt; EBADF
         The &lt;VAR&gt;filedes&lt;/VAR&gt; argument is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOTTY
         The &lt;VAR&gt;filedes&lt;/VAR&gt; is not associated with a terminal.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         Either the value of the &lt;CODE&gt;when&lt;/CODE&gt; argument is not valid, or there is
         something wrong with the data in the &lt;VAR&gt;termios-p&lt;/VAR&gt; argument.

        </synopsis>
    </function>
  </construct>
  <construct id="function-cfgetospeed" type="function">
    <function returntype="speed_t">
      <prototype>
        <parameter content="const struct termios *termios-p"/>
      </prototype>
      <headers>
        <header filename = "termios.h"/>
      </headers>
        <synopsis>
        This function returns the output line speed stored in the structure
         &lt;CODE&gt;*&lt;VAR&gt;termios-p&lt;/VAR&gt;&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cfgetispeed" type="function">
    <function returntype="speed_t">
      <prototype>
        <parameter content="const struct termios *termios-p"/>
      </prototype>
      <headers>
        <header filename = "termios.h"/>
      </headers>
        <synopsis>
        This function returns the input line speed stored in the structure
         &lt;CODE&gt;*&lt;VAR&gt;termios-p&lt;/VAR&gt;&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cfsetospeed" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="struct termios *termios-p"/>
        <parameter content="speed_t speed"/>
      </prototype>
      <headers>
        <header filename = "termios.h"/>
      </headers>
        <synopsis>
        This function stores &lt;VAR&gt;speed&lt;/VAR&gt; in &lt;CODE&gt;*&lt;VAR&gt;termios-p&lt;/VAR&gt;&lt;/CODE&gt; as the output
         speed.  The normal return value is 0; a value of -1
         indicates an error.  If &lt;VAR&gt;speed&lt;/VAR&gt; is not a speed, &lt;CODE&gt;cfsetospeed&lt;/CODE&gt;
         returns -1.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cfsetispeed" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="struct termios *termios-p"/>
        <parameter content="speed_t speed"/>
      </prototype>
      <headers>
        <header filename = "termios.h"/>
      </headers>
        <synopsis>
        This function stores &lt;VAR&gt;speed&lt;/VAR&gt; in &lt;CODE&gt;*&lt;VAR&gt;termios-p&lt;/VAR&gt;&lt;/CODE&gt; as the input
         speed.  The normal return value is 0; a value of -1
         indicates an error.  If &lt;VAR&gt;speed&lt;/VAR&gt; is not a speed, &lt;CODE&gt;cfsetospeed&lt;/CODE&gt;
         returns -1.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cfsetspeed" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="struct termios *termios-p"/>
        <parameter content="speed_t speed"/>
      </prototype>
      <headers>
        <header filename = "termios.h"/>
      </headers>
        <synopsis>
        This function stores &lt;VAR&gt;speed&lt;/VAR&gt; in &lt;CODE&gt;*&lt;VAR&gt;termios-p&lt;/VAR&gt;&lt;/CODE&gt; as both the
         input and output speeds.  The normal return value is 0; a value
         of -1 indicates an error.  If &lt;VAR&gt;speed&lt;/VAR&gt; is not a speed,
         &lt;CODE&gt;cfsetspeed&lt;/CODE&gt; returns -1.  This function is an extension in
         4.4 BSD.
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-speed_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="function-cfmakeraw" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="struct termios *termios-p"/>
      </prototype>
      <headers>
        <header filename = "termios.h"/>
      </headers>
        <synopsis>
        This function provides an easy way to set up &lt;CODE&gt;*&lt;VAR&gt;termios-p&lt;/VAR&gt;&lt;/CODE&gt; for
         what has traditionally been called ``raw mode'' in BSD.  This uses
         noncanonical input, and turns off most processing to give an unmodified
         channel to the terminal.
         &lt;br&gt;&lt;br&gt; It does exactly this:
         &lt;pre&gt;&lt;br&gt;
           &lt;VAR&gt;termios-p&lt;/VAR&gt;-&gt;c_iflag &amp;= ~(IGNBRK|BRKINT|PARMRK|ISTRIP&lt;br&gt;
                                         |INLCR|IGNCR|ICRNL|IXON);&lt;br&gt;
           &lt;VAR&gt;termios-p&lt;/VAR&gt;-&gt;c_oflag &amp;= ~OPOST;&lt;br&gt;
           &lt;VAR&gt;termios-p&lt;/VAR&gt;-&gt;c_lflag &amp;= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);&lt;br&gt;
           &lt;VAR&gt;termios-p&lt;/VAR&gt;-&gt;c_cflag &amp;= ~(CSIZE|PARENB);&lt;br&gt;
           &lt;VAR&gt;termios-p&lt;/VAR&gt;-&gt;c_cflag |= CS8;&lt;br&gt;
         &lt;/pre&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="struct-sgttyb" type="struct">
    <structure>
        <synopsis>
        This structure is an input or output parameter list for &lt;CODE&gt;gtty&lt;/CODE&gt; and
         &lt;CODE&gt;stty&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="char sg_ispeed">
            <synopsis>
            Line speed for input
            </synopsis>
        </element>
        <element content="char sg_ospeed">
            <synopsis>
            Line speed for output
            </synopsis>
        </element>
        <element content="char sg_erase">
            <synopsis>
            Erase character
            </synopsis>
        </element>
        <element content="char sg_kill">
            <synopsis>
            Kill character
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-gtty" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="struct sgttyb *attributes"/>
      </prototype>
      <headers>
        <header filename = "termios.h"/>
        <header filename = "sgtty.h"/>
      </headers>
        <synopsis>
        This function gets the attributes of a terminal.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;gtty&lt;/CODE&gt; sets *&lt;VAR&gt;attributes&lt;/VAR&gt; to describe the terminal attributes
         of the terminal which is open with file descriptor &lt;VAR&gt;filedes&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-stty" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="struct sgttyb * attributes"/>
      </prototype>
      <headers>
        <header filename = "sgtty.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; This function sets the attributes of a terminal.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;stty&lt;/CODE&gt; sets the terminal attributes of the terminal which is open with
         file descriptor &lt;VAR&gt;filedes&lt;/VAR&gt; to those described by *&lt;VAR&gt;filedes&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-tcsendbreak" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="int duration"/>
      </prototype>
      <headers>
        <header filename = "termios.h"/>
      </headers>
        <synopsis>
        This function generates a break condition by transmitting a stream of
         zero bits on the terminal associated with the file descriptor
         &lt;VAR&gt;filedes&lt;/VAR&gt;.  The duration of the break is controlled by the
         &lt;VAR&gt;duration&lt;/VAR&gt; argument.  If zero, the duration is between 0.25 and 0.5
         seconds.  The meaning of a nonzero value depends on the operating system.
         &lt;br&gt;&lt;br&gt; This function does nothing if the terminal is not an asynchronous serial
         data port.
         &lt;br&gt;&lt;br&gt; The return value is normally zero.  In the event of an error, a value
         of -1 is returned.  The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions
         are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;filedes&lt;/VAR&gt; is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOTTY
         The &lt;VAR&gt;filedes&lt;/VAR&gt; is not associated with a terminal device.

        </synopsis>
    </function>
  </construct>
  <construct id="function-tcdrain" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int filedes"/>
      </prototype>
      <headers>
        <header filename = "termios.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;tcdrain&lt;/CODE&gt; function waits until all queued
         output to the terminal &lt;VAR&gt;filedes&lt;/VAR&gt; has been transmitted.
         &lt;br&gt;&lt;br&gt; This function is a cancellation point in multi-threaded programs.  This
         is a problem if the thread allocates some resources (like memory, file
         descriptors, semaphores or whatever) at the time &lt;CODE&gt;tcdrain&lt;/CODE&gt; is
         called.  If the thread gets canceled these resources stay allocated
         until the program ends.  To avoid this calls to &lt;CODE&gt;tcdrain&lt;/CODE&gt; should be
         protected using cancellation handlers.
         &lt;br&gt;&lt;br&gt; The return value is normally zero.  In the event of an error, a value
         of -1 is returned.  The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions
         are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;filedes&lt;/VAR&gt; is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOTTY
         The &lt;VAR&gt;filedes&lt;/VAR&gt; is not associated with a terminal device.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINTR
         The operation was interrupted by delivery of a signal.
         .

        </synopsis>
    </function>
  </construct>
  <construct id="function-tcflush" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="int queue"/>
      </prototype>
      <headers>
        <header filename = "termios.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;tcflush&lt;/CODE&gt; function is used to clear the input and/or output
         queues associated with the terminal file &lt;VAR&gt;filedes&lt;/VAR&gt;.  The &lt;VAR&gt;queue&lt;/VAR&gt;
         argument specifies which queue(s) to clear, and can be one of the
         following values:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;


         &lt;DT&gt;&lt;CODE&gt;TCIFLUSH&lt;/CODE&gt;
&lt;DD&gt;
         &lt;br&gt;&lt;br&gt; Clear any input data received, but not yet read.
         &lt;br&gt;&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;TCOFLUSH&lt;/CODE&gt;
&lt;DD&gt;
         &lt;br&gt;&lt;br&gt; Clear any output data written, but not yet transmitted.
         &lt;br&gt;&lt;br&gt;
         &lt;LI&gt; TCIOFLUSH
         &lt;br&gt;&lt;br&gt; Clear both queued input and output.

         &lt;br&gt;&lt;br&gt; The return value is normally zero.  In the event of an error, a value
         of -1 is returned.  The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions
         are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;LI&gt; EBADF
         The &lt;VAR&gt;filedes&lt;/VAR&gt; is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; ENOTTY
         The &lt;VAR&gt;filedes&lt;/VAR&gt; is not associated with a terminal device.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         A bad value was supplied as the &lt;VAR&gt;queue&lt;/VAR&gt; argument.

         &lt;br&gt;&lt;br&gt; It is unfortunate that this function is named &lt;CODE&gt;tcflush&lt;/CODE&gt;, because
         the term ``flush'' is normally used for quite another operation---waiting
         until all output is transmitted---and using it for discarding input or
         output would be confusing.  Unfortunately, the name &lt;CODE&gt;tcflush&lt;/CODE&gt; comes
         from POSIX and we cannot change it.
        </synopsis>
    </function>
  </construct>
  <construct id="function-tcflow" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="int action"/>
      </prototype>
      <headers>
        <header filename = "termios.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;tcflow&lt;/CODE&gt; function is used to perform operations relating to
         XON/XOFF flow control on the terminal file specified by &lt;VAR&gt;filedes&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;action&lt;/VAR&gt; argument specifies what operation to perform, and can
         be one of the following values:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;


         &lt;DT&gt;&lt;CODE&gt;TCOOFF&lt;/CODE&gt;
&lt;DD&gt;
         Suspend transmission of output.
         &lt;br&gt;&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;TCOON&lt;/CODE&gt;
&lt;DD&gt;
         Restart transmission of output.
         &lt;br&gt;&lt;br&gt;
         &lt;LI&gt; TCIOFF
         Transmit a STOP character.
         &lt;br&gt;&lt;br&gt;
         &lt;LI&gt; TCION
         Transmit a START character.

         &lt;br&gt;&lt;br&gt; For more information about the STOP and START characters, see Special
         Characters.
         &lt;br&gt;&lt;br&gt; The return value is normally zero.  In the event of an error, a value
         of -1 is returned.  The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions
         are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;


         &lt;LI&gt; EBADF
         The &lt;VAR&gt;filedes&lt;/VAR&gt; is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt;
         &lt;LI&gt; ENOTTY
         The &lt;VAR&gt;filedes&lt;/VAR&gt; is not associated with a terminal device.
         &lt;br&gt;&lt;br&gt;
         &lt;LI&gt; EINVAL
         A bad value was supplied as the &lt;VAR&gt;action&lt;/VAR&gt; argument.

        </synopsis>
    </function>
  </construct>
  <construct id="function-getpt" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getpt&lt;/CODE&gt; function returns a new file descriptor for the next
         available master pseudo-terminal.  The normal return value from
         &lt;CODE&gt;getpt&lt;/CODE&gt; is a non-negative integer file descriptor.  In the case of
         an error, a value of -1 is returned instead.  The following
         &lt;CODE&gt;errno&lt;/CODE&gt; conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;ENOENT&lt;/CODE&gt;
&lt;DD&gt;
         There are no free master pseudo-terminals available.

         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-grantpt" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int filedes"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;grantpt&lt;/CODE&gt; function changes the ownership and access permission
         of the slave pseudo-terminal device corresponding to the master
         pseudo-terminal device associated with the file descriptor
         &lt;VAR&gt;filedes&lt;/VAR&gt;.  The owner is set from the real user ID of the calling
         process , and the group is set to a special
         group (typically tty) or from the real group ID of the calling
         process.  The access permission is set such that the file is both
         readable and writable by the owner and only writable by the group.
         &lt;br&gt;&lt;br&gt; On some systems this function is implemented by invoking a special
         &lt;CODE&gt;setuid&lt;/CODE&gt; root program. As a
         consequence, installing a signal handler for the &lt;CODE&gt;SIGCHLD&lt;/CODE&gt; signal
          may interfere with a call to
         &lt;CODE&gt;grantpt&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The normal return value from &lt;CODE&gt;grantpt&lt;/CODE&gt; is 0; a value of
         -1 is returned in case of failure.  The following &lt;CODE&gt;errno&lt;/CODE&gt;
         error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;filedes&lt;/VAR&gt; argument is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         The &lt;VAR&gt;filedes&lt;/VAR&gt; argument is not associated with a master pseudo-terminal
         device.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EACCES
         The slave pseudo-terminal device corresponding to the master associated
         with &lt;VAR&gt;filedes&lt;/VAR&gt; could not be accessed.

         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-unlockpt" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int filedes"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;unlockpt&lt;/CODE&gt; function unlocks the slave pseudo-terminal device
         corresponding to the master pseudo-terminal device associated with the
         file descriptor &lt;VAR&gt;filedes&lt;/VAR&gt;.  On many systems, the slave can only be
         opened after unlocking, so portable applications should always call
         &lt;CODE&gt;unlockpt&lt;/CODE&gt; before trying to open the slave.
         &lt;br&gt;&lt;br&gt; The normal return value from &lt;CODE&gt;unlockpt&lt;/CODE&gt; is 0; a value of
         -1 is returned in case of failure.  The following &lt;CODE&gt;errno&lt;/CODE&gt;
         error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;filedes&lt;/VAR&gt; argument is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         The &lt;VAR&gt;filedes&lt;/VAR&gt; argument is not associated with a master pseudo-terminal
         device.

        </synopsis>
    </function>
  </construct>
  <construct id="function-ptsname" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="int filedes"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        If the file descriptor &lt;VAR&gt;filedes&lt;/VAR&gt; is associated with a
         master pseudo-terminal device, the &lt;CODE&gt;ptsname&lt;/CODE&gt; function returns a
         pointer to a statically-allocated, null-terminated string containing the
         file name of the associated slave pseudo-terminal file.  This string
         might be overwritten by subsequent calls to &lt;CODE&gt;ptsname&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ptsname_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="char *buf"/>
        <parameter content="size_t len"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;ptsname_r&lt;/CODE&gt; function is similar to the &lt;CODE&gt;ptsname&lt;/CODE&gt; function
         except that it places its result into the user-specified buffer starting
         at &lt;VAR&gt;buf&lt;/VAR&gt; with length &lt;VAR&gt;len&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-openpty" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int *amaster"/>
        <parameter content="int *aslave"/>
        <parameter content="char *name"/>
        <parameter content="const struct termios *termp"/>
        <parameter content="const struct winsize *winp"/>
      </prototype>
      <headers>
        <header filename = "pty.h"/>
      </headers>
        <synopsis>
        This function allocates and opens a pseudo-terminal pair, returning the
         file descriptor for the master in &lt;VAR&gt;*amaster&lt;/VAR&gt;, and the file
         descriptor for the slave in &lt;VAR&gt;*aslave&lt;/VAR&gt;.  If the argument &lt;VAR&gt;name&lt;/VAR&gt;
         is not a null pointer, the file name of the slave pseudo-terminal
         device is stored in &lt;CODE&gt;*name&lt;/CODE&gt;.  If &lt;VAR&gt;termp&lt;/VAR&gt; is not a null pointer,
         the terminal attributes of the slave are set to the ones specified in
         the structure that &lt;VAR&gt;termp&lt;/VAR&gt; points to .
         Likewise, if the &lt;VAR&gt;winp&lt;/VAR&gt; is not a null pointer, the screen size of
         the slave is set to the values specified in the structure that
         &lt;VAR&gt;winp&lt;/VAR&gt; points to.
         &lt;br&gt;&lt;br&gt; The normal return value from &lt;CODE&gt;openpty&lt;/CODE&gt; is 0; a value of
         -1 is returned in case of failure.  The following &lt;CODE&gt;errno&lt;/CODE&gt;
         conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;ENOENT&lt;/CODE&gt;
&lt;DD&gt;
         There are no free pseudo-terminal pairs available.

         &lt;br&gt;&lt;br&gt; Warning: Using the &lt;CODE&gt;openpty&lt;/CODE&gt; function with &lt;VAR&gt;name&lt;/VAR&gt; not
         set to &lt;CODE&gt;NULL&lt;/CODE&gt; is very dangerous because it provides no
         protection against overflowing the string &lt;VAR&gt;name&lt;/VAR&gt;.  You should use
         the &lt;CODE&gt;ttyname&lt;/CODE&gt; function on the file descriptor returned in
         &lt;VAR&gt;*slave&lt;/VAR&gt; to find out the file name of the slave pseudo-terminal
         device instead.
        </synopsis>
    </function>
  </construct>
  <construct id="function-forkpty" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int *amaster"/>
        <parameter content="char *name"/>
        <parameter content="const struct termios *termp"/>
        <parameter content="const struct winsize *winp"/>
      </prototype>
      <headers>
        <header filename = "pty.h"/>
      </headers>
        <synopsis>
        This function is similar to the &lt;CODE&gt;openpty&lt;/CODE&gt; function, but in
         addition, forks a new process  and makes the
         newly opened slave pseudo-terminal device the controlling terminal
          for the child process.
         &lt;br&gt;&lt;br&gt; If the operation is successful, there are then both parent and child
         processes and both see &lt;CODE&gt;forkpty&lt;/CODE&gt; return, but with different values:
         it returns a value of 0 in the child process and returns the child's
         process ID in the parent process.
         &lt;br&gt;&lt;br&gt; If the allocation of a pseudo-terminal pair or the process creation
         failed, &lt;CODE&gt;forkpty&lt;/CODE&gt; returns a value of -1 in the parent
         process.
         &lt;br&gt;&lt;br&gt; Warning: The &lt;CODE&gt;forkpty&lt;/CODE&gt; function has the same problems with
         respect to the &lt;VAR&gt;name&lt;/VAR&gt; argument as &lt;CODE&gt;openpty&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-openlog" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="const char *ident"/>
        <parameter content="int option"/>
        <parameter content="int facility"/>
      </prototype>
      <headers>
        <header filename = "syslog.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; &lt;CODE&gt;openlog&lt;/CODE&gt; opens or reopens a connection to Syslog in preparation
         for submitting messages.
         &lt;br&gt;&lt;br&gt; &lt;VAR&gt;ident&lt;/VAR&gt; is an arbitrary identification string which future
         &lt;CODE&gt;syslog&lt;/CODE&gt; invocations will prefix to each message.  This is intended
         to identify the source of the message, and people conventionally set it
         to the name of the program that will submit the messages.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;ident&lt;/VAR&gt; is NULL, or if &lt;CODE&gt;openlog&lt;/CODE&gt; is not called, the default
         identification string used in Syslog messages will be the program name,
         taken from argv[0].
         &lt;br&gt;&lt;br&gt; Please note that the string pointer &lt;VAR&gt;ident&lt;/VAR&gt; will be retained
         internally by the Syslog routines.  You must not free the memory that
         &lt;VAR&gt;ident&lt;/VAR&gt; points to.  It is also dangerous to pass a reference to an
         automatic variable since leaving the scope would mean ending the
         lifetime of the variable.  If you want to change the &lt;VAR&gt;ident&lt;/VAR&gt; string,
         you must call &lt;CODE&gt;openlog&lt;/CODE&gt; again; overwriting the string pointed to by
         &lt;VAR&gt;ident&lt;/VAR&gt; is not thread-safe.
         &lt;br&gt;&lt;br&gt; You can cause the Syslog routines to drop the reference to &lt;VAR&gt;ident&lt;/VAR&gt; and
         go back to the default string (the program name taken from argv[0]), by
         calling &lt;CODE&gt;closelog&lt;/CODE&gt;: .
         &lt;br&gt;&lt;br&gt; In particular, if you are writing code for a shared library that might get
         loaded and then unloaded (e.g. a PAM module), and you use &lt;CODE&gt;openlog&lt;/CODE&gt;,
         you must call &lt;CODE&gt;closelog&lt;/CODE&gt; before any point where your library might
         get unloaded, as in this example:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         #include &lt;syslog.h&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; void&lt;br&gt;
         shared_library_function (void)&lt;br&gt;
         {&lt;br&gt;
           openlog ("mylibrary", option, priority);&lt;br&gt;
         &lt;br&gt;&lt;br&gt;   syslog (LOG_INFO, "shared library has been invoked");&lt;br&gt;
         &lt;br&gt;&lt;br&gt;   closelog ();&lt;br&gt;
         }&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; Without the call to &lt;CODE&gt;closelog&lt;/CODE&gt;, future invocations of &lt;CODE&gt;syslog&lt;/CODE&gt;
         by the program using the shared library may crash, if the library gets
         unloaded and the memory containing the string &lt;CODE&gt;"mylibrary"&lt;/CODE&gt; becomes
         unmapped.  This is a limitation of the BSD syslog interface.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;openlog&lt;/CODE&gt; may or may not open the &lt;TT&gt;/dev/log&lt;/TT&gt; socket, depending
         on &lt;VAR&gt;option&lt;/VAR&gt;.  If it does, it tries to open it and connect it as a
         stream socket.  If that doesn't work, it tries to open it and connect it
         as a datagram socket.  The socket has the ``Close on Exec'' attribute,
         so the kernel will close it if the process performs an exec.
         &lt;br&gt;&lt;br&gt; You don't have to use &lt;CODE&gt;openlog&lt;/CODE&gt;.  If you call &lt;CODE&gt;syslog&lt;/CODE&gt; without
         having called &lt;CODE&gt;openlog&lt;/CODE&gt;, &lt;CODE&gt;syslog&lt;/CODE&gt; just opens the connection
         implicitly and uses defaults for the information in &lt;VAR&gt;ident&lt;/VAR&gt; and
         &lt;VAR&gt;options&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; &lt;VAR&gt;options&lt;/VAR&gt; is a bit string, with the bits as defined by the following
         single bit masks:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;LOG_PERROR&lt;/CODE&gt;
&lt;DD&gt;
         If on, &lt;CODE&gt;openlog&lt;/CODE&gt; sets up the connection so that any &lt;CODE&gt;syslog&lt;/CODE&gt;
         on this connection writes its message to the calling process' Standard
         Error stream in addition to submitting it to Syslog.  If off, &lt;CODE&gt;syslog&lt;/CODE&gt;
         does not write the message to Standard Error.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; LOG_CONS
         If on, &lt;CODE&gt;openlog&lt;/CODE&gt; sets up the connection so that a &lt;CODE&gt;syslog&lt;/CODE&gt; on
         this connection that fails to submit a message to Syslog writes the
         message instead to system console.  If off, &lt;CODE&gt;syslog&lt;/CODE&gt; does not write
         to the system console (but of course Syslog may write messages it
         receives to the console).
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; LOG_PID
         When on, &lt;CODE&gt;openlog&lt;/CODE&gt; sets up the connection so that a &lt;CODE&gt;syslog&lt;/CODE&gt;
         on this connection inserts the calling process' Process ID (PID) into
         the message.  When off, &lt;CODE&gt;openlog&lt;/CODE&gt; does not insert the PID.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; LOG_NDELAY
         When on, &lt;CODE&gt;openlog&lt;/CODE&gt; opens and connects the &lt;TT&gt;/dev/log&lt;/TT&gt; socket.
         When off, a future &lt;CODE&gt;syslog&lt;/CODE&gt; call must open and connect the socket.
         &lt;br&gt;&lt;br&gt; Portability note:  In early systems, the sense of this bit was
         exactly the opposite.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; LOG_ODELAY
         This bit does nothing.  It exists for backward compatibility.
         &lt;br&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; If any other bit in &lt;VAR&gt;options&lt;/VAR&gt; is on, the result is undefined.
         &lt;br&gt;&lt;br&gt; &lt;VAR&gt;facility&lt;/VAR&gt; is the default facility code for this connection.  A
         &lt;CODE&gt;syslog&lt;/CODE&gt; on this connection that specifies default facility causes
         this facility to be associated with the message.  See &lt;CODE&gt;syslog&lt;/CODE&gt; for
         possible values.  A value of zero means the default default, which is
         &lt;CODE&gt;LOG_USER&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; If a Syslog connection is already open when you call &lt;CODE&gt;openlog&lt;/CODE&gt;,
         &lt;CODE&gt;openlog&lt;/CODE&gt; ``reopens'' the connection.  Reopening is like opening
         except that if you specify zero for the default facility code, the
         default facility code simply remains unchanged and if you specify
         LOG_NDELAY and the socket is already open and connected, &lt;CODE&gt;openlog&lt;/CODE&gt;
         just leaves it that way.
         &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-syslog" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="int facility_priority"/>
        <parameter content="char *format"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "syslog.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; &lt;CODE&gt;syslog&lt;/CODE&gt; submits a message to the Syslog facility.  It does this by
         writing to the Unix domain socket &lt;CODE&gt;/dev/log&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;syslog&lt;/CODE&gt; submits the message with the facility and priority indicated
         by &lt;VAR&gt;facility_priority&lt;/VAR&gt;.  The macro &lt;CODE&gt;LOG_MAKEPRI&lt;/CODE&gt; generates a
         facility/priority from a facility and a priority, as in the following
         example:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         LOG_MAKEPRI(LOG_USER, LOG_WARNING)&lt;br&gt;
         &lt;/pre&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; The possible values for the facility code are (macros):&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt; &lt;DL&gt;
&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;LOG_USER&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         A miscellaneous user process&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;LOG_MAIL&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         Mail&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;LOG_DAEMON&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         A miscellaneous system daemon&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;LOG_AUTH&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         Security (authorization)&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;LOG_SYSLOG&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         Syslog&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;LOG_LPR&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         Central printer&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;LOG_NEWS&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         Network news (e.g. Usenet)&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;LOG_UUCP&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         UUCP&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;LOG_CRON&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         Cron and At&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;LOG_AUTHPRIV&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         Private security (authorization)&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;LOG_FTP&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         Ftp server&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;LOG_LOCAL0&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         Locally defined&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;LOG_LOCAL1&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         Locally defined&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;LOG_LOCAL2&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         Locally defined&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;LOG_LOCAL3&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         Locally defined&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;LOG_LOCAL4&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         Locally defined&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;LOG_LOCAL5&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         Locally defined&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;LOG_LOCAL6&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         Locally defined&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;LOG_LOCAL7&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         Locally defined&lt;br&gt;
         &lt;/DL&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; Results are undefined if the facility code is anything else.&lt;br&gt;
         &lt;br&gt;&lt;br&gt; NB: &lt;CODE&gt;syslog&lt;/CODE&gt; recognizes one other facility code: that of&lt;br&gt;
         the kernel.  But you can't specify that facility code with these&lt;br&gt;
         functions.  If you try, it looks the same to &lt;CODE&gt;syslog&lt;/CODE&gt; as if you are&lt;br&gt;
         requesting the default facility.  But you wouldn't want to anyway,&lt;br&gt;
         because any program that uses the GNU C library is not the kernel.&lt;br&gt;
         &lt;br&gt;&lt;br&gt; You can use just a priority code as &lt;VAR&gt;facility_priority&lt;/VAR&gt;.  In that&lt;br&gt;
         case, &lt;CODE&gt;syslog&lt;/CODE&gt; assumes the default facility established when the&lt;br&gt;
         Syslog connection was opened.  .&lt;br&gt;
         &lt;br&gt;&lt;br&gt; The possible values for the priority code are (macros):&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;
&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;LOG_EMERG&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         The message says the system is unusable.&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;LOG_ALERT&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         Action on the message must be taken immediately.&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;LOG_CRIT&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         The message states a critical condition.&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;LOG_ERR&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         The message describes an error.&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;LOG_WARNING&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         The message is a warning.&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;LOG_NOTICE&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         The message describes a normal but important event.&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;LOG_INFO&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         The message is purely informational.&lt;br&gt;
         &lt;DT&gt;&lt;CODE&gt;LOG_DEBUG&lt;br&gt;&lt;/CODE&gt;
&lt;DD&gt;
         The message is only for debugging purposes.&lt;br&gt;
         &lt;/DL&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; Results are undefined if the priority code is anything else.&lt;br&gt;
         &lt;br&gt;&lt;br&gt; If the process does not presently have a Syslog connection open (i.e.,&lt;br&gt;
         it did not call &lt;CODE&gt;openlog&lt;/CODE&gt;), &lt;CODE&gt;syslog&lt;/CODE&gt; implicitly opens the&lt;br&gt;
         connection the same as &lt;CODE&gt;openlog&lt;/CODE&gt; would, with the following defaults&lt;br&gt;
         for information that would otherwise be included in an &lt;CODE&gt;openlog&lt;/CODE&gt;&lt;br&gt;
         call: The default identification string is the program name.  The&lt;br&gt;
         default default facility is &lt;CODE&gt;LOG_USER&lt;/CODE&gt;.  The default for all the&lt;br&gt;
         connection options in &lt;VAR&gt;options&lt;/VAR&gt; is as if those bits were off.&lt;br&gt;
         &lt;CODE&gt;syslog&lt;/CODE&gt; leaves the Syslog connection open.&lt;br&gt;
         &lt;br&gt;&lt;br&gt; If the &lt;TT&gt;dev/log&lt;/TT&gt; socket is not open and connected, &lt;CODE&gt;syslog&lt;/CODE&gt;&lt;br&gt;
         opens and connects it, the same as &lt;CODE&gt;openlog&lt;/CODE&gt; with the&lt;br&gt;
         &lt;CODE&gt;LOG_NDELAY&lt;/CODE&gt; option would.&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;syslog&lt;/CODE&gt; leaves &lt;TT&gt;/dev/log&lt;/TT&gt; open and connected unless its attempt&lt;br&gt;
         to send the message failed, in which case &lt;CODE&gt;syslog&lt;/CODE&gt; closes it (with the&lt;br&gt;
         hope that a future implicit open will restore the Syslog connection to a&lt;br&gt;
         usable state).&lt;br&gt;
         &lt;br&gt;&lt;br&gt; Example:&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; #include &lt;syslog.h&gt;&lt;br&gt;
         syslog (LOG_MAKEPRI(LOG_LOCAL1, LOG_ERROR),&lt;br&gt;
                 "Unable to make network connection to %s.  Error=%m", host);&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-vsyslog" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="int facility_priority"/>
        <parameter content="char *format"/>
        <parameter content="va_list arglist"/>
      </prototype>
      <headers>
        <header filename = "syslog.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; This is functionally identical to &lt;CODE&gt;syslog&lt;/CODE&gt;, with the BSD style variable
         length argument.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-closelog" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "syslog.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; &lt;CODE&gt;closelog&lt;/CODE&gt; closes the current Syslog connection, if there is one.
         This includes closing the &lt;TT&gt;dev/log&lt;/TT&gt; socket, if it is open.
         &lt;CODE&gt;closelog&lt;/CODE&gt; also sets the identification string for Syslog messages
         back to the default, if &lt;CODE&gt;openlog&lt;/CODE&gt; was called with a non-NULL argument
         to &lt;VAR&gt;ident&lt;/VAR&gt;.  The default identification string is the program name
         taken from argv[0].
         &lt;br&gt;&lt;br&gt; If you are writing shared library code that uses &lt;CODE&gt;openlog&lt;/CODE&gt; to
         generate custom syslog output, you should use &lt;CODE&gt;closelog&lt;/CODE&gt; to drop the
         GNU C library's internal reference to the &lt;VAR&gt;ident&lt;/VAR&gt; pointer when you are
         done.  Please read the section on &lt;CODE&gt;openlog&lt;/CODE&gt; for more information:
         .
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;closelog&lt;/CODE&gt; does not flush any buffers.  You do not have to call
         &lt;CODE&gt;closelog&lt;/CODE&gt; before re-opening a Syslog connection with &lt;CODE&gt;initlog&lt;/CODE&gt;.
         Syslog connections are automatically closed on exec or exit.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-setlogmask" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int mask"/>
      </prototype>
      <headers>
        <header filename = "syslog.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; &lt;CODE&gt;setlogmask&lt;/CODE&gt; sets a mask (the ``logmask'') that determines which
         future &lt;CODE&gt;syslog&lt;/CODE&gt; calls shall be ignored.  If a program has not
         called &lt;CODE&gt;setlogmask&lt;/CODE&gt;, &lt;CODE&gt;syslog&lt;/CODE&gt; doesn't ignore any calls.  You
         can use &lt;CODE&gt;setlogmask&lt;/CODE&gt; to specify that messages of particular
         priorities shall be ignored in the future.
         &lt;br&gt;&lt;br&gt; A &lt;CODE&gt;setlogmask&lt;/CODE&gt; call overrides any previous &lt;CODE&gt;setlogmask&lt;/CODE&gt; call.
         &lt;br&gt;&lt;br&gt; Note that the logmask exists entirely independently of opening and
         closing of Syslog connections.
         &lt;br&gt;&lt;br&gt; Setting the logmask has a similar effect to, but is not the same as,
         configuring Syslog.  The Syslog configuration may cause Syslog to
         discard certain messages it receives, but the logmask causes certain
         messages never to get submitted to Syslog in the first place.
         &lt;br&gt;&lt;br&gt; &lt;VAR&gt;mask&lt;/VAR&gt; is a bit string with one bit corresponding to each of the
         possible message priorities.  If the bit is on, &lt;CODE&gt;syslog&lt;/CODE&gt; handles
         messages of that priority normally.  If it is off, &lt;CODE&gt;syslog&lt;/CODE&gt;
         discards messages of that priority.  Use the message priority macros
         described in syslog; vsyslog and the &lt;CODE&gt;LOG_MASK&lt;/CODE&gt; to construct
         an appropriate &lt;VAR&gt;mask&lt;/VAR&gt; value, as in this example:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         LOG_MASK(LOG_EMERG) | LOG_MASK(LOG_ERROR)&lt;br&gt;
         &lt;/pre&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; or&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         ~(LOG_MASK(LOG_INFO))&lt;br&gt;
         &lt;/pre&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; There is also a &lt;CODE&gt;LOG_UPTO&lt;/CODE&gt; macro, which generates a mask with the bits&lt;br&gt;
         on for a certain priority and all priorities above it:&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         LOG_UPTO(LOG_ERROR)&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; The unfortunate naming of the macro is due to the fact that internally,
         higher numbers are used for lower message priorities.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-getsubopt" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="char **optionp"/>
        <parameter content="const char* const *tokens"/>
        <parameter content="char **valuep"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;optionp&lt;/VAR&gt; parameter must be a pointer to a variable containing
         the address of the string to process.  When the function returns the
         reference is updated to point to the next suboption or to the
         terminating &lt;samp&gt;\0&lt;/samp&gt; character if there is no more suboption available.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;tokens&lt;/VAR&gt; parameter references an array of strings containing the
         known suboptions.  All strings must be &lt;samp&gt;\0&lt;/samp&gt; terminated and to mark
         the end a null pointer must be stored.  When &lt;CODE&gt;getsubopt&lt;/CODE&gt; finds a
         possible legal suboption it compares it with all strings available in
         the &lt;VAR&gt;tokens&lt;/VAR&gt; array and returns the index in the string as the
         indicator.
         &lt;br&gt;&lt;br&gt; In case the suboption has an associated value introduced by a &lt;samp&gt;=&lt;/samp&gt;
         character, a pointer to the value is returned in &lt;VAR&gt;valuep&lt;/VAR&gt;.  The
         string is &lt;samp&gt;\0&lt;/samp&gt; terminated.  If no argument is available
         &lt;VAR&gt;valuep&lt;/VAR&gt; is set to the null pointer.  By doing this the caller can
         check whether a necessary value is given or whether no unexpected value
         is present.
         &lt;br&gt;&lt;br&gt; In case the next suboption in the string is not mentioned in the
         &lt;VAR&gt;tokens&lt;/VAR&gt; array the starting address of the suboption including a
         possible value is returned in &lt;VAR&gt;valuep&lt;/VAR&gt; and the return value of the
         function is &lt;samp&gt;-1&lt;/samp&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getenv" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="const char *name"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        This function returns a string that is the value of the environment
         variable &lt;VAR&gt;name&lt;/VAR&gt;.  You must not modify this string.  In some non-Unix
         systems not using the GNU library, it might be overwritten by subsequent
         calls to &lt;CODE&gt;getenv&lt;/CODE&gt; (but not by any other library function).  If the
         environment variable &lt;VAR&gt;name&lt;/VAR&gt; is not defined, the value is a null
         pointer.
        </synopsis>
    </function>
  </construct>
  <construct id="function-putenv" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="char *string"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;putenv&lt;/CODE&gt; function adds or removes definitions from the environment.
         If the &lt;VAR&gt;string&lt;/VAR&gt; is of the form &lt;samp&gt;&lt;VAR&gt;name&lt;/VAR&gt;=&lt;VAR&gt;value&lt;/VAR&gt;&lt;/samp&gt;, the
         definition is added to the environment.  Otherwise, the &lt;VAR&gt;string&lt;/VAR&gt; is
         interpreted as the name of an environment variable, and any definition
         for this variable in the environment is removed.
         &lt;br&gt;&lt;br&gt; The difference to the &lt;CODE&gt;setenv&lt;/CODE&gt; function is that the exact string
         given as the parameter &lt;VAR&gt;string&lt;/VAR&gt; is put into the environment.  If the
         user should change the string after the &lt;CODE&gt;putenv&lt;/CODE&gt; call this will
         reflect in automatically in the environment.  This also requires that
         &lt;VAR&gt;string&lt;/VAR&gt; is no automatic variable which scope is left before the
         variable is removed from the environment.  The same applies of course to
         dynamically allocated variables which are freed later.
         &lt;br&gt;&lt;br&gt; This function is part of the extended Unix interface.  Since it was also
         available in old SVID libraries you should define either
         &lt;VAR&gt;_XOPEN_SOURCE&lt;/VAR&gt; or &lt;VAR&gt;_SVID_SOURCE&lt;/VAR&gt; before including any header.
        </synopsis>
    </function>
  </construct>
  <construct id="function-setenv" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *name"/>
        <parameter content="const char *value"/>
        <parameter content="int replace"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;setenv&lt;/CODE&gt; function can be used to add a new definition to the
         environment.  The entry with the name &lt;VAR&gt;name&lt;/VAR&gt; is replaced by the
         value &lt;samp&gt;&lt;VAR&gt;name&lt;/VAR&gt;=&lt;VAR&gt;value&lt;/VAR&gt;&lt;/samp&gt;.  Please note that this is also true
         if &lt;VAR&gt;value&lt;/VAR&gt; is the empty string.  To do this a new string is created
         and the strings &lt;VAR&gt;name&lt;/VAR&gt; and &lt;VAR&gt;value&lt;/VAR&gt; are copied.  A null pointer
         for the &lt;VAR&gt;value&lt;/VAR&gt; parameter is illegal.  If the environment already
         contains an entry with key &lt;VAR&gt;name&lt;/VAR&gt; the &lt;VAR&gt;replace&lt;/VAR&gt; parameter
         controls the action.  If replace is zero, nothing happens.  Otherwise
         the old entry is replaced by the new one.
         &lt;br&gt;&lt;br&gt; Please note that you cannot remove an entry completely using this function.
         &lt;br&gt;&lt;br&gt; This function was originally part of the BSD library but is now part of
         the Unix standard.
        </synopsis>
    </function>
  </construct>
  <construct id="function-unsetenv" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *name"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        Using this function one can remove an entry completely from the
         environment.  If the environment contains an entry with the key
         &lt;VAR&gt;name&lt;/VAR&gt; this whole entry is removed.  A call to this function is
         equivalent to a call to &lt;CODE&gt;putenv&lt;/CODE&gt; when the &lt;VAR&gt;value&lt;/VAR&gt; part of the
         string is empty.
         &lt;br&gt;&lt;br&gt; The function return &lt;CODE&gt;-1&lt;/CODE&gt; if &lt;VAR&gt;name&lt;/VAR&gt; is a null pointer, points to
         an empty string, or points to a string containing a &lt;CODE&gt;=&lt;/CODE&gt; character.
         It returns &lt;CODE&gt;0&lt;/CODE&gt; if the call succeeded.
         &lt;br&gt;&lt;br&gt; This function was originally part of the BSD library but is now part of
         the Unix standard.  The BSD version had no return value, though.
        </synopsis>
    </function>
  </construct>
  <construct id="function-clearenv" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;clearenv&lt;/CODE&gt; function removes all entries from the environment.
         Using &lt;CODE&gt;putenv&lt;/CODE&gt; and &lt;CODE&gt;setenv&lt;/CODE&gt; new entries can be added again
         later.
         &lt;br&gt;&lt;br&gt; If the function is successful it returns &lt;CODE&gt;0&lt;/CODE&gt;.  Otherwise the return
         value is nonzero.
        </synopsis>
    </function>
  </construct>
  <construct id="function-syscall" type="function">
    <function returntype="long int">
      <prototype>
        <parameter content="long int sysno"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; &lt;CODE&gt;syscall&lt;/CODE&gt; performs a generic system call.
         &lt;br&gt;&lt;br&gt;  call number
         &lt;VAR&gt;sysno&lt;/VAR&gt; is the system call number.  Each kind of system call is
         identified by a number.  Macros for all the possible system call numbers
         are defined in &lt;TT&gt;sys/syscall.h&lt;/TT&gt;
         &lt;br&gt;&lt;br&gt; The remaining arguments are the arguments for the system call, in
         order, and their meanings depend on the kind of system call.  Each kind
         of system call has a definite number of arguments, from zero to five.
         If you code more arguments than the system call takes, the extra ones to
         the right are ignored.
         &lt;br&gt;&lt;br&gt; The return value is the return value from the system call, unless the
         system call failed.  In that case, &lt;CODE&gt;syscall&lt;/CODE&gt; returns &lt;CODE&gt;-1&lt;/CODE&gt; and
         sets &lt;CODE&gt;errno&lt;/CODE&gt; to an error code that the system call returned.  Note
         that system calls do not return &lt;CODE&gt;-1&lt;/CODE&gt; when they succeed.

         &lt;br&gt;&lt;br&gt; If you specify an invalid &lt;VAR&gt;sysno&lt;/VAR&gt;, &lt;CODE&gt;syscall&lt;/CODE&gt; returns &lt;CODE&gt;-1&lt;/CODE&gt;
         with &lt;CODE&gt;errno&lt;/CODE&gt; = &lt;CODE&gt;ENOSYS&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; Example:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; #include &lt;unistd.h&gt;&lt;br&gt;
         #include &lt;sys/syscall.h&gt;&lt;br&gt;
         #include &lt;errno.h&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;small&gt;...&lt;/small&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; int rc;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; rc = syscall(SYS_chmod, "/etc/passwd", 0444);&lt;br&gt;
         &lt;br&gt;&lt;br&gt; if (rc == -1)&lt;br&gt;
            fprintf(stderr, "chmod failed, errno = %d\n", errno);&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;/pre&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; This, if all the compatibility stars are aligned, is equivalent to the&lt;br&gt;
         following preferable code:&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; #include &lt;sys/types.h&gt;&lt;br&gt;
         #include &lt;sys/stat.h&gt;&lt;br&gt;
         #include &lt;errno.h&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;small&gt;...&lt;/small&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; int rc;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; rc = chmod("/etc/passwd", 0444);&lt;br&gt;
         if (rc == -1)&lt;br&gt;
            fprintf(stderr, "chmod failed, errno = %d\n", errno);&lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-exit" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="int status"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;exit&lt;/CODE&gt; function tells the system that the program is done, which
         causes it to terminate the process.
         &lt;br&gt;&lt;br&gt; &lt;VAR&gt;status&lt;/VAR&gt; is the program's exit status, which becomes part of the
         process' termination status.  This function does not return.
        </synopsis>
    </function>
  </construct>
  <construct id="function-atexit" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="void (*function) (void)"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;atexit&lt;/CODE&gt; function registers the function &lt;VAR&gt;function&lt;/VAR&gt; to be
         called at normal program termination.  The &lt;VAR&gt;function&lt;/VAR&gt; is called with
         no arguments.
         &lt;br&gt;&lt;br&gt; The return value from &lt;CODE&gt;atexit&lt;/CODE&gt; is zero on success and nonzero if
         the function cannot be registered.
        </synopsis>
    </function>
  </construct>
  <construct id="function-on_exit" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="void (*function)(int status"/>
        <parameter content="void *arg)"/>
        <parameter content="void *arg"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        This function is a somewhat more powerful variant of &lt;CODE&gt;atexit&lt;/CODE&gt;.  It
         accepts two arguments, a function &lt;VAR&gt;function&lt;/VAR&gt; and an arbitrary
         pointer &lt;VAR&gt;arg&lt;/VAR&gt;.  At normal program termination, the &lt;VAR&gt;function&lt;/VAR&gt; is
         called with two arguments:  the &lt;VAR&gt;status&lt;/VAR&gt; value passed to &lt;CODE&gt;exit&lt;/CODE&gt;,
         and the &lt;VAR&gt;arg&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; This function is included in the GNU C library only for compatibility
         for SunOS, and may not be supported by other implementations.
        </synopsis>
    </function>
  </construct>
  <construct id="function-abort" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;abort&lt;/CODE&gt; function causes abnormal program termination.  This
         does not execute cleanup functions registered with &lt;CODE&gt;atexit&lt;/CODE&gt; or
         &lt;CODE&gt;on_exit&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This function actually terminates the process by raising a
         &lt;CODE&gt;SIGABRT&lt;/CODE&gt; signal, and your program can include a handler to
         intercept this signal; see Signal Handling.
        </synopsis>
    </function>
  </construct>
  <construct id="function-_exit" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="int status"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;_exit&lt;/CODE&gt; function is the primitive for causing a process to
         terminate with status &lt;VAR&gt;status&lt;/VAR&gt;.  Calling this function does not
         execute cleanup functions registered with &lt;CODE&gt;atexit&lt;/CODE&gt; or
         &lt;CODE&gt;on_exit&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-_Exit" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="int status"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;_Exit&lt;/CODE&gt; function is the ISO C equivalent to &lt;CODE&gt;_exit&lt;/CODE&gt;.
         The ISO C committee members were not sure whether the definitions of
         &lt;CODE&gt;_exit&lt;/CODE&gt; and &lt;CODE&gt;_Exit&lt;/CODE&gt; were compatible so they have not used the
         POSIX name.
         &lt;br&gt;&lt;br&gt; This function was introduced in ISO C99 and is declared in
         &lt;TT&gt;stdlib.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-sin" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the sine of &lt;VAR&gt;x&lt;/VAR&gt;, where &lt;VAR&gt;x&lt;/VAR&gt; is given in
         radians.  The return value is in the range &lt;CODE&gt;-1&lt;/CODE&gt; to &lt;CODE&gt;1&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-sinf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the sine of &lt;VAR&gt;x&lt;/VAR&gt;, where &lt;VAR&gt;x&lt;/VAR&gt; is given in
         radians.  The return value is in the range &lt;CODE&gt;-1&lt;/CODE&gt; to &lt;CODE&gt;1&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-sinl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the sine of &lt;VAR&gt;x&lt;/VAR&gt;, where &lt;VAR&gt;x&lt;/VAR&gt; is given in
         radians.  The return value is in the range &lt;CODE&gt;-1&lt;/CODE&gt; to &lt;CODE&gt;1&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cos" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the cosine of &lt;VAR&gt;x&lt;/VAR&gt;, where &lt;VAR&gt;x&lt;/VAR&gt; is given in
         radians.  The return value is in the range &lt;CODE&gt;-1&lt;/CODE&gt; to &lt;CODE&gt;1&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cosf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the cosine of &lt;VAR&gt;x&lt;/VAR&gt;, where &lt;VAR&gt;x&lt;/VAR&gt; is given in
         radians.  The return value is in the range &lt;CODE&gt;-1&lt;/CODE&gt; to &lt;CODE&gt;1&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cosl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the cosine of &lt;VAR&gt;x&lt;/VAR&gt;, where &lt;VAR&gt;x&lt;/VAR&gt; is given in
         radians.  The return value is in the range &lt;CODE&gt;-1&lt;/CODE&gt; to &lt;CODE&gt;1&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-tan" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the tangent of &lt;VAR&gt;x&lt;/VAR&gt;, where &lt;VAR&gt;x&lt;/VAR&gt; is given in
         radians.
         &lt;br&gt;&lt;br&gt; Mathematically, the tangent function has singularities at odd multiples
         of pi/2.  If the argument &lt;VAR&gt;x&lt;/VAR&gt; is too close to one of these
         singularities, &lt;CODE&gt;tan&lt;/CODE&gt; will signal overflow.
        </synopsis>
    </function>
  </construct>
  <construct id="function-tanf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the tangent of &lt;VAR&gt;x&lt;/VAR&gt;, where &lt;VAR&gt;x&lt;/VAR&gt; is given in
         radians.
         &lt;br&gt;&lt;br&gt; Mathematically, the tangent function has singularities at odd multiples
         of pi/2.  If the argument &lt;VAR&gt;x&lt;/VAR&gt; is too close to one of these
         singularities, &lt;CODE&gt;tan&lt;/CODE&gt; will signal overflow.
        </synopsis>
    </function>
  </construct>
  <construct id="function-tanl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the tangent of &lt;VAR&gt;x&lt;/VAR&gt;, where &lt;VAR&gt;x&lt;/VAR&gt; is given in
         radians.
         &lt;br&gt;&lt;br&gt; Mathematically, the tangent function has singularities at odd multiples
         of pi/2.  If the argument &lt;VAR&gt;x&lt;/VAR&gt; is too close to one of these
         singularities, &lt;CODE&gt;tan&lt;/CODE&gt; will signal overflow.
        </synopsis>
    </function>
  </construct>
  <construct id="function-sincos" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="double x"/>
        <parameter content="double *sinx"/>
        <parameter content="double *cosx"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the sine of &lt;VAR&gt;x&lt;/VAR&gt; in &lt;CODE&gt;*&lt;VAR&gt;sinx&lt;/VAR&gt;&lt;/CODE&gt; and the
         cosine of &lt;VAR&gt;x&lt;/VAR&gt; in &lt;CODE&gt;*&lt;VAR&gt;cos&lt;/VAR&gt;&lt;/CODE&gt;, where &lt;VAR&gt;x&lt;/VAR&gt; is given in
         radians.  Both values, &lt;CODE&gt;*&lt;VAR&gt;sinx&lt;/VAR&gt;&lt;/CODE&gt; and &lt;CODE&gt;*&lt;VAR&gt;cosx&lt;/VAR&gt;&lt;/CODE&gt;, are in
         the range of &lt;CODE&gt;-1&lt;/CODE&gt; to &lt;CODE&gt;1&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.  Portable programs should be prepared
         to cope with its absence.
        </synopsis>
    </function>
  </construct>
  <construct id="function-sincosf" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="float x"/>
        <parameter content="float *sinx"/>
        <parameter content="float *cosx"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the sine of &lt;VAR&gt;x&lt;/VAR&gt; in &lt;CODE&gt;*&lt;VAR&gt;sinx&lt;/VAR&gt;&lt;/CODE&gt; and the
         cosine of &lt;VAR&gt;x&lt;/VAR&gt; in &lt;CODE&gt;*&lt;VAR&gt;cos&lt;/VAR&gt;&lt;/CODE&gt;, where &lt;VAR&gt;x&lt;/VAR&gt; is given in
         radians.  Both values, &lt;CODE&gt;*&lt;VAR&gt;sinx&lt;/VAR&gt;&lt;/CODE&gt; and &lt;CODE&gt;*&lt;VAR&gt;cosx&lt;/VAR&gt;&lt;/CODE&gt;, are in
         the range of &lt;CODE&gt;-1&lt;/CODE&gt; to &lt;CODE&gt;1&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.  Portable programs should be prepared
         to cope with its absence.
        </synopsis>
    </function>
  </construct>
  <construct id="function-sincosl" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="long double x"/>
        <parameter content="long double *sinx"/>
        <parameter content="long double *cosx"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the sine of &lt;VAR&gt;x&lt;/VAR&gt; in &lt;CODE&gt;*&lt;VAR&gt;sinx&lt;/VAR&gt;&lt;/CODE&gt; and the
         cosine of &lt;VAR&gt;x&lt;/VAR&gt; in &lt;CODE&gt;*&lt;VAR&gt;cos&lt;/VAR&gt;&lt;/CODE&gt;, where &lt;VAR&gt;x&lt;/VAR&gt; is given in
         radians.  Both values, &lt;CODE&gt;*&lt;VAR&gt;sinx&lt;/VAR&gt;&lt;/CODE&gt; and &lt;CODE&gt;*&lt;VAR&gt;cosx&lt;/VAR&gt;&lt;/CODE&gt;, are in
         the range of &lt;CODE&gt;-1&lt;/CODE&gt; to &lt;CODE&gt;1&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.  Portable programs should be prepared
         to cope with its absence.
        </synopsis>
    </function>
  </construct>
  <construct id="function-csin" type="function">
    <function returntype="complex double">
      <prototype>
        <parameter content="complex double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the complex sine of &lt;VAR&gt;z&lt;/VAR&gt;.
         The mathematical definition of the complex sine is
         &lt;br&gt;&lt;br&gt;
         sin (z) = 1/(2*i) * (exp (z*i) - exp (-z*i)).


        </synopsis>
    </function>
  </construct>
  <construct id="function-csinf" type="function">
    <function returntype="complex float">
      <prototype>
        <parameter content="complex float z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the complex sine of &lt;VAR&gt;z&lt;/VAR&gt;.
         The mathematical definition of the complex sine is
         &lt;br&gt;&lt;br&gt;
         sin (z) = 1/(2*i) * (exp (z*i) - exp (-z*i)).


        </synopsis>
    </function>
  </construct>
  <construct id="function-csinl" type="function">
    <function returntype="complex long double">
      <prototype>
        <parameter content="complex long double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the complex sine of &lt;VAR&gt;z&lt;/VAR&gt;.
         The mathematical definition of the complex sine is
         &lt;br&gt;&lt;br&gt;
         sin (z) = 1/(2*i) * (exp (z*i) - exp (-z*i)).


        </synopsis>
    </function>
  </construct>
  <construct id="function-ccos" type="function">
    <function returntype="complex double">
      <prototype>
        <parameter content="complex double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the complex cosine of &lt;VAR&gt;z&lt;/VAR&gt;.
         The mathematical definition of the complex cosine is
         &lt;br&gt;&lt;br&gt;
         cos (z) = 1/2 * (exp (z*i) + exp (-z*i))


        </synopsis>
    </function>
  </construct>
  <construct id="function-ccosf" type="function">
    <function returntype="complex float">
      <prototype>
        <parameter content="complex float z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the complex cosine of &lt;VAR&gt;z&lt;/VAR&gt;.
         The mathematical definition of the complex cosine is
         &lt;br&gt;&lt;br&gt;
         cos (z) = 1/2 * (exp (z*i) + exp (-z*i))


        </synopsis>
    </function>
  </construct>
  <construct id="function-ccosl" type="function">
    <function returntype="complex long double">
      <prototype>
        <parameter content="complex long double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the complex cosine of &lt;VAR&gt;z&lt;/VAR&gt;.
         The mathematical definition of the complex cosine is
         &lt;br&gt;&lt;br&gt;
         cos (z) = 1/2 * (exp (z*i) + exp (-z*i))


        </synopsis>
    </function>
  </construct>
  <construct id="function-ctan" type="function">
    <function returntype="complex double">
      <prototype>
        <parameter content="complex double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the complex tangent of &lt;VAR&gt;z&lt;/VAR&gt;.
         The mathematical definition of the complex tangent is
         &lt;br&gt;&lt;br&gt;
         tan (z) = -i * (exp (z*i) - exp (-z*i)) / (exp (z*i) + exp (-z*i))


         &lt;br&gt;&lt;br&gt;
         The complex tangent has poles at pi/2 + 2n, where n is an
         integer.  &lt;CODE&gt;ctan&lt;/CODE&gt; may signal overflow if &lt;VAR&gt;z&lt;/VAR&gt; is too close to a
         pole.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ctanf" type="function">
    <function returntype="complex float">
      <prototype>
        <parameter content="complex float z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the complex tangent of &lt;VAR&gt;z&lt;/VAR&gt;.
         The mathematical definition of the complex tangent is
         &lt;br&gt;&lt;br&gt;
         tan (z) = -i * (exp (z*i) - exp (-z*i)) / (exp (z*i) + exp (-z*i))


         &lt;br&gt;&lt;br&gt;
         The complex tangent has poles at pi/2 + 2n, where n is an
         integer.  &lt;CODE&gt;ctan&lt;/CODE&gt; may signal overflow if &lt;VAR&gt;z&lt;/VAR&gt; is too close to a
         pole.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ctanl" type="function">
    <function returntype="complex long double">
      <prototype>
        <parameter content="complex long double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the complex tangent of &lt;VAR&gt;z&lt;/VAR&gt;.
         The mathematical definition of the complex tangent is
         &lt;br&gt;&lt;br&gt;
         tan (z) = -i * (exp (z*i) - exp (-z*i)) / (exp (z*i) + exp (-z*i))


         &lt;br&gt;&lt;br&gt;
         The complex tangent has poles at pi/2 + 2n, where n is an
         integer.  &lt;CODE&gt;ctan&lt;/CODE&gt; may signal overflow if &lt;VAR&gt;z&lt;/VAR&gt; is too close to a
         pole.
        </synopsis>
    </function>
  </construct>
  <construct id="function-asin" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions compute the arc sine of &lt;VAR&gt;x&lt;/VAR&gt;---that is, the value whose
         sine is &lt;VAR&gt;x&lt;/VAR&gt;.  The value is in units of radians.  Mathematically,
         there are infinitely many such values; the one actually returned is the
         one between &lt;CODE&gt;-pi/2&lt;/CODE&gt; and &lt;CODE&gt;pi/2&lt;/CODE&gt; (inclusive).
         &lt;br&gt;&lt;br&gt; The arc sine function is defined mathematically only
         over the domain &lt;CODE&gt;-1&lt;/CODE&gt; to &lt;CODE&gt;1&lt;/CODE&gt;.  If &lt;VAR&gt;x&lt;/VAR&gt; is outside the
         domain, &lt;CODE&gt;asin&lt;/CODE&gt; signals a domain error.
        </synopsis>
    </function>
  </construct>
  <construct id="function-asinf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions compute the arc sine of &lt;VAR&gt;x&lt;/VAR&gt;---that is, the value whose
         sine is &lt;VAR&gt;x&lt;/VAR&gt;.  The value is in units of radians.  Mathematically,
         there are infinitely many such values; the one actually returned is the
         one between &lt;CODE&gt;-pi/2&lt;/CODE&gt; and &lt;CODE&gt;pi/2&lt;/CODE&gt; (inclusive).
         &lt;br&gt;&lt;br&gt; The arc sine function is defined mathematically only
         over the domain &lt;CODE&gt;-1&lt;/CODE&gt; to &lt;CODE&gt;1&lt;/CODE&gt;.  If &lt;VAR&gt;x&lt;/VAR&gt; is outside the
         domain, &lt;CODE&gt;asin&lt;/CODE&gt; signals a domain error.
        </synopsis>
    </function>
  </construct>
  <construct id="function-asinl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions compute the arc sine of &lt;VAR&gt;x&lt;/VAR&gt;---that is, the value whose
         sine is &lt;VAR&gt;x&lt;/VAR&gt;.  The value is in units of radians.  Mathematically,
         there are infinitely many such values; the one actually returned is the
         one between &lt;CODE&gt;-pi/2&lt;/CODE&gt; and &lt;CODE&gt;pi/2&lt;/CODE&gt; (inclusive).
         &lt;br&gt;&lt;br&gt; The arc sine function is defined mathematically only
         over the domain &lt;CODE&gt;-1&lt;/CODE&gt; to &lt;CODE&gt;1&lt;/CODE&gt;.  If &lt;VAR&gt;x&lt;/VAR&gt; is outside the
         domain, &lt;CODE&gt;asin&lt;/CODE&gt; signals a domain error.
        </synopsis>
    </function>
  </construct>
  <construct id="function-acos" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions compute the arc cosine of &lt;VAR&gt;x&lt;/VAR&gt;---that is, the value
         whose cosine is &lt;VAR&gt;x&lt;/VAR&gt;.  The value is in units of radians.
         Mathematically, there are infinitely many such values; the one actually
         returned is the one between &lt;CODE&gt;0&lt;/CODE&gt; and &lt;CODE&gt;pi&lt;/CODE&gt; (inclusive).
         &lt;br&gt;&lt;br&gt; The arc cosine function is defined mathematically only
         over the domain &lt;CODE&gt;-1&lt;/CODE&gt; to &lt;CODE&gt;1&lt;/CODE&gt;.  If &lt;VAR&gt;x&lt;/VAR&gt; is outside the
         domain, &lt;CODE&gt;acos&lt;/CODE&gt; signals a domain error.
        </synopsis>
    </function>
  </construct>
  <construct id="function-acosf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions compute the arc cosine of &lt;VAR&gt;x&lt;/VAR&gt;---that is, the value
         whose cosine is &lt;VAR&gt;x&lt;/VAR&gt;.  The value is in units of radians.
         Mathematically, there are infinitely many such values; the one actually
         returned is the one between &lt;CODE&gt;0&lt;/CODE&gt; and &lt;CODE&gt;pi&lt;/CODE&gt; (inclusive).
         &lt;br&gt;&lt;br&gt; The arc cosine function is defined mathematically only
         over the domain &lt;CODE&gt;-1&lt;/CODE&gt; to &lt;CODE&gt;1&lt;/CODE&gt;.  If &lt;VAR&gt;x&lt;/VAR&gt; is outside the
         domain, &lt;CODE&gt;acos&lt;/CODE&gt; signals a domain error.
        </synopsis>
    </function>
  </construct>
  <construct id="function-acosl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions compute the arc cosine of &lt;VAR&gt;x&lt;/VAR&gt;---that is, the value
         whose cosine is &lt;VAR&gt;x&lt;/VAR&gt;.  The value is in units of radians.
         Mathematically, there are infinitely many such values; the one actually
         returned is the one between &lt;CODE&gt;0&lt;/CODE&gt; and &lt;CODE&gt;pi&lt;/CODE&gt; (inclusive).
         &lt;br&gt;&lt;br&gt; The arc cosine function is defined mathematically only
         over the domain &lt;CODE&gt;-1&lt;/CODE&gt; to &lt;CODE&gt;1&lt;/CODE&gt;.  If &lt;VAR&gt;x&lt;/VAR&gt; is outside the
         domain, &lt;CODE&gt;acos&lt;/CODE&gt; signals a domain error.
        </synopsis>
    </function>
  </construct>
  <construct id="function-atan" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions compute the arc tangent of &lt;VAR&gt;x&lt;/VAR&gt;---that is, the value
         whose tangent is &lt;VAR&gt;x&lt;/VAR&gt;.  The value is in units of radians.
         Mathematically, there are infinitely many such values; the one actually
         returned is the one between &lt;CODE&gt;-pi/2&lt;/CODE&gt; and &lt;CODE&gt;pi/2&lt;/CODE&gt; (inclusive).
        </synopsis>
    </function>
  </construct>
  <construct id="function-atanf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions compute the arc tangent of &lt;VAR&gt;x&lt;/VAR&gt;---that is, the value
         whose tangent is &lt;VAR&gt;x&lt;/VAR&gt;.  The value is in units of radians.
         Mathematically, there are infinitely many such values; the one actually
         returned is the one between &lt;CODE&gt;-pi/2&lt;/CODE&gt; and &lt;CODE&gt;pi/2&lt;/CODE&gt; (inclusive).
        </synopsis>
    </function>
  </construct>
  <construct id="function-atanl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions compute the arc tangent of &lt;VAR&gt;x&lt;/VAR&gt;---that is, the value
         whose tangent is &lt;VAR&gt;x&lt;/VAR&gt;.  The value is in units of radians.
         Mathematically, there are infinitely many such values; the one actually
         returned is the one between &lt;CODE&gt;-pi/2&lt;/CODE&gt; and &lt;CODE&gt;pi/2&lt;/CODE&gt; (inclusive).
        </synopsis>
    </function>
  </construct>
  <construct id="function-atan2" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double y"/>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        This function computes the arc tangent of &lt;VAR&gt;y&lt;/VAR&gt;/&lt;VAR&gt;x&lt;/VAR&gt;, but the signs
         of both arguments are used to determine the quadrant of the result, and
         &lt;VAR&gt;x&lt;/VAR&gt; is permitted to be zero.  The return value is given in radians
         and is in the range &lt;CODE&gt;-pi&lt;/CODE&gt; to &lt;CODE&gt;pi&lt;/CODE&gt;, inclusive.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;x&lt;/VAR&gt; and &lt;VAR&gt;y&lt;/VAR&gt; are coordinates of a point in the plane,
         &lt;CODE&gt;atan2&lt;/CODE&gt; returns the signed angle between the line from the origin
         to that point and the x-axis.  Thus, &lt;CODE&gt;atan2&lt;/CODE&gt; is useful for
         converting Cartesian coordinates to polar coordinates.  (To compute the
         radial coordinate, use &lt;CODE&gt;hypot&lt;/CODE&gt;; see Exponents and
         Logarithms.)
         &lt;br&gt;&lt;br&gt; If both &lt;VAR&gt;x&lt;/VAR&gt; and &lt;VAR&gt;y&lt;/VAR&gt; are zero, &lt;CODE&gt;atan2&lt;/CODE&gt; returns zero.
        </synopsis>
    </function>
  </construct>
  <construct id="function-atan2f" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float y"/>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        This function computes the arc tangent of &lt;VAR&gt;y&lt;/VAR&gt;/&lt;VAR&gt;x&lt;/VAR&gt;, but the signs
         of both arguments are used to determine the quadrant of the result, and
         &lt;VAR&gt;x&lt;/VAR&gt; is permitted to be zero.  The return value is given in radians
         and is in the range &lt;CODE&gt;-pi&lt;/CODE&gt; to &lt;CODE&gt;pi&lt;/CODE&gt;, inclusive.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;x&lt;/VAR&gt; and &lt;VAR&gt;y&lt;/VAR&gt; are coordinates of a point in the plane,
         &lt;CODE&gt;atan2&lt;/CODE&gt; returns the signed angle between the line from the origin
         to that point and the x-axis.  Thus, &lt;CODE&gt;atan2&lt;/CODE&gt; is useful for
         converting Cartesian coordinates to polar coordinates.  (To compute the
         radial coordinate, use &lt;CODE&gt;hypot&lt;/CODE&gt;; see Exponents and
         Logarithms.)
         &lt;br&gt;&lt;br&gt; If both &lt;VAR&gt;x&lt;/VAR&gt; and &lt;VAR&gt;y&lt;/VAR&gt; are zero, &lt;CODE&gt;atan2&lt;/CODE&gt; returns zero.
        </synopsis>
    </function>
  </construct>
  <construct id="function-atan2l" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double y"/>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        This function computes the arc tangent of &lt;VAR&gt;y&lt;/VAR&gt;/&lt;VAR&gt;x&lt;/VAR&gt;, but the signs
         of both arguments are used to determine the quadrant of the result, and
         &lt;VAR&gt;x&lt;/VAR&gt; is permitted to be zero.  The return value is given in radians
         and is in the range &lt;CODE&gt;-pi&lt;/CODE&gt; to &lt;CODE&gt;pi&lt;/CODE&gt;, inclusive.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;x&lt;/VAR&gt; and &lt;VAR&gt;y&lt;/VAR&gt; are coordinates of a point in the plane,
         &lt;CODE&gt;atan2&lt;/CODE&gt; returns the signed angle between the line from the origin
         to that point and the x-axis.  Thus, &lt;CODE&gt;atan2&lt;/CODE&gt; is useful for
         converting Cartesian coordinates to polar coordinates.  (To compute the
         radial coordinate, use &lt;CODE&gt;hypot&lt;/CODE&gt;; see Exponents and
         Logarithms.)
         &lt;br&gt;&lt;br&gt; If both &lt;VAR&gt;x&lt;/VAR&gt; and &lt;VAR&gt;y&lt;/VAR&gt; are zero, &lt;CODE&gt;atan2&lt;/CODE&gt; returns zero.
        </synopsis>
    </function>
  </construct>
  <construct id="function-casin" type="function">
    <function returntype="complex double">
      <prototype>
        <parameter content="complex double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions compute the complex arc sine of &lt;VAR&gt;z&lt;/VAR&gt;---that is, the
         value whose sine is &lt;VAR&gt;z&lt;/VAR&gt;.  The value returned is in radians.
         &lt;br&gt;&lt;br&gt; Unlike the real-valued functions, &lt;CODE&gt;casin&lt;/CODE&gt; is defined for all
         values of &lt;VAR&gt;z&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-casinf" type="function">
    <function returntype="complex float">
      <prototype>
        <parameter content="complex float z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions compute the complex arc sine of &lt;VAR&gt;z&lt;/VAR&gt;---that is, the
         value whose sine is &lt;VAR&gt;z&lt;/VAR&gt;.  The value returned is in radians.
         &lt;br&gt;&lt;br&gt; Unlike the real-valued functions, &lt;CODE&gt;casin&lt;/CODE&gt; is defined for all
         values of &lt;VAR&gt;z&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-casinl" type="function">
    <function returntype="complex long double">
      <prototype>
        <parameter content="complex long double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions compute the complex arc sine of &lt;VAR&gt;z&lt;/VAR&gt;---that is, the
         value whose sine is &lt;VAR&gt;z&lt;/VAR&gt;.  The value returned is in radians.
         &lt;br&gt;&lt;br&gt; Unlike the real-valued functions, &lt;CODE&gt;casin&lt;/CODE&gt; is defined for all
         values of &lt;VAR&gt;z&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cacos" type="function">
    <function returntype="complex double">
      <prototype>
        <parameter content="complex double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions compute the complex arc cosine of &lt;VAR&gt;z&lt;/VAR&gt;---that is, the
         value whose cosine is &lt;VAR&gt;z&lt;/VAR&gt;.  The value returned is in radians.
         &lt;br&gt;&lt;br&gt; Unlike the real-valued functions, &lt;CODE&gt;cacos&lt;/CODE&gt; is defined for all
         values of &lt;VAR&gt;z&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cacosf" type="function">
    <function returntype="complex float">
      <prototype>
        <parameter content="complex float z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions compute the complex arc cosine of &lt;VAR&gt;z&lt;/VAR&gt;---that is, the
         value whose cosine is &lt;VAR&gt;z&lt;/VAR&gt;.  The value returned is in radians.
         &lt;br&gt;&lt;br&gt; Unlike the real-valued functions, &lt;CODE&gt;cacos&lt;/CODE&gt; is defined for all
         values of &lt;VAR&gt;z&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cacosl" type="function">
    <function returntype="complex long double">
      <prototype>
        <parameter content="complex long double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions compute the complex arc cosine of &lt;VAR&gt;z&lt;/VAR&gt;---that is, the
         value whose cosine is &lt;VAR&gt;z&lt;/VAR&gt;.  The value returned is in radians.
         &lt;br&gt;&lt;br&gt; Unlike the real-valued functions, &lt;CODE&gt;cacos&lt;/CODE&gt; is defined for all
         values of &lt;VAR&gt;z&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-catan" type="function">
    <function returntype="complex double">
      <prototype>
        <parameter content="complex double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions compute the complex arc tangent of &lt;VAR&gt;z&lt;/VAR&gt;---that is,
         the value whose tangent is &lt;VAR&gt;z&lt;/VAR&gt;.  The value is in units of radians.
        </synopsis>
    </function>
  </construct>
  <construct id="function-catanf" type="function">
    <function returntype="complex float">
      <prototype>
        <parameter content="complex float z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions compute the complex arc tangent of &lt;VAR&gt;z&lt;/VAR&gt;---that is,
         the value whose tangent is &lt;VAR&gt;z&lt;/VAR&gt;.  The value is in units of radians.
        </synopsis>
    </function>
  </construct>
  <construct id="function-catanl" type="function">
    <function returntype="complex long double">
      <prototype>
        <parameter content="complex long double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions compute the complex arc tangent of &lt;VAR&gt;z&lt;/VAR&gt;---that is,
         the value whose tangent is &lt;VAR&gt;z&lt;/VAR&gt;.  The value is in units of radians.
        </synopsis>
    </function>
  </construct>
  <construct id="function-exp" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions compute &lt;CODE&gt;e&lt;/CODE&gt; (the base of natural logarithms) raised
         to the power &lt;VAR&gt;x&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If the magnitude of the result is too large to be representable,
         &lt;CODE&gt;exp&lt;/CODE&gt; signals overflow.
        </synopsis>
    </function>
  </construct>
  <construct id="function-expf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions compute &lt;CODE&gt;e&lt;/CODE&gt; (the base of natural logarithms) raised
         to the power &lt;VAR&gt;x&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If the magnitude of the result is too large to be representable,
         &lt;CODE&gt;exp&lt;/CODE&gt; signals overflow.
        </synopsis>
    </function>
  </construct>
  <construct id="function-expl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions compute &lt;CODE&gt;e&lt;/CODE&gt; (the base of natural logarithms) raised
         to the power &lt;VAR&gt;x&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If the magnitude of the result is too large to be representable,
         &lt;CODE&gt;exp&lt;/CODE&gt; signals overflow.
        </synopsis>
    </function>
  </construct>
  <construct id="function-exp2" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions compute &lt;CODE&gt;2&lt;/CODE&gt; raised to the power &lt;VAR&gt;x&lt;/VAR&gt;.
         Mathematically, &lt;CODE&gt;exp2 (x)&lt;/CODE&gt; is the same as &lt;CODE&gt;exp (x * log (2))&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-exp2f" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions compute &lt;CODE&gt;2&lt;/CODE&gt; raised to the power &lt;VAR&gt;x&lt;/VAR&gt;.
         Mathematically, &lt;CODE&gt;exp2 (x)&lt;/CODE&gt; is the same as &lt;CODE&gt;exp (x * log (2))&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-exp2l" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions compute &lt;CODE&gt;2&lt;/CODE&gt; raised to the power &lt;VAR&gt;x&lt;/VAR&gt;.
         Mathematically, &lt;CODE&gt;exp2 (x)&lt;/CODE&gt; is the same as &lt;CODE&gt;exp (x * log (2))&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-exp10" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions compute &lt;CODE&gt;10&lt;/CODE&gt; raised to the power &lt;VAR&gt;x&lt;/VAR&gt;.
         Mathematically, &lt;CODE&gt;exp10 (x)&lt;/CODE&gt; is the same as &lt;CODE&gt;exp (x * log (10))&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; These functions are GNU extensions.  The name &lt;CODE&gt;exp10&lt;/CODE&gt; is
         preferred, since it is analogous to &lt;CODE&gt;exp&lt;/CODE&gt; and &lt;CODE&gt;exp2&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-exp10f" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions compute &lt;CODE&gt;10&lt;/CODE&gt; raised to the power &lt;VAR&gt;x&lt;/VAR&gt;.
         Mathematically, &lt;CODE&gt;exp10 (x)&lt;/CODE&gt; is the same as &lt;CODE&gt;exp (x * log (10))&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; These functions are GNU extensions.  The name &lt;CODE&gt;exp10&lt;/CODE&gt; is
         preferred, since it is analogous to &lt;CODE&gt;exp&lt;/CODE&gt; and &lt;CODE&gt;exp2&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-exp10l" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions compute &lt;CODE&gt;10&lt;/CODE&gt; raised to the power &lt;VAR&gt;x&lt;/VAR&gt;.
         Mathematically, &lt;CODE&gt;exp10 (x)&lt;/CODE&gt; is the same as &lt;CODE&gt;exp (x * log (10))&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; These functions are GNU extensions.  The name &lt;CODE&gt;exp10&lt;/CODE&gt; is
         preferred, since it is analogous to &lt;CODE&gt;exp&lt;/CODE&gt; and &lt;CODE&gt;exp2&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-pow10" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions compute &lt;CODE&gt;10&lt;/CODE&gt; raised to the power &lt;VAR&gt;x&lt;/VAR&gt;.
         Mathematically, &lt;CODE&gt;exp10 (x)&lt;/CODE&gt; is the same as &lt;CODE&gt;exp (x * log (10))&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; These functions are GNU extensions.  The name &lt;CODE&gt;exp10&lt;/CODE&gt; is
         preferred, since it is analogous to &lt;CODE&gt;exp&lt;/CODE&gt; and &lt;CODE&gt;exp2&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-pow10f" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions compute &lt;CODE&gt;10&lt;/CODE&gt; raised to the power &lt;VAR&gt;x&lt;/VAR&gt;.
         Mathematically, &lt;CODE&gt;exp10 (x)&lt;/CODE&gt; is the same as &lt;CODE&gt;exp (x * log (10))&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; These functions are GNU extensions.  The name &lt;CODE&gt;exp10&lt;/CODE&gt; is
         preferred, since it is analogous to &lt;CODE&gt;exp&lt;/CODE&gt; and &lt;CODE&gt;exp2&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-pow10l" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions compute &lt;CODE&gt;10&lt;/CODE&gt; raised to the power &lt;VAR&gt;x&lt;/VAR&gt;.
         Mathematically, &lt;CODE&gt;exp10 (x)&lt;/CODE&gt; is the same as &lt;CODE&gt;exp (x * log (10))&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; These functions are GNU extensions.  The name &lt;CODE&gt;exp10&lt;/CODE&gt; is
         preferred, since it is analogous to &lt;CODE&gt;exp&lt;/CODE&gt; and &lt;CODE&gt;exp2&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-log" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions compute the natural logarithm of &lt;VAR&gt;x&lt;/VAR&gt;.  &lt;CODE&gt;exp (log
         (&lt;VAR&gt;x&lt;/VAR&gt;))&lt;/CODE&gt; equals &lt;VAR&gt;x&lt;/VAR&gt;, exactly in mathematics and approximately in
         C.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;x&lt;/VAR&gt; is negative, &lt;CODE&gt;log&lt;/CODE&gt; signals a domain error.  If &lt;VAR&gt;x&lt;/VAR&gt;
         is zero, it returns negative infinity; if &lt;VAR&gt;x&lt;/VAR&gt; is too close to zero,
         it may signal overflow.
        </synopsis>
    </function>
  </construct>
  <construct id="function-logf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions compute the natural logarithm of &lt;VAR&gt;x&lt;/VAR&gt;.  &lt;CODE&gt;exp (log
         (&lt;VAR&gt;x&lt;/VAR&gt;))&lt;/CODE&gt; equals &lt;VAR&gt;x&lt;/VAR&gt;, exactly in mathematics and approximately in
         C.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;x&lt;/VAR&gt; is negative, &lt;CODE&gt;log&lt;/CODE&gt; signals a domain error.  If &lt;VAR&gt;x&lt;/VAR&gt;
         is zero, it returns negative infinity; if &lt;VAR&gt;x&lt;/VAR&gt; is too close to zero,
         it may signal overflow.
        </synopsis>
    </function>
  </construct>
  <construct id="function-logl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions compute the natural logarithm of &lt;VAR&gt;x&lt;/VAR&gt;.  &lt;CODE&gt;exp (log
         (&lt;VAR&gt;x&lt;/VAR&gt;))&lt;/CODE&gt; equals &lt;VAR&gt;x&lt;/VAR&gt;, exactly in mathematics and approximately in
         C.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;x&lt;/VAR&gt; is negative, &lt;CODE&gt;log&lt;/CODE&gt; signals a domain error.  If &lt;VAR&gt;x&lt;/VAR&gt;
         is zero, it returns negative infinity; if &lt;VAR&gt;x&lt;/VAR&gt; is too close to zero,
         it may signal overflow.
        </synopsis>
    </function>
  </construct>
  <construct id="function-log10" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the base-10 logarithm of &lt;VAR&gt;x&lt;/VAR&gt;.
         &lt;CODE&gt;log10 (&lt;VAR&gt;x&lt;/VAR&gt;)&lt;/CODE&gt; equals &lt;CODE&gt;log (&lt;VAR&gt;x&lt;/VAR&gt;) / log (10)&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-log10f" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the base-10 logarithm of &lt;VAR&gt;x&lt;/VAR&gt;.
         &lt;CODE&gt;log10 (&lt;VAR&gt;x&lt;/VAR&gt;)&lt;/CODE&gt; equals &lt;CODE&gt;log (&lt;VAR&gt;x&lt;/VAR&gt;) / log (10)&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-log10l" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the base-10 logarithm of &lt;VAR&gt;x&lt;/VAR&gt;.
         &lt;CODE&gt;log10 (&lt;VAR&gt;x&lt;/VAR&gt;)&lt;/CODE&gt; equals &lt;CODE&gt;log (&lt;VAR&gt;x&lt;/VAR&gt;) / log (10)&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-log2" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the base-2 logarithm of &lt;VAR&gt;x&lt;/VAR&gt;.
         &lt;CODE&gt;log2 (&lt;VAR&gt;x&lt;/VAR&gt;)&lt;/CODE&gt; equals &lt;CODE&gt;log (&lt;VAR&gt;x&lt;/VAR&gt;) / log (2)&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-log2f" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the base-2 logarithm of &lt;VAR&gt;x&lt;/VAR&gt;.
         &lt;CODE&gt;log2 (&lt;VAR&gt;x&lt;/VAR&gt;)&lt;/CODE&gt; equals &lt;CODE&gt;log (&lt;VAR&gt;x&lt;/VAR&gt;) / log (2)&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-log2l" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the base-2 logarithm of &lt;VAR&gt;x&lt;/VAR&gt;.
         &lt;CODE&gt;log2 (&lt;VAR&gt;x&lt;/VAR&gt;)&lt;/CODE&gt; equals &lt;CODE&gt;log (&lt;VAR&gt;x&lt;/VAR&gt;) / log (2)&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-logb" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions extract the exponent of &lt;VAR&gt;x&lt;/VAR&gt; and return it as a
         floating-point value.  If &lt;CODE&gt;FLT_RADIX&lt;/CODE&gt; is two, &lt;CODE&gt;logb&lt;/CODE&gt; is equal
         to &lt;CODE&gt;floor (log2 (x))&lt;/CODE&gt;, except it's probably faster.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;x&lt;/VAR&gt; is de-normalized, &lt;CODE&gt;logb&lt;/CODE&gt; returns the exponent &lt;VAR&gt;x&lt;/VAR&gt;
         would have if it were normalized.  If &lt;VAR&gt;x&lt;/VAR&gt; is infinity (positive or
         negative), &lt;CODE&gt;logb&lt;/CODE&gt; returns infinity{}.  If &lt;VAR&gt;x&lt;/VAR&gt; is zero,
         &lt;CODE&gt;logb&lt;/CODE&gt; returns infinity{}.  It does not signal.
        </synopsis>
    </function>
  </construct>
  <construct id="function-logbf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions extract the exponent of &lt;VAR&gt;x&lt;/VAR&gt; and return it as a
         floating-point value.  If &lt;CODE&gt;FLT_RADIX&lt;/CODE&gt; is two, &lt;CODE&gt;logb&lt;/CODE&gt; is equal
         to &lt;CODE&gt;floor (log2 (x))&lt;/CODE&gt;, except it's probably faster.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;x&lt;/VAR&gt; is de-normalized, &lt;CODE&gt;logb&lt;/CODE&gt; returns the exponent &lt;VAR&gt;x&lt;/VAR&gt;
         would have if it were normalized.  If &lt;VAR&gt;x&lt;/VAR&gt; is infinity (positive or
         negative), &lt;CODE&gt;logb&lt;/CODE&gt; returns infinity{}.  If &lt;VAR&gt;x&lt;/VAR&gt; is zero,
         &lt;CODE&gt;logb&lt;/CODE&gt; returns infinity{}.  It does not signal.
        </synopsis>
    </function>
  </construct>
  <construct id="function-logbl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions extract the exponent of &lt;VAR&gt;x&lt;/VAR&gt; and return it as a
         floating-point value.  If &lt;CODE&gt;FLT_RADIX&lt;/CODE&gt; is two, &lt;CODE&gt;logb&lt;/CODE&gt; is equal
         to &lt;CODE&gt;floor (log2 (x))&lt;/CODE&gt;, except it's probably faster.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;x&lt;/VAR&gt; is de-normalized, &lt;CODE&gt;logb&lt;/CODE&gt; returns the exponent &lt;VAR&gt;x&lt;/VAR&gt;
         would have if it were normalized.  If &lt;VAR&gt;x&lt;/VAR&gt; is infinity (positive or
         negative), &lt;CODE&gt;logb&lt;/CODE&gt; returns infinity{}.  If &lt;VAR&gt;x&lt;/VAR&gt; is zero,
         &lt;CODE&gt;logb&lt;/CODE&gt; returns infinity{}.  It does not signal.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ilogb" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions are equivalent to the corresponding &lt;CODE&gt;logb&lt;/CODE&gt;
         functions except that they return signed integer values.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ilogbf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions are equivalent to the corresponding &lt;CODE&gt;logb&lt;/CODE&gt;
         functions except that they return signed integer values.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ilogbl" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions are equivalent to the corresponding &lt;CODE&gt;logb&lt;/CODE&gt;
         functions except that they return signed integer values.
        </synopsis>
    </function>
  </construct>
  <construct id="function-pow" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double base"/>
        <parameter content="double power"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These are general exponentiation functions, returning &lt;VAR&gt;base&lt;/VAR&gt; raised
         to &lt;VAR&gt;power&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; Mathematically, &lt;CODE&gt;pow&lt;/CODE&gt; would return a complex number when &lt;VAR&gt;base&lt;/VAR&gt;
         is negative and &lt;VAR&gt;power&lt;/VAR&gt; is not an integral value.  &lt;CODE&gt;pow&lt;/CODE&gt; can't
         do that, so instead it signals a domain error. &lt;CODE&gt;pow&lt;/CODE&gt; may also
         underflow or overflow the destination type.
        </synopsis>
    </function>
  </construct>
  <construct id="function-powf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float base"/>
        <parameter content="float power"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These are general exponentiation functions, returning &lt;VAR&gt;base&lt;/VAR&gt; raised
         to &lt;VAR&gt;power&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; Mathematically, &lt;CODE&gt;pow&lt;/CODE&gt; would return a complex number when &lt;VAR&gt;base&lt;/VAR&gt;
         is negative and &lt;VAR&gt;power&lt;/VAR&gt; is not an integral value.  &lt;CODE&gt;pow&lt;/CODE&gt; can't
         do that, so instead it signals a domain error. &lt;CODE&gt;pow&lt;/CODE&gt; may also
         underflow or overflow the destination type.
        </synopsis>
    </function>
  </construct>
  <construct id="function-powl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double base"/>
        <parameter content="long double power"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These are general exponentiation functions, returning &lt;VAR&gt;base&lt;/VAR&gt; raised
         to &lt;VAR&gt;power&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; Mathematically, &lt;CODE&gt;pow&lt;/CODE&gt; would return a complex number when &lt;VAR&gt;base&lt;/VAR&gt;
         is negative and &lt;VAR&gt;power&lt;/VAR&gt; is not an integral value.  &lt;CODE&gt;pow&lt;/CODE&gt; can't
         do that, so instead it signals a domain error. &lt;CODE&gt;pow&lt;/CODE&gt; may also
         underflow or overflow the destination type.
        </synopsis>
    </function>
  </construct>
  <construct id="function-sqrt" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the nonnegative square root of &lt;VAR&gt;x&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;x&lt;/VAR&gt; is negative, &lt;CODE&gt;sqrt&lt;/CODE&gt; signals a domain error.
         Mathematically, it should return a complex number.
        </synopsis>
    </function>
  </construct>
  <construct id="function-sqrtf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the nonnegative square root of &lt;VAR&gt;x&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;x&lt;/VAR&gt; is negative, &lt;CODE&gt;sqrt&lt;/CODE&gt; signals a domain error.
         Mathematically, it should return a complex number.
        </synopsis>
    </function>
  </construct>
  <construct id="function-sqrtl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the nonnegative square root of &lt;VAR&gt;x&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;x&lt;/VAR&gt; is negative, &lt;CODE&gt;sqrt&lt;/CODE&gt; signals a domain error.
         Mathematically, it should return a complex number.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cbrt" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the cube root of &lt;VAR&gt;x&lt;/VAR&gt;.  They cannot
         fail; every representable real value has a representable real cube root.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cbrtf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the cube root of &lt;VAR&gt;x&lt;/VAR&gt;.  They cannot
         fail; every representable real value has a representable real cube root.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cbrtl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the cube root of &lt;VAR&gt;x&lt;/VAR&gt;.  They cannot
         fail; every representable real value has a representable real cube root.
        </synopsis>
    </function>
  </construct>
  <construct id="function-hypot" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
        <parameter content="double y"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return &lt;CODE&gt;sqrt (&lt;VAR&gt;x&lt;/VAR&gt;*&lt;VAR&gt;x&lt;/VAR&gt; +
         &lt;VAR&gt;y&lt;/VAR&gt;*&lt;VAR&gt;y&lt;/VAR&gt;)&lt;/CODE&gt;.  This is the length of the hypotenuse of a right
         triangle with sides of length &lt;VAR&gt;x&lt;/VAR&gt; and &lt;VAR&gt;y&lt;/VAR&gt;, or the distance
         of the point (&lt;VAR&gt;x&lt;/VAR&gt;, &lt;VAR&gt;y&lt;/VAR&gt;) from the origin.  Using this function
         instead of the direct formula is wise, since the error is
         much smaller.  See also the function &lt;CODE&gt;cabs&lt;/CODE&gt; in Absolute Value.
        </synopsis>
    </function>
  </construct>
  <construct id="function-hypotf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
        <parameter content="float y"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return &lt;CODE&gt;sqrt (&lt;VAR&gt;x&lt;/VAR&gt;*&lt;VAR&gt;x&lt;/VAR&gt; +
         &lt;VAR&gt;y&lt;/VAR&gt;*&lt;VAR&gt;y&lt;/VAR&gt;)&lt;/CODE&gt;.  This is the length of the hypotenuse of a right
         triangle with sides of length &lt;VAR&gt;x&lt;/VAR&gt; and &lt;VAR&gt;y&lt;/VAR&gt;, or the distance
         of the point (&lt;VAR&gt;x&lt;/VAR&gt;, &lt;VAR&gt;y&lt;/VAR&gt;) from the origin.  Using this function
         instead of the direct formula is wise, since the error is
         much smaller.  See also the function &lt;CODE&gt;cabs&lt;/CODE&gt; in Absolute Value.
        </synopsis>
    </function>
  </construct>
  <construct id="function-hypotl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
        <parameter content="long double y"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return &lt;CODE&gt;sqrt (&lt;VAR&gt;x&lt;/VAR&gt;*&lt;VAR&gt;x&lt;/VAR&gt; +
         &lt;VAR&gt;y&lt;/VAR&gt;*&lt;VAR&gt;y&lt;/VAR&gt;)&lt;/CODE&gt;.  This is the length of the hypotenuse of a right
         triangle with sides of length &lt;VAR&gt;x&lt;/VAR&gt; and &lt;VAR&gt;y&lt;/VAR&gt;, or the distance
         of the point (&lt;VAR&gt;x&lt;/VAR&gt;, &lt;VAR&gt;y&lt;/VAR&gt;) from the origin.  Using this function
         instead of the direct formula is wise, since the error is
         much smaller.  See also the function &lt;CODE&gt;cabs&lt;/CODE&gt; in Absolute Value.
        </synopsis>
    </function>
  </construct>
  <construct id="function-expm1" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return a value equivalent to &lt;CODE&gt;exp (&lt;VAR&gt;x&lt;/VAR&gt;) - 1&lt;/CODE&gt;.
         They are computed in a way that is accurate even if &lt;VAR&gt;x&lt;/VAR&gt; is
         near zero---a case where &lt;CODE&gt;exp (&lt;VAR&gt;x&lt;/VAR&gt;) - 1&lt;/CODE&gt; would be inaccurate owing
         to subtraction of two numbers that are nearly equal.
        </synopsis>
    </function>
  </construct>
  <construct id="function-expm1f" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return a value equivalent to &lt;CODE&gt;exp (&lt;VAR&gt;x&lt;/VAR&gt;) - 1&lt;/CODE&gt;.
         They are computed in a way that is accurate even if &lt;VAR&gt;x&lt;/VAR&gt; is
         near zero---a case where &lt;CODE&gt;exp (&lt;VAR&gt;x&lt;/VAR&gt;) - 1&lt;/CODE&gt; would be inaccurate owing
         to subtraction of two numbers that are nearly equal.
        </synopsis>
    </function>
  </construct>
  <construct id="function-expm1l" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return a value equivalent to &lt;CODE&gt;exp (&lt;VAR&gt;x&lt;/VAR&gt;) - 1&lt;/CODE&gt;.
         They are computed in a way that is accurate even if &lt;VAR&gt;x&lt;/VAR&gt; is
         near zero---a case where &lt;CODE&gt;exp (&lt;VAR&gt;x&lt;/VAR&gt;) - 1&lt;/CODE&gt; would be inaccurate owing
         to subtraction of two numbers that are nearly equal.
        </synopsis>
    </function>
  </construct>
  <construct id="function-log1p" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions returns a value equivalent to &lt;CODE&gt;log (1 + &lt;VAR&gt;x&lt;/VAR&gt;)&lt;/CODE&gt;.
         They are computed in a way that is accurate even if &lt;VAR&gt;x&lt;/VAR&gt; is
         near zero.
        </synopsis>
    </function>
  </construct>
  <construct id="function-log1pf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions returns a value equivalent to &lt;CODE&gt;log (1 + &lt;VAR&gt;x&lt;/VAR&gt;)&lt;/CODE&gt;.
         They are computed in a way that is accurate even if &lt;VAR&gt;x&lt;/VAR&gt; is
         near zero.
        </synopsis>
    </function>
  </construct>
  <construct id="function-log1pl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions returns a value equivalent to &lt;CODE&gt;log (1 + &lt;VAR&gt;x&lt;/VAR&gt;)&lt;/CODE&gt;.
         They are computed in a way that is accurate even if &lt;VAR&gt;x&lt;/VAR&gt; is
         near zero.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cexp" type="function">
    <function returntype="complex double">
      <prototype>
        <parameter content="complex double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return &lt;CODE&gt;e&lt;/CODE&gt; (the base of natural
         logarithms) raised to the power of &lt;VAR&gt;z&lt;/VAR&gt;.
         Mathematically, this corresponds to the value
         &lt;br&gt;&lt;br&gt;
         exp (z) = exp (creal (z)) * (cos (cimag (z)) + I * sin (cimag (z)))


        </synopsis>
    </function>
  </construct>
  <construct id="function-cexpf" type="function">
    <function returntype="complex float">
      <prototype>
        <parameter content="complex float z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return &lt;CODE&gt;e&lt;/CODE&gt; (the base of natural
         logarithms) raised to the power of &lt;VAR&gt;z&lt;/VAR&gt;.
         Mathematically, this corresponds to the value
         &lt;br&gt;&lt;br&gt;
         exp (z) = exp (creal (z)) * (cos (cimag (z)) + I * sin (cimag (z)))


        </synopsis>
    </function>
  </construct>
  <construct id="function-cexpl" type="function">
    <function returntype="complex long double">
      <prototype>
        <parameter content="complex long double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return &lt;CODE&gt;e&lt;/CODE&gt; (the base of natural
         logarithms) raised to the power of &lt;VAR&gt;z&lt;/VAR&gt;.
         Mathematically, this corresponds to the value
         &lt;br&gt;&lt;br&gt;
         exp (z) = exp (creal (z)) * (cos (cimag (z)) + I * sin (cimag (z)))


        </synopsis>
    </function>
  </construct>
  <construct id="function-clog" type="function">
    <function returntype="complex double">
      <prototype>
        <parameter content="complex double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the natural logarithm of &lt;VAR&gt;z&lt;/VAR&gt;.
         Mathematically, this corresponds to the value
         &lt;br&gt;&lt;br&gt;
         log (z) = log (cabs (z)) + I * carg (z)


         &lt;br&gt;&lt;br&gt;
         &lt;CODE&gt;clog&lt;/CODE&gt; has a pole at 0, and will signal overflow if &lt;VAR&gt;z&lt;/VAR&gt; equals
         or is very close to 0.  It is well-defined for all other values of
         &lt;VAR&gt;z&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-clogf" type="function">
    <function returntype="complex float">
      <prototype>
        <parameter content="complex float z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the natural logarithm of &lt;VAR&gt;z&lt;/VAR&gt;.
         Mathematically, this corresponds to the value
         &lt;br&gt;&lt;br&gt;
         log (z) = log (cabs (z)) + I * carg (z)


         &lt;br&gt;&lt;br&gt;
         &lt;CODE&gt;clog&lt;/CODE&gt; has a pole at 0, and will signal overflow if &lt;VAR&gt;z&lt;/VAR&gt; equals
         or is very close to 0.  It is well-defined for all other values of
         &lt;VAR&gt;z&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-clogl" type="function">
    <function returntype="complex long double">
      <prototype>
        <parameter content="complex long double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the natural logarithm of &lt;VAR&gt;z&lt;/VAR&gt;.
         Mathematically, this corresponds to the value
         &lt;br&gt;&lt;br&gt;
         log (z) = log (cabs (z)) + I * carg (z)


         &lt;br&gt;&lt;br&gt;
         &lt;CODE&gt;clog&lt;/CODE&gt; has a pole at 0, and will signal overflow if &lt;VAR&gt;z&lt;/VAR&gt; equals
         or is very close to 0.  It is well-defined for all other values of
         &lt;VAR&gt;z&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-clog10" type="function">
    <function returntype="complex double">
      <prototype>
        <parameter content="complex double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the base 10 logarithm of the complex value
         &lt;VAR&gt;z&lt;/VAR&gt;. Mathematically, this corresponds to the value
         &lt;br&gt;&lt;br&gt;
         log (z) = log10 (cabs (z)) + I * carg (z)


         &lt;br&gt;&lt;br&gt; These functions are GNU extensions.
        </synopsis>
    </function>
  </construct>
  <construct id="function-clog10f" type="function">
    <function returntype="complex float">
      <prototype>
        <parameter content="complex float z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the base 10 logarithm of the complex value
         &lt;VAR&gt;z&lt;/VAR&gt;. Mathematically, this corresponds to the value
         &lt;br&gt;&lt;br&gt;
         log (z) = log10 (cabs (z)) + I * carg (z)


         &lt;br&gt;&lt;br&gt; These functions are GNU extensions.
        </synopsis>
    </function>
  </construct>
  <construct id="function-clog10l" type="function">
    <function returntype="complex long double">
      <prototype>
        <parameter content="complex long double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the base 10 logarithm of the complex value
         &lt;VAR&gt;z&lt;/VAR&gt;. Mathematically, this corresponds to the value
         &lt;br&gt;&lt;br&gt;
         log (z) = log10 (cabs (z)) + I * carg (z)


         &lt;br&gt;&lt;br&gt; These functions are GNU extensions.
        </synopsis>
    </function>
  </construct>
  <construct id="function-csqrt" type="function">
    <function returntype="complex double">
      <prototype>
        <parameter content="complex double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the complex square root of the argument &lt;VAR&gt;z&lt;/VAR&gt;.  Unlike
         the real-valued functions, they are defined for all values of &lt;VAR&gt;z&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-csqrtf" type="function">
    <function returntype="complex float">
      <prototype>
        <parameter content="complex float z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the complex square root of the argument &lt;VAR&gt;z&lt;/VAR&gt;.  Unlike
         the real-valued functions, they are defined for all values of &lt;VAR&gt;z&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-csqrtl" type="function">
    <function returntype="complex long double">
      <prototype>
        <parameter content="complex long double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the complex square root of the argument &lt;VAR&gt;z&lt;/VAR&gt;.  Unlike
         the real-valued functions, they are defined for all values of &lt;VAR&gt;z&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cpow" type="function">
    <function returntype="complex double">
      <prototype>
        <parameter content="complex double base"/>
        <parameter content="complex double power"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return &lt;VAR&gt;base&lt;/VAR&gt; raised to the power of
         &lt;VAR&gt;power&lt;/VAR&gt;.  This is equivalent to &lt;CODE&gt;cexp (y * clog (x))&lt;/CODE&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-cpowf" type="function">
    <function returntype="complex float">
      <prototype>
        <parameter content="complex float base"/>
        <parameter content="complex float power"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return &lt;VAR&gt;base&lt;/VAR&gt; raised to the power of
         &lt;VAR&gt;power&lt;/VAR&gt;.  This is equivalent to &lt;CODE&gt;cexp (y * clog (x))&lt;/CODE&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-cpowl" type="function">
    <function returntype="complex long double">
      <prototype>
        <parameter content="complex long double base"/>
        <parameter content="complex long double power"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return &lt;VAR&gt;base&lt;/VAR&gt; raised to the power of
         &lt;VAR&gt;power&lt;/VAR&gt;.  This is equivalent to &lt;CODE&gt;cexp (y * clog (x))&lt;/CODE&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-sinh" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the hyperbolic sine of &lt;VAR&gt;x&lt;/VAR&gt;, defined
         mathematically as &lt;CODE&gt;(exp (&lt;VAR&gt;x&lt;/VAR&gt;) - exp (-&lt;VAR&gt;x&lt;/VAR&gt;)) / 2&lt;/CODE&gt;.  They
         may signal overflow if &lt;VAR&gt;x&lt;/VAR&gt; is too large.
        </synopsis>
    </function>
  </construct>
  <construct id="function-sinhf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the hyperbolic sine of &lt;VAR&gt;x&lt;/VAR&gt;, defined
         mathematically as &lt;CODE&gt;(exp (&lt;VAR&gt;x&lt;/VAR&gt;) - exp (-&lt;VAR&gt;x&lt;/VAR&gt;)) / 2&lt;/CODE&gt;.  They
         may signal overflow if &lt;VAR&gt;x&lt;/VAR&gt; is too large.
        </synopsis>
    </function>
  </construct>
  <construct id="function-sinhl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the hyperbolic sine of &lt;VAR&gt;x&lt;/VAR&gt;, defined
         mathematically as &lt;CODE&gt;(exp (&lt;VAR&gt;x&lt;/VAR&gt;) - exp (-&lt;VAR&gt;x&lt;/VAR&gt;)) / 2&lt;/CODE&gt;.  They
         may signal overflow if &lt;VAR&gt;x&lt;/VAR&gt; is too large.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cosh" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These function return the hyperbolic cosine of &lt;VAR&gt;x&lt;/VAR&gt;,
         defined mathematically as &lt;CODE&gt;(exp (&lt;VAR&gt;x&lt;/VAR&gt;) + exp (-&lt;VAR&gt;x&lt;/VAR&gt;)) / 2&lt;/CODE&gt;.
         They may signal overflow if &lt;VAR&gt;x&lt;/VAR&gt; is too large.
        </synopsis>
    </function>
  </construct>
  <construct id="function-coshf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These function return the hyperbolic cosine of &lt;VAR&gt;x&lt;/VAR&gt;,
         defined mathematically as &lt;CODE&gt;(exp (&lt;VAR&gt;x&lt;/VAR&gt;) + exp (-&lt;VAR&gt;x&lt;/VAR&gt;)) / 2&lt;/CODE&gt;.
         They may signal overflow if &lt;VAR&gt;x&lt;/VAR&gt; is too large.
        </synopsis>
    </function>
  </construct>
  <construct id="function-coshl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These function return the hyperbolic cosine of &lt;VAR&gt;x&lt;/VAR&gt;,
         defined mathematically as &lt;CODE&gt;(exp (&lt;VAR&gt;x&lt;/VAR&gt;) + exp (-&lt;VAR&gt;x&lt;/VAR&gt;)) / 2&lt;/CODE&gt;.
         They may signal overflow if &lt;VAR&gt;x&lt;/VAR&gt; is too large.
        </synopsis>
    </function>
  </construct>
  <construct id="function-tanh" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the hyperbolic tangent of &lt;VAR&gt;x&lt;/VAR&gt;,
         defined mathematically as &lt;CODE&gt;sinh (&lt;VAR&gt;x&lt;/VAR&gt;) / cosh (&lt;VAR&gt;x&lt;/VAR&gt;)&lt;/CODE&gt;.
         They may signal overflow if &lt;VAR&gt;x&lt;/VAR&gt; is too large.
        </synopsis>
    </function>
  </construct>
  <construct id="function-tanhf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the hyperbolic tangent of &lt;VAR&gt;x&lt;/VAR&gt;,
         defined mathematically as &lt;CODE&gt;sinh (&lt;VAR&gt;x&lt;/VAR&gt;) / cosh (&lt;VAR&gt;x&lt;/VAR&gt;)&lt;/CODE&gt;.
         They may signal overflow if &lt;VAR&gt;x&lt;/VAR&gt; is too large.
        </synopsis>
    </function>
  </construct>
  <construct id="function-tanhl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the hyperbolic tangent of &lt;VAR&gt;x&lt;/VAR&gt;,
         defined mathematically as &lt;CODE&gt;sinh (&lt;VAR&gt;x&lt;/VAR&gt;) / cosh (&lt;VAR&gt;x&lt;/VAR&gt;)&lt;/CODE&gt;.
         They may signal overflow if &lt;VAR&gt;x&lt;/VAR&gt; is too large.
        </synopsis>
    </function>
  </construct>
  <construct id="function-csinh" type="function">
    <function returntype="complex double">
      <prototype>
        <parameter content="complex double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the complex hyperbolic sine of &lt;VAR&gt;z&lt;/VAR&gt;, defined
         mathematically as &lt;CODE&gt;(exp (&lt;VAR&gt;z&lt;/VAR&gt;) - exp (-&lt;VAR&gt;z&lt;/VAR&gt;)) / 2&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-csinhf" type="function">
    <function returntype="complex float">
      <prototype>
        <parameter content="complex float z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the complex hyperbolic sine of &lt;VAR&gt;z&lt;/VAR&gt;, defined
         mathematically as &lt;CODE&gt;(exp (&lt;VAR&gt;z&lt;/VAR&gt;) - exp (-&lt;VAR&gt;z&lt;/VAR&gt;)) / 2&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-csinhl" type="function">
    <function returntype="complex long double">
      <prototype>
        <parameter content="complex long double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the complex hyperbolic sine of &lt;VAR&gt;z&lt;/VAR&gt;, defined
         mathematically as &lt;CODE&gt;(exp (&lt;VAR&gt;z&lt;/VAR&gt;) - exp (-&lt;VAR&gt;z&lt;/VAR&gt;)) / 2&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ccosh" type="function">
    <function returntype="complex double">
      <prototype>
        <parameter content="complex double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the complex hyperbolic cosine of &lt;VAR&gt;z&lt;/VAR&gt;, defined
         mathematically as &lt;CODE&gt;(exp (&lt;VAR&gt;z&lt;/VAR&gt;) + exp (-&lt;VAR&gt;z&lt;/VAR&gt;)) / 2&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ccoshf" type="function">
    <function returntype="complex float">
      <prototype>
        <parameter content="complex float z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the complex hyperbolic cosine of &lt;VAR&gt;z&lt;/VAR&gt;, defined
         mathematically as &lt;CODE&gt;(exp (&lt;VAR&gt;z&lt;/VAR&gt;) + exp (-&lt;VAR&gt;z&lt;/VAR&gt;)) / 2&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ccoshl" type="function">
    <function returntype="complex long double">
      <prototype>
        <parameter content="complex long double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the complex hyperbolic cosine of &lt;VAR&gt;z&lt;/VAR&gt;, defined
         mathematically as &lt;CODE&gt;(exp (&lt;VAR&gt;z&lt;/VAR&gt;) + exp (-&lt;VAR&gt;z&lt;/VAR&gt;)) / 2&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ctanh" type="function">
    <function returntype="complex double">
      <prototype>
        <parameter content="complex double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the complex hyperbolic tangent of &lt;VAR&gt;z&lt;/VAR&gt;,
         defined mathematically as &lt;CODE&gt;csinh (&lt;VAR&gt;z&lt;/VAR&gt;) / ccosh (&lt;VAR&gt;z&lt;/VAR&gt;)&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ctanhf" type="function">
    <function returntype="complex float">
      <prototype>
        <parameter content="complex float z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the complex hyperbolic tangent of &lt;VAR&gt;z&lt;/VAR&gt;,
         defined mathematically as &lt;CODE&gt;csinh (&lt;VAR&gt;z&lt;/VAR&gt;) / ccosh (&lt;VAR&gt;z&lt;/VAR&gt;)&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ctanhl" type="function">
    <function returntype="complex long double">
      <prototype>
        <parameter content="complex long double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the complex hyperbolic tangent of &lt;VAR&gt;z&lt;/VAR&gt;,
         defined mathematically as &lt;CODE&gt;csinh (&lt;VAR&gt;z&lt;/VAR&gt;) / ccosh (&lt;VAR&gt;z&lt;/VAR&gt;)&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-asinh" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the inverse hyperbolic sine of &lt;VAR&gt;x&lt;/VAR&gt;---the
         value whose hyperbolic sine is &lt;VAR&gt;x&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-asinhf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the inverse hyperbolic sine of &lt;VAR&gt;x&lt;/VAR&gt;---the
         value whose hyperbolic sine is &lt;VAR&gt;x&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-asinhl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the inverse hyperbolic sine of &lt;VAR&gt;x&lt;/VAR&gt;---the
         value whose hyperbolic sine is &lt;VAR&gt;x&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-acosh" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the inverse hyperbolic cosine of &lt;VAR&gt;x&lt;/VAR&gt;---the
         value whose hyperbolic cosine is &lt;VAR&gt;x&lt;/VAR&gt;.  If &lt;VAR&gt;x&lt;/VAR&gt; is less than
         &lt;CODE&gt;1&lt;/CODE&gt;, &lt;CODE&gt;acosh&lt;/CODE&gt; signals a domain error.
        </synopsis>
    </function>
  </construct>
  <construct id="function-acoshf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the inverse hyperbolic cosine of &lt;VAR&gt;x&lt;/VAR&gt;---the
         value whose hyperbolic cosine is &lt;VAR&gt;x&lt;/VAR&gt;.  If &lt;VAR&gt;x&lt;/VAR&gt; is less than
         &lt;CODE&gt;1&lt;/CODE&gt;, &lt;CODE&gt;acosh&lt;/CODE&gt; signals a domain error.
        </synopsis>
    </function>
  </construct>
  <construct id="function-acoshl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the inverse hyperbolic cosine of &lt;VAR&gt;x&lt;/VAR&gt;---the
         value whose hyperbolic cosine is &lt;VAR&gt;x&lt;/VAR&gt;.  If &lt;VAR&gt;x&lt;/VAR&gt; is less than
         &lt;CODE&gt;1&lt;/CODE&gt;, &lt;CODE&gt;acosh&lt;/CODE&gt; signals a domain error.
        </synopsis>
    </function>
  </construct>
  <construct id="function-atanh" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the inverse hyperbolic tangent of &lt;VAR&gt;x&lt;/VAR&gt;---the
         value whose hyperbolic tangent is &lt;VAR&gt;x&lt;/VAR&gt;.  If the absolute value of
         &lt;VAR&gt;x&lt;/VAR&gt; is greater than &lt;CODE&gt;1&lt;/CODE&gt;, &lt;CODE&gt;atanh&lt;/CODE&gt; signals a domain error;
         if it is equal to 1, &lt;CODE&gt;atanh&lt;/CODE&gt; returns infinity.
        </synopsis>
    </function>
  </construct>
  <construct id="function-atanhf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the inverse hyperbolic tangent of &lt;VAR&gt;x&lt;/VAR&gt;---the
         value whose hyperbolic tangent is &lt;VAR&gt;x&lt;/VAR&gt;.  If the absolute value of
         &lt;VAR&gt;x&lt;/VAR&gt; is greater than &lt;CODE&gt;1&lt;/CODE&gt;, &lt;CODE&gt;atanh&lt;/CODE&gt; signals a domain error;
         if it is equal to 1, &lt;CODE&gt;atanh&lt;/CODE&gt; returns infinity.
        </synopsis>
    </function>
  </construct>
  <construct id="function-atanhl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions return the inverse hyperbolic tangent of &lt;VAR&gt;x&lt;/VAR&gt;---the
         value whose hyperbolic tangent is &lt;VAR&gt;x&lt;/VAR&gt;.  If the absolute value of
         &lt;VAR&gt;x&lt;/VAR&gt; is greater than &lt;CODE&gt;1&lt;/CODE&gt;, &lt;CODE&gt;atanh&lt;/CODE&gt; signals a domain error;
         if it is equal to 1, &lt;CODE&gt;atanh&lt;/CODE&gt; returns infinity.
        </synopsis>
    </function>
  </construct>
  <construct id="function-casinh" type="function">
    <function returntype="complex double">
      <prototype>
        <parameter content="complex double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the inverse complex hyperbolic sine of
         &lt;VAR&gt;z&lt;/VAR&gt;---the value whose complex hyperbolic sine is &lt;VAR&gt;z&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-casinhf" type="function">
    <function returntype="complex float">
      <prototype>
        <parameter content="complex float z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the inverse complex hyperbolic sine of
         &lt;VAR&gt;z&lt;/VAR&gt;---the value whose complex hyperbolic sine is &lt;VAR&gt;z&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-casinhl" type="function">
    <function returntype="complex long double">
      <prototype>
        <parameter content="complex long double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the inverse complex hyperbolic sine of
         &lt;VAR&gt;z&lt;/VAR&gt;---the value whose complex hyperbolic sine is &lt;VAR&gt;z&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cacosh" type="function">
    <function returntype="complex double">
      <prototype>
        <parameter content="complex double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the inverse complex hyperbolic cosine of
         &lt;VAR&gt;z&lt;/VAR&gt;---the value whose complex hyperbolic cosine is &lt;VAR&gt;z&lt;/VAR&gt;.  Unlike
         the real-valued functions, there are no restrictions on the value of &lt;VAR&gt;z&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cacoshf" type="function">
    <function returntype="complex float">
      <prototype>
        <parameter content="complex float z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the inverse complex hyperbolic cosine of
         &lt;VAR&gt;z&lt;/VAR&gt;---the value whose complex hyperbolic cosine is &lt;VAR&gt;z&lt;/VAR&gt;.  Unlike
         the real-valued functions, there are no restrictions on the value of &lt;VAR&gt;z&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-cacoshl" type="function">
    <function returntype="complex long double">
      <prototype>
        <parameter content="complex long double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the inverse complex hyperbolic cosine of
         &lt;VAR&gt;z&lt;/VAR&gt;---the value whose complex hyperbolic cosine is &lt;VAR&gt;z&lt;/VAR&gt;.  Unlike
         the real-valued functions, there are no restrictions on the value of &lt;VAR&gt;z&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-catanh" type="function">
    <function returntype="complex double">
      <prototype>
        <parameter content="complex double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the inverse complex hyperbolic tangent of
         &lt;VAR&gt;z&lt;/VAR&gt;---the value whose complex hyperbolic tangent is &lt;VAR&gt;z&lt;/VAR&gt;.  Unlike
         the real-valued functions, there are no restrictions on the value of
         &lt;VAR&gt;z&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-catanhf" type="function">
    <function returntype="complex float">
      <prototype>
        <parameter content="complex float z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the inverse complex hyperbolic tangent of
         &lt;VAR&gt;z&lt;/VAR&gt;---the value whose complex hyperbolic tangent is &lt;VAR&gt;z&lt;/VAR&gt;.  Unlike
         the real-valued functions, there are no restrictions on the value of
         &lt;VAR&gt;z&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-catanhl" type="function">
    <function returntype="complex long double">
      <prototype>
        <parameter content="complex long double z"/>
      </prototype>
      <headers>
        <header filename = "complex.h"/>
      </headers>
        <synopsis>
        These functions return the inverse complex hyperbolic tangent of
         &lt;VAR&gt;z&lt;/VAR&gt;---the value whose complex hyperbolic tangent is &lt;VAR&gt;z&lt;/VAR&gt;.  Unlike
         the real-valued functions, there are no restrictions on the value of
         &lt;VAR&gt;z&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-erf" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;erf&lt;/CODE&gt; returns the error function of &lt;VAR&gt;x&lt;/VAR&gt;.  The error
         function is defined as


         &lt;pre&gt;&lt;br&gt;
         erf (x) = 2/sqrt(pi) * integral from 0 to x of exp(-t^2) dt&lt;br&gt;
         &lt;/pre&gt;

        </synopsis>
    </function>
  </construct>
  <construct id="function-erff" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;erf&lt;/CODE&gt; returns the error function of &lt;VAR&gt;x&lt;/VAR&gt;.  The error
         function is defined as


         &lt;pre&gt;&lt;br&gt;
         erf (x) = 2/sqrt(pi) * integral from 0 to x of exp(-t^2) dt&lt;br&gt;
         &lt;/pre&gt;

        </synopsis>
    </function>
  </construct>
  <construct id="function-erfl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;erf&lt;/CODE&gt; returns the error function of &lt;VAR&gt;x&lt;/VAR&gt;.  The error
         function is defined as


         &lt;pre&gt;&lt;br&gt;
         erf (x) = 2/sqrt(pi) * integral from 0 to x of exp(-t^2) dt&lt;br&gt;
         &lt;/pre&gt;

        </synopsis>
    </function>
  </construct>
  <construct id="function-erfc" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;erfc&lt;/CODE&gt; returns &lt;CODE&gt;1.0 - erf(&lt;VAR&gt;x&lt;/VAR&gt;)&lt;/CODE&gt;, but computed in a
         fashion that avoids round-off error when &lt;VAR&gt;x&lt;/VAR&gt; is large.
        </synopsis>
    </function>
  </construct>
  <construct id="function-erfcf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;erfc&lt;/CODE&gt; returns &lt;CODE&gt;1.0 - erf(&lt;VAR&gt;x&lt;/VAR&gt;)&lt;/CODE&gt;, but computed in a
         fashion that avoids round-off error when &lt;VAR&gt;x&lt;/VAR&gt; is large.
        </synopsis>
    </function>
  </construct>
  <construct id="function-erfcl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;erfc&lt;/CODE&gt; returns &lt;CODE&gt;1.0 - erf(&lt;VAR&gt;x&lt;/VAR&gt;)&lt;/CODE&gt;, but computed in a
         fashion that avoids round-off error when &lt;VAR&gt;x&lt;/VAR&gt; is large.
        </synopsis>
    </function>
  </construct>
  <construct id="function-lgamma" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;lgamma&lt;/CODE&gt; returns the natural logarithm of the absolute value of
         the gamma function of &lt;VAR&gt;x&lt;/VAR&gt;.  The gamma function is defined as


         &lt;pre&gt;&lt;br&gt;
         gamma (x) = integral from 0 to infinity{} of t^(x-1) e^-t dt&lt;br&gt;
         &lt;/pre&gt;&lt;br&gt;
         &lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;br&gt;
         The sign of the gamma function is stored in the global variable&lt;br&gt;
         &lt;VAR&gt;signgam&lt;/VAR&gt;, which is declared in &lt;TT&gt;math.h&lt;/TT&gt;.  It is &lt;CODE&gt;1&lt;/CODE&gt; if&lt;br&gt;
         the intermediate result was positive or zero, or &lt;CODE&gt;-1&lt;/CODE&gt; if it was&lt;br&gt;
         negative.&lt;br&gt;
         &lt;br&gt;&lt;br&gt; To compute the real gamma function you can use the &lt;CODE&gt;tgamma&lt;/CODE&gt;&lt;br&gt;
         function or you can compute the values as follows:&lt;br&gt;
         &lt;pre&gt;&lt;br&gt;
         lgam = lgamma(x);&lt;br&gt;
         gam  = signgam*exp(lgam);&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; The gamma function has singularities at the non-positive integers.
         &lt;CODE&gt;lgamma&lt;/CODE&gt; will raise the zero divide exception if evaluated at a
         singularity.
        </synopsis>
    </function>
  </construct>
  <construct id="function-lgammaf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;lgamma&lt;/CODE&gt; returns the natural logarithm of the absolute value of
         the gamma function of &lt;VAR&gt;x&lt;/VAR&gt;.  The gamma function is defined as


         &lt;pre&gt;&lt;br&gt;
         gamma (x) = integral from 0 to infinity{} of t^(x-1) e^-t dt&lt;br&gt;
         &lt;/pre&gt;&lt;br&gt;
         &lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;br&gt;
         The sign of the gamma function is stored in the global variable&lt;br&gt;
         &lt;VAR&gt;signgam&lt;/VAR&gt;, which is declared in &lt;TT&gt;math.h&lt;/TT&gt;.  It is &lt;CODE&gt;1&lt;/CODE&gt; if&lt;br&gt;
         the intermediate result was positive or zero, or &lt;CODE&gt;-1&lt;/CODE&gt; if it was&lt;br&gt;
         negative.&lt;br&gt;
         &lt;br&gt;&lt;br&gt; To compute the real gamma function you can use the &lt;CODE&gt;tgamma&lt;/CODE&gt;&lt;br&gt;
         function or you can compute the values as follows:&lt;br&gt;
         &lt;pre&gt;&lt;br&gt;
         lgam = lgamma(x);&lt;br&gt;
         gam  = signgam*exp(lgam);&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; The gamma function has singularities at the non-positive integers.
         &lt;CODE&gt;lgamma&lt;/CODE&gt; will raise the zero divide exception if evaluated at a
         singularity.
        </synopsis>
    </function>
  </construct>
  <construct id="function-lgammal" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;lgamma&lt;/CODE&gt; returns the natural logarithm of the absolute value of
         the gamma function of &lt;VAR&gt;x&lt;/VAR&gt;.  The gamma function is defined as


         &lt;pre&gt;&lt;br&gt;
         gamma (x) = integral from 0 to infinity{} of t^(x-1) e^-t dt&lt;br&gt;
         &lt;/pre&gt;&lt;br&gt;
         &lt;br&gt;
         &lt;br&gt;&lt;br&gt; &lt;br&gt;
         The sign of the gamma function is stored in the global variable&lt;br&gt;
         &lt;VAR&gt;signgam&lt;/VAR&gt;, which is declared in &lt;TT&gt;math.h&lt;/TT&gt;.  It is &lt;CODE&gt;1&lt;/CODE&gt; if&lt;br&gt;
         the intermediate result was positive or zero, or &lt;CODE&gt;-1&lt;/CODE&gt; if it was&lt;br&gt;
         negative.&lt;br&gt;
         &lt;br&gt;&lt;br&gt; To compute the real gamma function you can use the &lt;CODE&gt;tgamma&lt;/CODE&gt;&lt;br&gt;
         function or you can compute the values as follows:&lt;br&gt;
         &lt;pre&gt;&lt;br&gt;
         lgam = lgamma(x);&lt;br&gt;
         gam  = signgam*exp(lgam);&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; The gamma function has singularities at the non-positive integers.
         &lt;CODE&gt;lgamma&lt;/CODE&gt; will raise the zero divide exception if evaluated at a
         singularity.
        </synopsis>
    </function>
  </construct>
  <construct id="function-lgamma_r" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
        <parameter content="int *signp"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;lgamma_r&lt;/CODE&gt; is just like &lt;CODE&gt;lgamma&lt;/CODE&gt;, but it stores the sign of
         the intermediate result in the variable pointed to by &lt;VAR&gt;signp&lt;/VAR&gt;
         instead of in the &lt;VAR&gt;signgam&lt;/VAR&gt; global.  This means it is reentrant.
        </synopsis>
    </function>
  </construct>
  <construct id="function-lgammaf_r" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
        <parameter content="int *signp"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;lgamma_r&lt;/CODE&gt; is just like &lt;CODE&gt;lgamma&lt;/CODE&gt;, but it stores the sign of
         the intermediate result in the variable pointed to by &lt;VAR&gt;signp&lt;/VAR&gt;
         instead of in the &lt;VAR&gt;signgam&lt;/VAR&gt; global.  This means it is reentrant.
        </synopsis>
    </function>
  </construct>
  <construct id="function-lgammal_r" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
        <parameter content="int *signp"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;lgamma_r&lt;/CODE&gt; is just like &lt;CODE&gt;lgamma&lt;/CODE&gt;, but it stores the sign of
         the intermediate result in the variable pointed to by &lt;VAR&gt;signp&lt;/VAR&gt;
         instead of in the &lt;VAR&gt;signgam&lt;/VAR&gt; global.  This means it is reentrant.
        </synopsis>
    </function>
  </construct>
  <construct id="function-gamma" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions exist for compatibility reasons.  They are equivalent to
         &lt;CODE&gt;lgamma&lt;/CODE&gt; etc.  It is better to use &lt;CODE&gt;lgamma&lt;/CODE&gt; since for one the
         name reflects better the actual computation, moreover &lt;CODE&gt;lgamma&lt;/CODE&gt; is
         standardized in ISO C99 while &lt;CODE&gt;gamma&lt;/CODE&gt; is not.
        </synopsis>
    </function>
  </construct>
  <construct id="function-gammaf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions exist for compatibility reasons.  They are equivalent to
         &lt;CODE&gt;lgamma&lt;/CODE&gt; etc.  It is better to use &lt;CODE&gt;lgamma&lt;/CODE&gt; since for one the
         name reflects better the actual computation, moreover &lt;CODE&gt;lgamma&lt;/CODE&gt; is
         standardized in ISO C99 while &lt;CODE&gt;gamma&lt;/CODE&gt; is not.
        </synopsis>
    </function>
  </construct>
  <construct id="function-gammal" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        These functions exist for compatibility reasons.  They are equivalent to
         &lt;CODE&gt;lgamma&lt;/CODE&gt; etc.  It is better to use &lt;CODE&gt;lgamma&lt;/CODE&gt; since for one the
         name reflects better the actual computation, moreover &lt;CODE&gt;lgamma&lt;/CODE&gt; is
         standardized in ISO C99 while &lt;CODE&gt;gamma&lt;/CODE&gt; is not.
        </synopsis>
    </function>
  </construct>
  <construct id="function-tgamma" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;tgamma&lt;/CODE&gt; applies the gamma function to &lt;VAR&gt;x&lt;/VAR&gt;.  The gamma
         function is defined as


         &lt;pre&gt;&lt;br&gt;
         gamma (x) = integral from 0 to infinity{} of t^(x-1) e^-t dt&lt;br&gt;
         &lt;/pre&gt;

         &lt;br&gt;&lt;br&gt; This function was introduced in ISO C99.
        </synopsis>
    </function>
  </construct>
  <construct id="function-tgammaf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;tgamma&lt;/CODE&gt; applies the gamma function to &lt;VAR&gt;x&lt;/VAR&gt;.  The gamma
         function is defined as


         &lt;pre&gt;&lt;br&gt;
         gamma (x) = integral from 0 to infinity{} of t^(x-1) e^-t dt&lt;br&gt;
         &lt;/pre&gt;

         &lt;br&gt;&lt;br&gt; This function was introduced in ISO C99.
        </synopsis>
    </function>
  </construct>
  <construct id="function-tgammal" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;tgamma&lt;/CODE&gt; applies the gamma function to &lt;VAR&gt;x&lt;/VAR&gt;.  The gamma
         function is defined as


         &lt;pre&gt;&lt;br&gt;
         gamma (x) = integral from 0 to infinity{} of t^(x-1) e^-t dt&lt;br&gt;
         &lt;/pre&gt;

         &lt;br&gt;&lt;br&gt; This function was introduced in ISO C99.
        </synopsis>
    </function>
  </construct>
  <construct id="function-j0" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;j0&lt;/CODE&gt; returns the Bessel function of the first kind of order 0 of
         &lt;VAR&gt;x&lt;/VAR&gt;.  It may signal underflow if &lt;VAR&gt;x&lt;/VAR&gt; is too large.
        </synopsis>
    </function>
  </construct>
  <construct id="function-j0f" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;j0&lt;/CODE&gt; returns the Bessel function of the first kind of order 0 of
         &lt;VAR&gt;x&lt;/VAR&gt;.  It may signal underflow if &lt;VAR&gt;x&lt;/VAR&gt; is too large.
        </synopsis>
    </function>
  </construct>
  <construct id="function-j0l" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;j0&lt;/CODE&gt; returns the Bessel function of the first kind of order 0 of
         &lt;VAR&gt;x&lt;/VAR&gt;.  It may signal underflow if &lt;VAR&gt;x&lt;/VAR&gt; is too large.
        </synopsis>
    </function>
  </construct>
  <construct id="function-j1" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;j1&lt;/CODE&gt; returns the Bessel function of the first kind of order 1 of
         &lt;VAR&gt;x&lt;/VAR&gt;.  It may signal underflow if &lt;VAR&gt;x&lt;/VAR&gt; is too large.
        </synopsis>
    </function>
  </construct>
  <construct id="function-j1f" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;j1&lt;/CODE&gt; returns the Bessel function of the first kind of order 1 of
         &lt;VAR&gt;x&lt;/VAR&gt;.  It may signal underflow if &lt;VAR&gt;x&lt;/VAR&gt; is too large.
        </synopsis>
    </function>
  </construct>
  <construct id="function-j1l" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;j1&lt;/CODE&gt; returns the Bessel function of the first kind of order 1 of
         &lt;VAR&gt;x&lt;/VAR&gt;.  It may signal underflow if &lt;VAR&gt;x&lt;/VAR&gt; is too large.
        </synopsis>
    </function>
  </construct>
  <construct id="function-jn" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="int n"/>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;jn&lt;/CODE&gt; returns the Bessel function of the first kind of order
         &lt;VAR&gt;n&lt;/VAR&gt; of &lt;VAR&gt;x&lt;/VAR&gt;.  It may signal underflow if &lt;VAR&gt;x&lt;/VAR&gt; is too large.
        </synopsis>
    </function>
  </construct>
  <construct id="function-jnf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="int n"/>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;jn&lt;/CODE&gt; returns the Bessel function of the first kind of order
         &lt;VAR&gt;n&lt;/VAR&gt; of &lt;VAR&gt;x&lt;/VAR&gt;.  It may signal underflow if &lt;VAR&gt;x&lt;/VAR&gt; is too large.
        </synopsis>
    </function>
  </construct>
  <construct id="function-jnl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="int n"/>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;jn&lt;/CODE&gt; returns the Bessel function of the first kind of order
         &lt;VAR&gt;n&lt;/VAR&gt; of &lt;VAR&gt;x&lt;/VAR&gt;.  It may signal underflow if &lt;VAR&gt;x&lt;/VAR&gt; is too large.
        </synopsis>
    </function>
  </construct>
  <construct id="function-y0" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;y0&lt;/CODE&gt; returns the Bessel function of the second kind of order 0 of
         &lt;VAR&gt;x&lt;/VAR&gt;.  It may signal underflow if &lt;VAR&gt;x&lt;/VAR&gt; is too large.  If &lt;VAR&gt;x&lt;/VAR&gt;
         is negative, &lt;CODE&gt;y0&lt;/CODE&gt; signals a domain error; if it is zero,
         &lt;CODE&gt;y0&lt;/CODE&gt; signals overflow and returns -infinity.
        </synopsis>
    </function>
  </construct>
  <construct id="function-y0f" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;y0&lt;/CODE&gt; returns the Bessel function of the second kind of order 0 of
         &lt;VAR&gt;x&lt;/VAR&gt;.  It may signal underflow if &lt;VAR&gt;x&lt;/VAR&gt; is too large.  If &lt;VAR&gt;x&lt;/VAR&gt;
         is negative, &lt;CODE&gt;y0&lt;/CODE&gt; signals a domain error; if it is zero,
         &lt;CODE&gt;y0&lt;/CODE&gt; signals overflow and returns -infinity.
        </synopsis>
    </function>
  </construct>
  <construct id="function-y0l" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;y0&lt;/CODE&gt; returns the Bessel function of the second kind of order 0 of
         &lt;VAR&gt;x&lt;/VAR&gt;.  It may signal underflow if &lt;VAR&gt;x&lt;/VAR&gt; is too large.  If &lt;VAR&gt;x&lt;/VAR&gt;
         is negative, &lt;CODE&gt;y0&lt;/CODE&gt; signals a domain error; if it is zero,
         &lt;CODE&gt;y0&lt;/CODE&gt; signals overflow and returns -infinity.
        </synopsis>
    </function>
  </construct>
  <construct id="function-y1" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;y1&lt;/CODE&gt; returns the Bessel function of the second kind of order 1 of
         &lt;VAR&gt;x&lt;/VAR&gt;.  It may signal underflow if &lt;VAR&gt;x&lt;/VAR&gt; is too large.  If &lt;VAR&gt;x&lt;/VAR&gt;
         is negative, &lt;CODE&gt;y1&lt;/CODE&gt; signals a domain error; if it is zero,
         &lt;CODE&gt;y1&lt;/CODE&gt; signals overflow and returns -infinity.
        </synopsis>
    </function>
  </construct>
  <construct id="function-y1f" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;y1&lt;/CODE&gt; returns the Bessel function of the second kind of order 1 of
         &lt;VAR&gt;x&lt;/VAR&gt;.  It may signal underflow if &lt;VAR&gt;x&lt;/VAR&gt; is too large.  If &lt;VAR&gt;x&lt;/VAR&gt;
         is negative, &lt;CODE&gt;y1&lt;/CODE&gt; signals a domain error; if it is zero,
         &lt;CODE&gt;y1&lt;/CODE&gt; signals overflow and returns -infinity.
        </synopsis>
    </function>
  </construct>
  <construct id="function-y1l" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;y1&lt;/CODE&gt; returns the Bessel function of the second kind of order 1 of
         &lt;VAR&gt;x&lt;/VAR&gt;.  It may signal underflow if &lt;VAR&gt;x&lt;/VAR&gt; is too large.  If &lt;VAR&gt;x&lt;/VAR&gt;
         is negative, &lt;CODE&gt;y1&lt;/CODE&gt; signals a domain error; if it is zero,
         &lt;CODE&gt;y1&lt;/CODE&gt; signals overflow and returns -infinity.
        </synopsis>
    </function>
  </construct>
  <construct id="function-yn" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="int n"/>
        <parameter content="double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;yn&lt;/CODE&gt; returns the Bessel function of the second kind of order &lt;VAR&gt;n&lt;/VAR&gt; of
         &lt;VAR&gt;x&lt;/VAR&gt;.  It may signal underflow if &lt;VAR&gt;x&lt;/VAR&gt; is too large.  If &lt;VAR&gt;x&lt;/VAR&gt;
         is negative, &lt;CODE&gt;yn&lt;/CODE&gt; signals a domain error; if it is zero,
         &lt;CODE&gt;yn&lt;/CODE&gt; signals overflow and returns -infinity.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ynf" type="function">
    <function returntype="float">
      <prototype>
        <parameter content="int n"/>
        <parameter content="float x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;yn&lt;/CODE&gt; returns the Bessel function of the second kind of order &lt;VAR&gt;n&lt;/VAR&gt; of
         &lt;VAR&gt;x&lt;/VAR&gt;.  It may signal underflow if &lt;VAR&gt;x&lt;/VAR&gt; is too large.  If &lt;VAR&gt;x&lt;/VAR&gt;
         is negative, &lt;CODE&gt;yn&lt;/CODE&gt; signals a domain error; if it is zero,
         &lt;CODE&gt;yn&lt;/CODE&gt; signals overflow and returns -infinity.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ynl" type="function">
    <function returntype="long double">
      <prototype>
        <parameter content="int n"/>
        <parameter content="long double x"/>
      </prototype>
      <headers>
        <header filename = "math.h"/>
      </headers>
        <synopsis>
        &lt;CODE&gt;yn&lt;/CODE&gt; returns the Bessel function of the second kind of order &lt;VAR&gt;n&lt;/VAR&gt; of
         &lt;VAR&gt;x&lt;/VAR&gt;.  It may signal underflow if &lt;VAR&gt;x&lt;/VAR&gt; is too large.  If &lt;VAR&gt;x&lt;/VAR&gt;
         is negative, &lt;CODE&gt;yn&lt;/CODE&gt; signals a domain error; if it is zero,
         &lt;CODE&gt;yn&lt;/CODE&gt; signals overflow and returns -infinity.
        </synopsis>
    </function>
  </construct>
  <construct id="function-rand" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;rand&lt;/CODE&gt; function returns the next pseudo-random number in the
         series.  The value ranges from &lt;CODE&gt;0&lt;/CODE&gt; to &lt;CODE&gt;RAND_MAX&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-srand" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="unsigned int seed"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        This function establishes &lt;VAR&gt;seed&lt;/VAR&gt; as the seed for a new series of
         pseudo-random numbers.  If you call &lt;CODE&gt;rand&lt;/CODE&gt; before a seed has been
         established with &lt;CODE&gt;srand&lt;/CODE&gt;, it uses the value &lt;CODE&gt;1&lt;/CODE&gt; as a default
         seed.
         &lt;br&gt;&lt;br&gt; To produce a different pseudo-random series each time your program is
         run, do &lt;CODE&gt;srand (time (0))&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-rand_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="unsigned int *seed"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        This function returns a random number in the range 0 to &lt;CODE&gt;RAND_MAX&lt;/CODE&gt;
         just as &lt;CODE&gt;rand&lt;/CODE&gt; does.  However, all its state is stored in the
         &lt;VAR&gt;seed&lt;/VAR&gt; argument.  This means the RNG's state can only have as many
         bits as the type &lt;CODE&gt;unsigned int&lt;/CODE&gt; has.  This is far too few to
         provide a good RNG.
         &lt;br&gt;&lt;br&gt; If your program requires a reentrant RNG, we recommend you use the
         reentrant GNU extensions to the SVID random number generator.  The
         POSIX.1 interface should only be used when the GNU extensions are not
         available.
        </synopsis>
    </function>
  </construct>
  <construct id="function-random" type="function">
    <function returntype="long int">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        This function returns the next pseudo-random number in the sequence.
         The value returned ranges from &lt;CODE&gt;0&lt;/CODE&gt; to &lt;CODE&gt;RAND_MAX&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; NB: Temporarily this function was defined to return a
         &lt;CODE&gt;int32_t&lt;/CODE&gt; value to indicate that the return value always contains
         32 bits even if &lt;CODE&gt;long int&lt;/CODE&gt; is wider.  The standard demands it
         differently.  Users must always be aware of the 32-bit limitation,
         though.
        </synopsis>
    </function>
  </construct>
  <construct id="function-srandom" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="unsigned int seed"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;srandom&lt;/CODE&gt; function sets the state of the random number
         generator based on the integer &lt;VAR&gt;seed&lt;/VAR&gt;.  If you supply a &lt;VAR&gt;seed&lt;/VAR&gt; value
         of &lt;CODE&gt;1&lt;/CODE&gt;, this will cause &lt;CODE&gt;random&lt;/CODE&gt; to reproduce the default set
         of random numbers.
         &lt;br&gt;&lt;br&gt; To produce a different set of pseudo-random numbers each time your
         program runs, do &lt;CODE&gt;srandom (time (0))&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-initstate" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="unsigned int seed"/>
        <parameter content="void *state"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;initstate&lt;/CODE&gt; function is used to initialize the random number
         generator state.  The argument &lt;VAR&gt;state&lt;/VAR&gt; is an array of &lt;VAR&gt;size&lt;/VAR&gt;
         bytes, used to hold the state information.  It is initialized based on
         &lt;VAR&gt;seed&lt;/VAR&gt;.  The size must be between 8 and 256 bytes, and should be a
         power of two.  The bigger the &lt;VAR&gt;state&lt;/VAR&gt; array, the better.
         &lt;br&gt;&lt;br&gt; The return value is the previous value of the state information array.
         You can use this value later as an argument to &lt;CODE&gt;setstate&lt;/CODE&gt; to
         restore that state.
        </synopsis>
    </function>
  </construct>
  <construct id="function-setstate" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="void *state"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;setstate&lt;/CODE&gt; function restores the random number state
         information &lt;VAR&gt;state&lt;/VAR&gt;.  The argument must have been the result of
         a previous call to &lt;VAR&gt;initstate&lt;/VAR&gt; or &lt;VAR&gt;setstate&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The return value is the previous value of the state information array.
         You can use this value later as an argument to &lt;CODE&gt;setstate&lt;/CODE&gt; to
         restore that state.
         &lt;br&gt;&lt;br&gt; If the function fails the return value is &lt;CODE&gt;NULL&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-random_data" type="struct">
    <structure>
    </structure>
  </construct>
  <construct id="function-random_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="struct random_data *restrict buf"/>
        <parameter content="int32_t *restrict result"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;random_r&lt;/CODE&gt; function behaves exactly like the &lt;CODE&gt;random&lt;/CODE&gt;
         function except that it uses and modifies the state in the object
         pointed to by the first parameter instead of the global state.
        </synopsis>
    </function>
  </construct>
  <construct id="function-srandom_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="unsigned int seed"/>
        <parameter content="struct random_data *buf"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;srandom_r&lt;/CODE&gt; function behaves exactly like the &lt;CODE&gt;srandom&lt;/CODE&gt;
         function except that it uses and modifies the state in the object
         pointed to by the second parameter instead of the global state.
        </synopsis>
    </function>
  </construct>
  <construct id="function-initstate_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="unsigned int seed"/>
        <parameter content="char *restrict statebuf"/>
        <parameter content="size_t statelen"/>
        <parameter content="struct random_data *restrict buf"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;initstate_r&lt;/CODE&gt; function behaves exactly like the &lt;CODE&gt;initstate&lt;/CODE&gt;
         function except that it uses and modifies the state in the object
         pointed to by the fourth parameter instead of the global state.
        </synopsis>
    </function>
  </construct>
  <construct id="function-setstate_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="char *restrict statebuf"/>
        <parameter content="struct random_data *restrict buf"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;setstate_r&lt;/CODE&gt; function behaves exactly like the &lt;CODE&gt;setstate&lt;/CODE&gt;
         function except that it uses and modifies the state in the object
         pointed to by the first parameter instead of the global state.
        </synopsis>
    </function>
  </construct>
  <construct id="function-drand48" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        This function returns a &lt;CODE&gt;double&lt;/CODE&gt; value in the range of &lt;CODE&gt;0.0&lt;/CODE&gt;
         to &lt;CODE&gt;1.0&lt;/CODE&gt; (exclusive).  The random bits are determined by the global
         state of the random number generator in the C library.
         &lt;br&gt;&lt;br&gt; Since the &lt;CODE&gt;double&lt;/CODE&gt; type according to IEEE 754 has a 52-bit
         mantissa this means 4 bits are not initialized by the random number
         generator.  These are (of course) chosen to be the least significant
         bits and they are initialized to &lt;CODE&gt;0&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-erand48" type="function">
    <function returntype="double">
      <prototype>
        <parameter content="unsigned short int xsubi[3]"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        This function returns a &lt;CODE&gt;double&lt;/CODE&gt; value in the range of &lt;CODE&gt;0.0&lt;/CODE&gt;
         to &lt;CODE&gt;1.0&lt;/CODE&gt; (exclusive), similarly to &lt;CODE&gt;drand48&lt;/CODE&gt;.  The argument is
         an array describing the state of the random number generator.
         &lt;br&gt;&lt;br&gt; This function can be called subsequently since it updates the array to
         guarantee random numbers.  The array should have been initialized before
         initial use to obtain reproducible results.
        </synopsis>
    </function>
  </construct>
  <construct id="function-lrand48" type="function">
    <function returntype="long int">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;lrand48&lt;/CODE&gt; function returns an integer value in the range of
         &lt;CODE&gt;0&lt;/CODE&gt; to &lt;CODE&gt;2^31&lt;/CODE&gt; (exclusive).  Even if the size of the &lt;CODE&gt;long
         int&lt;/CODE&gt; type can take more than 32 bits, no higher numbers are returned.
         The random bits are determined by the global state of the random number
         generator in the C library.
        </synopsis>
    </function>
  </construct>
  <construct id="function-nrand48" type="function">
    <function returntype="long int">
      <prototype>
        <parameter content="unsigned short int xsubi[3]"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        This function is similar to the &lt;CODE&gt;lrand48&lt;/CODE&gt; function in that it
         returns a number in the range of &lt;CODE&gt;0&lt;/CODE&gt; to &lt;CODE&gt;2^31&lt;/CODE&gt; (exclusive) but
         the state of the random number generator used to produce the random bits
         is determined by the array provided as the parameter to the function.
         &lt;br&gt;&lt;br&gt; The numbers in the array are updated afterwards so that subsequent calls
         to this function yield different results (as is expected of a random
         number generator).  The array should have been initialized before the
         first call to obtain reproducible results.
        </synopsis>
    </function>
  </construct>
  <construct id="function-mrand48" type="function">
    <function returntype="long int">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;mrand48&lt;/CODE&gt; function is similar to &lt;CODE&gt;lrand48&lt;/CODE&gt;.  The only
         difference is that the numbers returned are in the range &lt;CODE&gt;-2^31&lt;/CODE&gt; to
         &lt;CODE&gt;2^31&lt;/CODE&gt; (exclusive).
        </synopsis>
    </function>
  </construct>
  <construct id="function-jrand48" type="function">
    <function returntype="long int">
      <prototype>
        <parameter content="unsigned short int xsubi[3]"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;jrand48&lt;/CODE&gt; function is similar to &lt;CODE&gt;nrand48&lt;/CODE&gt;.  The only
         difference is that the numbers returned are in the range &lt;CODE&gt;-2^31&lt;/CODE&gt; to
         &lt;CODE&gt;2^31&lt;/CODE&gt; (exclusive).  For the &lt;CODE&gt;xsubi&lt;/CODE&gt; parameter the same
         requirements are necessary.
        </synopsis>
    </function>
  </construct>
  <construct id="function-srand48" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="long int seedval"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;srand48&lt;/CODE&gt; function sets the most significant 32 bits of the
         internal state of the random number generator to the least
         significant 32 bits of the &lt;VAR&gt;seedval&lt;/VAR&gt; parameter.  The lower 16 bits
         are initialized to the value &lt;CODE&gt;0x330E&lt;/CODE&gt;.  Even if the &lt;CODE&gt;long
         int&lt;/CODE&gt; type contains more than 32 bits only the lower 32 bits are used.
         &lt;br&gt;&lt;br&gt; Owing to this limitation, initialization of the state of this
         function is not very useful.  But it makes it easy to use a construct
         like &lt;CODE&gt;srand48 (time (0))&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; A side-effect of this function is that the values &lt;CODE&gt;a&lt;/CODE&gt; and &lt;CODE&gt;c&lt;/CODE&gt;
         from the internal state, which are used in the congruential formula,
         are reset to the default values given above.  This is of importance once
         the user has called the &lt;CODE&gt;lcong48&lt;/CODE&gt; function (see below).
        </synopsis>
    </function>
  </construct>
  <construct id="function-seed48" type="function">
    <function returntype="unsigned short int *">
      <prototype>
        <parameter content="unsigned short int seed16v[3]"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;seed48&lt;/CODE&gt; function initializes all 48 bits of the state of the
         internal random number generator from the contents of the parameter
         &lt;VAR&gt;seed16v&lt;/VAR&gt;.  Here the lower 16 bits of the first element of
         &lt;VAR&gt;see16v&lt;/VAR&gt; initialize the least significant 16 bits of the internal
         state, the lower 16 bits of &lt;CODE&gt;&lt;VAR&gt;seed16v&lt;/VAR&gt;[1]&lt;/CODE&gt; initialize the mid-order
         16 bits of the state and the 16 lower bits of &lt;CODE&gt;&lt;VAR&gt;seed16v&lt;/VAR&gt;[2]&lt;/CODE&gt;
         initialize the most significant 16 bits of the state.
         &lt;br&gt;&lt;br&gt; Unlike &lt;CODE&gt;srand48&lt;/CODE&gt; this function lets the user initialize all 48 bits
         of the state.
         &lt;br&gt;&lt;br&gt; The value returned by &lt;CODE&gt;seed48&lt;/CODE&gt; is a pointer to an array containing
         the values of the internal state before the change.  This might be
         useful to restart the random number generator at a certain state.
         Otherwise the value can simply be ignored.
         &lt;br&gt;&lt;br&gt; As for &lt;CODE&gt;srand48&lt;/CODE&gt;, the values &lt;CODE&gt;a&lt;/CODE&gt; and &lt;CODE&gt;c&lt;/CODE&gt; from the
         congruential formula are reset to the default values.
        </synopsis>
    </function>
  </construct>
  <construct id="function-lcong48" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="unsigned short int param[7]"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;lcong48&lt;/CODE&gt; function allows the user to change the complete state
         of the random number generator.  Unlike &lt;CODE&gt;srand48&lt;/CODE&gt; and
         &lt;CODE&gt;seed48&lt;/CODE&gt;, this function also changes the constants in the
         congruential formula.
         &lt;br&gt;&lt;br&gt; From the seven elements in the array &lt;VAR&gt;param&lt;/VAR&gt; the least significant
         16 bits of the entries &lt;CODE&gt;&lt;VAR&gt;param&lt;/VAR&gt;[0]&lt;/CODE&gt; to &lt;CODE&gt;&lt;VAR&gt;param&lt;/VAR&gt;[2]&lt;/CODE&gt;
         determine the initial state, the least significant 16 bits of
         &lt;CODE&gt;&lt;VAR&gt;param&lt;/VAR&gt;[3]&lt;/CODE&gt; to &lt;CODE&gt;&lt;VAR&gt;param&lt;/VAR&gt;[5]&lt;/CODE&gt; determine the 48 bit
         constant &lt;CODE&gt;a&lt;/CODE&gt; and &lt;CODE&gt;&lt;VAR&gt;param&lt;/VAR&gt;[6]&lt;/CODE&gt; determines the 16-bit value
         &lt;CODE&gt;c&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-drand48_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="struct drand48_data *buffer"/>
        <parameter content="double *result"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        This function is equivalent to the &lt;CODE&gt;drand48&lt;/CODE&gt; function with the
         difference that it does not modify the global random number generator
         parameters but instead the parameters in the buffer supplied through the
         pointer &lt;VAR&gt;buffer&lt;/VAR&gt;.  The random number is returned in the variable
         pointed to by &lt;VAR&gt;result&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The return value of the function indicates whether the call succeeded.
         If the value is less than &lt;CODE&gt;0&lt;/CODE&gt; an error occurred and &lt;VAR&gt;errno&lt;/VAR&gt; is
         set to indicate the problem.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension and should not be used in portable
         programs.
        </synopsis>
    </function>
  </construct>
  <construct id="function-erand48_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="unsigned short int xsubi[3]"/>
        <parameter content="struct drand48_data *buffer"/>
        <parameter content="double *result"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;erand48_r&lt;/CODE&gt; function works like &lt;CODE&gt;erand48&lt;/CODE&gt;, but in addition
         it takes an argument &lt;VAR&gt;buffer&lt;/VAR&gt; which describes the random number
         generator.  The state of the random number generator is taken from the
         &lt;CODE&gt;xsubi&lt;/CODE&gt; array, the parameters for the congruential formula from the
         global random number generator data.  The random number is returned in
         the variable pointed to by &lt;VAR&gt;result&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The return value is non-negative if the call succeeded.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension and should not be used in portable
         programs.
        </synopsis>
    </function>
  </construct>
  <construct id="function-lrand48_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="struct drand48_data *buffer"/>
        <parameter content="double *result"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;lrand48&lt;/CODE&gt;, but in addition it takes a
         pointer to a buffer describing the state of the random number generator
         just like &lt;CODE&gt;drand48&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; If the return value of the function is non-negative the variable pointed
         to by &lt;VAR&gt;result&lt;/VAR&gt; contains the result.  Otherwise an error occurred.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension and should not be used in portable
         programs.
        </synopsis>
    </function>
  </construct>
  <construct id="function-nrand48_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="unsigned short int xsubi[3]"/>
        <parameter content="struct drand48_data *buffer"/>
        <parameter content="long int *result"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;nrand48_r&lt;/CODE&gt; function works like &lt;CODE&gt;nrand48&lt;/CODE&gt; in that it
         produces a random number in the range &lt;CODE&gt;0&lt;/CODE&gt; to &lt;CODE&gt;2^31&lt;/CODE&gt;.  But instead
         of using the global parameters for the congruential formula it uses the
         information from the buffer pointed to by &lt;VAR&gt;buffer&lt;/VAR&gt;.  The state is
         described by the values in &lt;VAR&gt;xsubi&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If the return value is non-negative the variable pointed to by
         &lt;VAR&gt;result&lt;/VAR&gt; contains the result.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension and should not be used in portable
         programs.
        </synopsis>
    </function>
  </construct>
  <construct id="function-mrand48_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="struct drand48_data *buffer"/>
        <parameter content="double *result"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;mrand48&lt;/CODE&gt; but like the other reentrant
         functions it uses the random number generator described by the value in
         the buffer pointed to by &lt;VAR&gt;buffer&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If the return value is non-negative the variable pointed to by
         &lt;VAR&gt;result&lt;/VAR&gt; contains the result.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension and should not be used in portable
         programs.
        </synopsis>
    </function>
  </construct>
  <construct id="function-jrand48_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="unsigned short int xsubi[3]"/>
        <parameter content="struct drand48_data *buffer"/>
        <parameter content="long int *result"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;jrand48_r&lt;/CODE&gt; function is similar to &lt;CODE&gt;jrand48&lt;/CODE&gt;.  Like the
         other reentrant functions of this function family it uses the
         congruential formula parameters from the buffer pointed to by
         &lt;VAR&gt;buffer&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If the return value is non-negative the variable pointed to by
         &lt;VAR&gt;result&lt;/VAR&gt; contains the result.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension and should not be used in portable
         programs.
        </synopsis>
    </function>
  </construct>
  <construct id="function-srand48_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="long int seedval"/>
        <parameter content="struct drand48_data *buffer"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The description of the random number generator represented by the
         information in &lt;VAR&gt;buffer&lt;/VAR&gt; is initialized similarly to what the function
         &lt;CODE&gt;srand48&lt;/CODE&gt; does.  The state is initialized from the parameter
         &lt;VAR&gt;seedval&lt;/VAR&gt; and the parameters for the congruential formula are
         initialized to their default values.
         &lt;br&gt;&lt;br&gt; If the return value is non-negative the function call succeeded.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension and should not be used in portable
         programs.
        </synopsis>
    </function>
  </construct>
  <construct id="function-seed48_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="unsigned short int seed16v[3]"/>
        <parameter content="struct drand48_data *buffer"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;srand48_r&lt;/CODE&gt; but like &lt;CODE&gt;seed48&lt;/CODE&gt; it
         initializes all 48 bits of the state from the parameter &lt;VAR&gt;seed16v&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If the return value is non-negative the function call succeeded.  It
         does not return a pointer to the previous state of the random number
         generator like the &lt;CODE&gt;seed48&lt;/CODE&gt; function does.  If the user wants to
         preserve the state for a later re-run s/he can copy the whole buffer
         pointed to by &lt;VAR&gt;buffer&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension and should not be used in portable
         programs.
        </synopsis>
    </function>
  </construct>
  <construct id="function-lcong48_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="unsigned short int param[7]"/>
        <parameter content="struct drand48_data *buffer"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        This function initializes all aspects of the random number generator
         described in &lt;VAR&gt;buffer&lt;/VAR&gt; with the data in &lt;VAR&gt;param&lt;/VAR&gt;.  Here it is
         especially true that the function does more than just copying the
         contents of &lt;VAR&gt;param&lt;/VAR&gt; and &lt;VAR&gt;buffer&lt;/VAR&gt;.  More work is required and
         therefore it is important to use this function rather than initializing
         the random number generator directly.
         &lt;br&gt;&lt;br&gt; If the return value is non-negative the function call succeeded.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension and should not be used in portable
         programs.
        </synopsis>
    </function>
  </construct>
  <construct id="function-sysconf" type="function">
    <function returntype="long int">
      <prototype>
        <parameter content="int parameter"/>
      </prototype>
      <headers>
        <header filename = "limits.h"/>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        This function is used to inquire about runtime system parameters.  The
         &lt;VAR&gt;parameter&lt;/VAR&gt; argument should be one of the &lt;samp&gt;_SC_&lt;/samp&gt; symbols listed
         below.
         &lt;br&gt;&lt;br&gt; The normal return value from &lt;CODE&gt;sysconf&lt;/CODE&gt; is the value you requested.
         A value of &lt;CODE&gt;-1&lt;/CODE&gt; is returned both if the implementation does not
         impose a limit, and in case of an error.
         &lt;br&gt;&lt;br&gt; The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EINVAL&lt;/CODE&gt;
&lt;DD&gt;
         The value of the &lt;VAR&gt;parameter&lt;/VAR&gt; is invalid.

        </synopsis>
    </function>
  </construct>
  <construct id="function-pathconf" type="function">
    <function returntype="long int">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="int parameter"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
        <header filename = "unistdh.h"/>
        <header filename = "limits.h"/>
        <header filename = "dirent.h"/>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function is used to inquire about the limits that apply to
         the file named &lt;VAR&gt;filename&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;parameter&lt;/VAR&gt; argument should be one of the &lt;samp&gt;_PC_&lt;/samp&gt; constants
         listed below.
         &lt;br&gt;&lt;br&gt; The normal return value from &lt;CODE&gt;pathconf&lt;/CODE&gt; is the value you requested.
         A value of &lt;CODE&gt;-1&lt;/CODE&gt; is returned both if the implementation does not
         impose a limit, and in case of an error.  In the former case,
         &lt;CODE&gt;errno&lt;/CODE&gt; is not set, while in the latter case, &lt;CODE&gt;errno&lt;/CODE&gt; is set
         to indicate the cause of the problem.  So the only way to use this
         function robustly is to store &lt;CODE&gt;0&lt;/CODE&gt; into &lt;CODE&gt;errno&lt;/CODE&gt; just before
         calling it.
         &lt;br&gt;&lt;br&gt; Besides the usual file name errors ,
         the following error condition is defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EINVAL&lt;/CODE&gt;
&lt;DD&gt;
         The value of &lt;VAR&gt;parameter&lt;/VAR&gt; is invalid, or the implementation doesn't
         support the &lt;VAR&gt;parameter&lt;/VAR&gt; for the specific file.

        </synopsis>
    </function>
  </construct>
  <construct id="function-fpathconf" type="function">
    <function returntype="long int">
      <prototype>
        <parameter content="int filedes"/>
        <parameter content="int parameter"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
      </headers>
        <synopsis>
        This is just like &lt;CODE&gt;pathconf&lt;/CODE&gt; except that an open file descriptor
         is used to specify the file for which information is requested, instead
         of a file name.
         &lt;br&gt;&lt;br&gt; The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EBADF&lt;/CODE&gt;
&lt;DD&gt;
         The &lt;VAR&gt;filedes&lt;/VAR&gt; argument is not a valid file descriptor.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; EINVAL
         The value of &lt;VAR&gt;parameter&lt;/VAR&gt; is invalid, or the implementation doesn't
         support the &lt;VAR&gt;parameter&lt;/VAR&gt; for the specific file.

        </synopsis>
    </function>
  </construct>
  <construct id="function-confstr" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="int parameter"/>
        <parameter content="char *buf"/>
        <parameter content="size_t len"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
        <header filename = "limits.h"/>
      </headers>
        <synopsis>
        This function reads the value of a string-valued system parameter,
         storing the string into &lt;VAR&gt;len&lt;/VAR&gt; bytes of memory space starting at
         &lt;VAR&gt;buf&lt;/VAR&gt;.  The &lt;VAR&gt;parameter&lt;/VAR&gt; argument should be one of the
         &lt;samp&gt;_CS_&lt;/samp&gt; symbols listed below.
         &lt;br&gt;&lt;br&gt; The normal return value from &lt;CODE&gt;confstr&lt;/CODE&gt; is the length of the string
         value that you asked for.  If you supply a null pointer for &lt;VAR&gt;buf&lt;/VAR&gt;,
         then &lt;CODE&gt;confstr&lt;/CODE&gt; does not try to store the string; it just returns
         its length.  A value of &lt;CODE&gt;0&lt;/CODE&gt; indicates an error.
         &lt;br&gt;&lt;br&gt; If the string you asked for is too long for the buffer (that is, longer
         than &lt;CODE&gt;&lt;VAR&gt;len&lt;/VAR&gt; - 1&lt;/CODE&gt;), then &lt;CODE&gt;confstr&lt;/CODE&gt; stores just that much
         (leaving room for the terminating null character).  You can tell that
         this has happened because &lt;CODE&gt;confstr&lt;/CODE&gt; returns a value greater than or
         equal to &lt;VAR&gt;len&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The following &lt;CODE&gt;errno&lt;/CODE&gt; error conditions are defined for this function:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;EINVAL&lt;/CODE&gt;
&lt;DD&gt;
         The value of the &lt;VAR&gt;parameter&lt;/VAR&gt; is invalid.

        </synopsis>
    </function>
  </construct>
  <construct id="function-setlocale" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="int category"/>
        <parameter content="const char *locale"/>
      </prototype>
      <headers>
        <header filename = "unistd.h"/>
        <header filename = "locale.h"/>
      </headers>
        <synopsis>
        The function &lt;CODE&gt;setlocale&lt;/CODE&gt; sets the current locale for category
         &lt;VAR&gt;category&lt;/VAR&gt; to &lt;VAR&gt;locale&lt;/VAR&gt;.  A list of all the locales the system
         provides can be created by running
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
           locale -a&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;category&lt;/VAR&gt; is &lt;CODE&gt;LC_ALL&lt;/CODE&gt;, this specifies the locale for all
         purposes.  The other possible values of &lt;VAR&gt;category&lt;/VAR&gt; specify an
         single purpose .
         &lt;br&gt;&lt;br&gt; You can also use this function to find out the current locale by passing
         a null pointer as the &lt;VAR&gt;locale&lt;/VAR&gt; argument.  In this case,
         &lt;CODE&gt;setlocale&lt;/CODE&gt; returns a string that is the name of the locale
         currently selected for category &lt;VAR&gt;category&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The string returned by &lt;CODE&gt;setlocale&lt;/CODE&gt; can be overwritten by subsequent
         calls, so you should make a copy of the string  if you want to save it past any further calls to
         &lt;CODE&gt;setlocale&lt;/CODE&gt;.  (The standard library is guaranteed never to call
         &lt;CODE&gt;setlocale&lt;/CODE&gt; itself.)
         &lt;br&gt;&lt;br&gt; You should not modify the string returned by &lt;CODE&gt;setlocale&lt;/CODE&gt;.  It might
         be the same string that was passed as an argument in a previous call to
         &lt;CODE&gt;setlocale&lt;/CODE&gt;.  One requirement is that the &lt;VAR&gt;category&lt;/VAR&gt; must be
         the same in the call the string was returned and the one when the string
         is passed in as &lt;VAR&gt;locale&lt;/VAR&gt; parameter.
         &lt;br&gt;&lt;br&gt; When you read the current locale for category &lt;CODE&gt;LC_ALL&lt;/CODE&gt;, the value
         encodes the entire combination of selected locales for all categories.
         In this case, the value is not just a single locale name.  In fact, we
         don't make any promises about what it looks like.  But if you specify
         the same ``locale name'' with &lt;CODE&gt;LC_ALL&lt;/CODE&gt; in a subsequent call to
         &lt;CODE&gt;setlocale&lt;/CODE&gt;, it restores the same combination of locale selections.
         &lt;br&gt;&lt;br&gt; To be sure you can use the returned string encoding the currently selected
         locale at a later time, you must make a copy of the string.  It is not
         guaranteed that the returned pointer remains valid over time.
         &lt;br&gt;&lt;br&gt; When the &lt;VAR&gt;locale&lt;/VAR&gt; argument is not a null pointer, the string returned
         by &lt;CODE&gt;setlocale&lt;/CODE&gt; reflects the newly-modified locale.
         &lt;br&gt;&lt;br&gt; If you specify an empty string for &lt;VAR&gt;locale&lt;/VAR&gt;, this means to read the
         appropriate environment variable and use its value to select the locale
         for &lt;VAR&gt;category&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If a nonempty string is given for &lt;VAR&gt;locale&lt;/VAR&gt;, then the locale of that
         name is used if possible.
         &lt;br&gt;&lt;br&gt; If you specify an invalid locale name, &lt;CODE&gt;setlocale&lt;/CODE&gt; returns a null
         pointer and leaves the current locale unchanged.
        </synopsis>
    </function>
  </construct>
  <construct id="function-localeconv" type="function">
    <function returntype="struct lconv *">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "locale.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;localeconv&lt;/CODE&gt; function returns a pointer to a structure whose
         components contain information about how numeric and monetary values
         should be formatted in the current locale.
         &lt;br&gt;&lt;br&gt; You should not modify the structure or its contents.  The structure might
         be overwritten by subsequent calls to &lt;CODE&gt;localeconv&lt;/CODE&gt;, or by calls to
         &lt;CODE&gt;setlocale&lt;/CODE&gt;, but no other function in the library overwrites this
         value.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-lconv" type="struct">
    <structure>
    </structure>
  </construct>
  <construct id="function-nl_langinfo" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="nl_item item"/>
      </prototype>
      <headers>
        <header filename = "locale.h"/>
        <header filename = "langinfo.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;nl_langinfo&lt;/CODE&gt; function can be used to access individual
         elements of the locale categories.  Unlike the &lt;CODE&gt;localeconv&lt;/CODE&gt;
         function, which returns all the information, &lt;CODE&gt;nl_langinfo&lt;/CODE&gt;
         lets the caller select what information it requires.  This is very
         fast and it is not a problem to call this function multiple times.
         &lt;br&gt;&lt;br&gt; A second advantage is that in addition to the numeric and monetary
         formatting information, information from the
         &lt;CODE&gt;LC_TIME&lt;/CODE&gt; and &lt;CODE&gt;LC_MESSAGES&lt;/CODE&gt; categories is available.
         &lt;br&gt;&lt;br&gt; The type &lt;CODE&gt;nl_type&lt;/CODE&gt; is defined in &lt;TT&gt;nl_types.h&lt;/TT&gt;.  The argument
         &lt;VAR&gt;item&lt;/VAR&gt; is a numeric value defined in the header &lt;TT&gt;langinfo.h&lt;/TT&gt;.
         The X/Open standard defines the following values:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;CODESET&lt;/CODE&gt;
&lt;DD&gt;
         &lt;CODE&gt;nl_langinfo&lt;/CODE&gt; returns a string with the name of the coded character
         set used in the selected locale.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;ABDAY_1&lt;/CODE&gt;
&lt;DD&gt;
         &lt;LI&gt;x ABDAY_2
         &lt;LI&gt;x ABDAY_3
         &lt;LI&gt;x ABDAY_4
         &lt;LI&gt;x ABDAY_5
         &lt;LI&gt;x ABDAY_6
         &lt;LI&gt;x ABDAY_7
         &lt;CODE&gt;nl_langinfo&lt;/CODE&gt; returns the abbreviated weekday name.  &lt;CODE&gt;ABDAY_1&lt;/CODE&gt;
         corresponds to Sunday.
         &lt;DT&gt;&lt;CODE&gt;DAY_1&lt;/CODE&gt;
&lt;DD&gt;
         &lt;LI&gt;x DAY_2
         &lt;LI&gt;x DAY_3
         &lt;LI&gt;x DAY_4
         &lt;LI&gt;x DAY_5
         &lt;LI&gt;x DAY_6
         &lt;LI&gt;x DAY_7
         Similar to &lt;CODE&gt;ABDAY_1&lt;/CODE&gt; etc., but here the return value is the
         unabbreviated weekday name.
         &lt;DT&gt;&lt;CODE&gt;ABMON_1&lt;/CODE&gt;
&lt;DD&gt;
         &lt;LI&gt;x ABMON_2
         &lt;LI&gt;x ABMON_3
         &lt;LI&gt;x ABMON_4
         &lt;LI&gt;x ABMON_5
         &lt;LI&gt;x ABMON_6
         &lt;LI&gt;x ABMON_7
         &lt;LI&gt;x ABMON_8
         &lt;LI&gt;x ABMON_9
         &lt;LI&gt;x ABMON_10
         &lt;LI&gt;x ABMON_11
         &lt;LI&gt;x ABMON_12
         The return value is abbreviated name of the month.  &lt;CODE&gt;ABMON_1&lt;/CODE&gt;
         corresponds to January.
         &lt;DT&gt;&lt;CODE&gt;MON_1&lt;/CODE&gt;
&lt;DD&gt;
         &lt;LI&gt;x MON_2
         &lt;LI&gt;x MON_3
         &lt;LI&gt;x MON_4
         &lt;LI&gt;x MON_5
         &lt;LI&gt;x MON_6
         &lt;LI&gt;x MON_7
         &lt;LI&gt;x MON_8
         &lt;LI&gt;x MON_9
         &lt;LI&gt;x MON_10
         &lt;LI&gt;x MON_11
         &lt;LI&gt;x MON_12
         Similar to &lt;CODE&gt;ABMON_1&lt;/CODE&gt; etc., but here the month names are not abbreviated.
         Here the first value &lt;CODE&gt;MON_1&lt;/CODE&gt; also corresponds to January.
         &lt;DT&gt;&lt;CODE&gt;AM_STR&lt;/CODE&gt;
&lt;DD&gt;
         &lt;LI&gt;x PM_STR
         The return values are strings which can be used in the representation of time
         as an hour from 1 to 12 plus an am/pm specifier.
         &lt;br&gt;&lt;br&gt; Note that in locales which do not use this time representation
         these strings might be empty, in which case the am/pm format
         cannot be used at all.
         &lt;DT&gt;&lt;CODE&gt;D_T_FMT&lt;/CODE&gt;
&lt;DD&gt;
         The return value can be used as a format string for &lt;CODE&gt;strftime&lt;/CODE&gt; to
         represent time and date in a locale-specific way.
         &lt;DT&gt;&lt;CODE&gt;D_FMT&lt;/CODE&gt;
&lt;DD&gt;
         The return value can be used as a format string for &lt;CODE&gt;strftime&lt;/CODE&gt; to
         represent a date in a locale-specific way.
         &lt;DT&gt;&lt;CODE&gt;T_FMT&lt;/CODE&gt;
&lt;DD&gt;
         The return value can be used as a format string for &lt;CODE&gt;strftime&lt;/CODE&gt; to
         represent time in a locale-specific way.
         &lt;DT&gt;&lt;CODE&gt;T_FMT_AMPM&lt;/CODE&gt;
&lt;DD&gt;
         The return value can be used as a format string for &lt;CODE&gt;strftime&lt;/CODE&gt; to
         represent time in the am/pm format.
         &lt;br&gt;&lt;br&gt; Note that if the am/pm format does not make any sense for the
         selected locale, the return value might be the same as the one for
         &lt;CODE&gt;T_FMT&lt;/CODE&gt;.
         &lt;DT&gt;&lt;CODE&gt;ERA&lt;/CODE&gt;
&lt;DD&gt;
         The return value represents the era used in the current locale.
         &lt;br&gt;&lt;br&gt; Most locales do not define this value.  An example of a locale which
         does define this value is the Japanese one.  In Japan, the traditional
         representation of dates includes the name of the era corresponding to
         the then-emperor's reign.
         &lt;br&gt;&lt;br&gt; Normally it should not be necessary to use this value directly.
         Specifying the &lt;CODE&gt;E&lt;/CODE&gt; modifier in their format strings causes the
         &lt;CODE&gt;strftime&lt;/CODE&gt; functions to use this information.  The format of the
         returned string is not specified, and therefore you should not assume
         knowledge of it on different systems.
         &lt;DT&gt;&lt;CODE&gt;ERA_YEAR&lt;/CODE&gt;
&lt;DD&gt;
         The return value gives the year in the relevant era of the locale.
         As for &lt;CODE&gt;ERA&lt;/CODE&gt; it should not be necessary to use this value directly.
         &lt;DT&gt;&lt;CODE&gt;ERA_D_T_FMT&lt;/CODE&gt;
&lt;DD&gt;
         This return value can be used as a format string for &lt;CODE&gt;strftime&lt;/CODE&gt; to
         represent dates and times in a locale-specific era-based way.
         &lt;DT&gt;&lt;CODE&gt;ERA_D_FMT&lt;/CODE&gt;
&lt;DD&gt;
         This return value can be used as a format string for &lt;CODE&gt;strftime&lt;/CODE&gt; to
         represent a date in a locale-specific era-based way.
         &lt;DT&gt;&lt;CODE&gt;ERA_T_FMT&lt;/CODE&gt;
&lt;DD&gt;
         This return value can be used as a format string for &lt;CODE&gt;strftime&lt;/CODE&gt; to
         represent time in a locale-specific era-based way.
         &lt;DT&gt;&lt;CODE&gt;ALT_DIGITS&lt;/CODE&gt;
&lt;DD&gt;
         The return value is a representation of up to 100 values used to
         represent the values 0 to 99.  As for &lt;CODE&gt;ERA&lt;/CODE&gt; this
         value is not intended to be used directly, but instead indirectly
         through the &lt;CODE&gt;strftime&lt;/CODE&gt; function.  When the modifier &lt;CODE&gt;O&lt;/CODE&gt; is
         used in a format which would otherwise use numerals to represent hours,
         minutes, seconds, weekdays, months, or weeks, the appropriate value for
         the locale is used instead.
         &lt;DT&gt;&lt;CODE&gt;INT_CURR_SYMBOL&lt;/CODE&gt;
&lt;DD&gt;
         The same as the value returned by &lt;CODE&gt;localeconv&lt;/CODE&gt; in the
         &lt;CODE&gt;int_curr_symbol&lt;/CODE&gt; element of the &lt;CODE&gt;struct lconv&lt;/CODE&gt;.
         &lt;DT&gt;&lt;CODE&gt;CURRENCY_SYMBOL&lt;/CODE&gt;
&lt;DD&gt;
         &lt;LI&gt;x CRNCYSTR
         The same as the value returned by &lt;CODE&gt;localeconv&lt;/CODE&gt; in the
         &lt;CODE&gt;currency_symbol&lt;/CODE&gt; element of the &lt;CODE&gt;struct lconv&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;CRNCYSTR&lt;/CODE&gt; is a deprecated alias still required by Unix98.
         &lt;DT&gt;&lt;CODE&gt;MON_DECIMAL_POINT&lt;/CODE&gt;
&lt;DD&gt;
         The same as the value returned by &lt;CODE&gt;localeconv&lt;/CODE&gt; in the
         &lt;CODE&gt;mon_decimal_point&lt;/CODE&gt; element of the &lt;CODE&gt;struct lconv&lt;/CODE&gt;.
         &lt;DT&gt;&lt;CODE&gt;MON_THOUSANDS_SEP&lt;/CODE&gt;
&lt;DD&gt;
         The same as the value returned by &lt;CODE&gt;localeconv&lt;/CODE&gt; in the
         &lt;CODE&gt;mon_thousands_sep&lt;/CODE&gt; element of the &lt;CODE&gt;struct lconv&lt;/CODE&gt;.
         &lt;DT&gt;&lt;CODE&gt;MON_GROUPING&lt;/CODE&gt;
&lt;DD&gt;
         The same as the value returned by &lt;CODE&gt;localeconv&lt;/CODE&gt; in the
         &lt;CODE&gt;mon_grouping&lt;/CODE&gt; element of the &lt;CODE&gt;struct lconv&lt;/CODE&gt;.
         &lt;DT&gt;&lt;CODE&gt;POSITIVE_SIGN&lt;/CODE&gt;
&lt;DD&gt;
         The same as the value returned by &lt;CODE&gt;localeconv&lt;/CODE&gt; in the
         &lt;CODE&gt;positive_sign&lt;/CODE&gt; element of the &lt;CODE&gt;struct lconv&lt;/CODE&gt;.
         &lt;DT&gt;&lt;CODE&gt;NEGATIVE_SIGN&lt;/CODE&gt;
&lt;DD&gt;
         The same as the value returned by &lt;CODE&gt;localeconv&lt;/CODE&gt; in the
         &lt;CODE&gt;negative_sign&lt;/CODE&gt; element of the &lt;CODE&gt;struct lconv&lt;/CODE&gt;.
         &lt;DT&gt;&lt;CODE&gt;INT_FRAC_DIGITS&lt;/CODE&gt;
&lt;DD&gt;
         The same as the value returned by &lt;CODE&gt;localeconv&lt;/CODE&gt; in the
         &lt;CODE&gt;int_frac_digits&lt;/CODE&gt; element of the &lt;CODE&gt;struct lconv&lt;/CODE&gt;.
         &lt;DT&gt;&lt;CODE&gt;FRAC_DIGITS&lt;/CODE&gt;
&lt;DD&gt;
         The same as the value returned by &lt;CODE&gt;localeconv&lt;/CODE&gt; in the
         &lt;CODE&gt;frac_digits&lt;/CODE&gt; element of the &lt;CODE&gt;struct lconv&lt;/CODE&gt;.
         &lt;DT&gt;&lt;CODE&gt;P_CS_PRECEDES&lt;/CODE&gt;
&lt;DD&gt;
         The same as the value returned by &lt;CODE&gt;localeconv&lt;/CODE&gt; in the
         &lt;CODE&gt;p_cs_precedes&lt;/CODE&gt; element of the &lt;CODE&gt;struct lconv&lt;/CODE&gt;.
         &lt;DT&gt;&lt;CODE&gt;P_SEP_BY_SPACE&lt;/CODE&gt;
&lt;DD&gt;
         The same as the value returned by &lt;CODE&gt;localeconv&lt;/CODE&gt; in the
         &lt;CODE&gt;p_sep_by_space&lt;/CODE&gt; element of the &lt;CODE&gt;struct lconv&lt;/CODE&gt;.
         &lt;DT&gt;&lt;CODE&gt;N_CS_PRECEDES&lt;/CODE&gt;
&lt;DD&gt;
         The same as the value returned by &lt;CODE&gt;localeconv&lt;/CODE&gt; in the
         &lt;CODE&gt;n_cs_precedes&lt;/CODE&gt; element of the &lt;CODE&gt;struct lconv&lt;/CODE&gt;.
         &lt;DT&gt;&lt;CODE&gt;N_SEP_BY_SPACE&lt;/CODE&gt;
&lt;DD&gt;
         The same as the value returned by &lt;CODE&gt;localeconv&lt;/CODE&gt; in the
         &lt;CODE&gt;n_sep_by_space&lt;/CODE&gt; element of the &lt;CODE&gt;struct lconv&lt;/CODE&gt;.
         &lt;DT&gt;&lt;CODE&gt;P_SIGN_POSN&lt;/CODE&gt;
&lt;DD&gt;
         The same as the value returned by &lt;CODE&gt;localeconv&lt;/CODE&gt; in the
         &lt;CODE&gt;p_sign_posn&lt;/CODE&gt; element of the &lt;CODE&gt;struct lconv&lt;/CODE&gt;.
         &lt;DT&gt;&lt;CODE&gt;N_SIGN_POSN&lt;/CODE&gt;
&lt;DD&gt;
         The same as the value returned by &lt;CODE&gt;localeconv&lt;/CODE&gt; in the
         &lt;CODE&gt;n_sign_posn&lt;/CODE&gt; element of the &lt;CODE&gt;struct lconv&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;INT_P_CS_PRECEDES&lt;/CODE&gt;
&lt;DD&gt;
         The same as the value returned by &lt;CODE&gt;localeconv&lt;/CODE&gt; in the
         &lt;CODE&gt;int_p_cs_precedes&lt;/CODE&gt; element of the &lt;CODE&gt;struct lconv&lt;/CODE&gt;.
         &lt;DT&gt;&lt;CODE&gt;INT_P_SEP_BY_SPACE&lt;/CODE&gt;
&lt;DD&gt;
         The same as the value returned by &lt;CODE&gt;localeconv&lt;/CODE&gt; in the
         &lt;CODE&gt;int_p_sep_by_space&lt;/CODE&gt; element of the &lt;CODE&gt;struct lconv&lt;/CODE&gt;.
         &lt;DT&gt;&lt;CODE&gt;INT_N_CS_PRECEDES&lt;/CODE&gt;
&lt;DD&gt;
         The same as the value returned by &lt;CODE&gt;localeconv&lt;/CODE&gt; in the
         &lt;CODE&gt;int_n_cs_precedes&lt;/CODE&gt; element of the &lt;CODE&gt;struct lconv&lt;/CODE&gt;.
         &lt;DT&gt;&lt;CODE&gt;INT_N_SEP_BY_SPACE&lt;/CODE&gt;
&lt;DD&gt;
         The same as the value returned by &lt;CODE&gt;localeconv&lt;/CODE&gt; in the
         &lt;CODE&gt;int_n_sep_by_space&lt;/CODE&gt; element of the &lt;CODE&gt;struct lconv&lt;/CODE&gt;.
         &lt;DT&gt;&lt;CODE&gt;INT_P_SIGN_POSN&lt;/CODE&gt;
&lt;DD&gt;
         The same as the value returned by &lt;CODE&gt;localeconv&lt;/CODE&gt; in the
         &lt;CODE&gt;int_p_sign_posn&lt;/CODE&gt; element of the &lt;CODE&gt;struct lconv&lt;/CODE&gt;.
         &lt;DT&gt;&lt;CODE&gt;INT_N_SIGN_POSN&lt;/CODE&gt;
&lt;DD&gt;
         The same as the value returned by &lt;CODE&gt;localeconv&lt;/CODE&gt; in the
         &lt;CODE&gt;int_n_sign_posn&lt;/CODE&gt; element of the &lt;CODE&gt;struct lconv&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;DECIMAL_POINT&lt;/CODE&gt;
&lt;DD&gt;
         &lt;LI&gt;x RADIXCHAR
         The same as the value returned by &lt;CODE&gt;localeconv&lt;/CODE&gt; in the
         &lt;CODE&gt;decimal_point&lt;/CODE&gt; element of the &lt;CODE&gt;struct lconv&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The name &lt;CODE&gt;RADIXCHAR&lt;/CODE&gt; is a deprecated alias still used in Unix98.
         &lt;DT&gt;&lt;CODE&gt;THOUSANDS_SEP&lt;/CODE&gt;
&lt;DD&gt;
         &lt;LI&gt;x THOUSEP
         The same as the value returned by &lt;CODE&gt;localeconv&lt;/CODE&gt; in the
         &lt;CODE&gt;thousands_sep&lt;/CODE&gt; element of the &lt;CODE&gt;struct lconv&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The name &lt;CODE&gt;THOUSEP&lt;/CODE&gt; is a deprecated alias still used in Unix98.
         &lt;DT&gt;&lt;CODE&gt;GROUPING&lt;/CODE&gt;
&lt;DD&gt;
         The same as the value returned by &lt;CODE&gt;localeconv&lt;/CODE&gt; in the
         &lt;CODE&gt;grouping&lt;/CODE&gt; element of the &lt;CODE&gt;struct lconv&lt;/CODE&gt;.
         &lt;DT&gt;&lt;CODE&gt;YESEXPR&lt;/CODE&gt;
&lt;DD&gt;
         The return value is a regular expression which can be used with the
         &lt;CODE&gt;regex&lt;/CODE&gt; function to recognize a positive response to a yes/no
         question.  The GNU C library provides the &lt;CODE&gt;rpmatch&lt;/CODE&gt; function for
         easier handling in applications.
         &lt;DT&gt;&lt;CODE&gt;NOEXPR&lt;/CODE&gt;
&lt;DD&gt;
         The return value is a regular expression which can be used with the
         &lt;CODE&gt;regex&lt;/CODE&gt; function to recognize a negative response to a yes/no
         question.
         &lt;DT&gt;&lt;CODE&gt;YESSTR&lt;/CODE&gt;
&lt;DD&gt;
         The return value is a locale-specific translation of the positive response
         to a yes/no question.
         &lt;br&gt;&lt;br&gt; Using this value is deprecated since it is a very special case of
         message translation, and is better handled by the message
         translation functions .
         &lt;br&gt;&lt;br&gt; The use of this symbol is deprecated.  Instead message translation
         should be used.
         &lt;DT&gt;&lt;CODE&gt;NOSTR&lt;/CODE&gt;
&lt;DD&gt;
         The return value is a locale-specific translation of the negative response
         to a yes/no question.  What is said for &lt;CODE&gt;YESSTR&lt;/CODE&gt; is also true here.
         &lt;br&gt;&lt;br&gt; The use of this symbol is deprecated.  Instead message translation
         should be used.
         &lt;/DL&gt;
         &lt;br&gt;&lt;br&gt; The file &lt;TT&gt;langinfo.h&lt;/TT&gt; defines a lot more symbols but none of them
         is official.  Using them is not portable, and the format of the
         return values might change.  Therefore we recommended you not use
         them.
         &lt;br&gt;&lt;br&gt; Note that the return value for any valid argument can be used for
         in all situations (with the possible exception of the am/pm time formatting
         codes).  If the user has not selected any locale for the
         appropriate category, &lt;CODE&gt;nl_langinfo&lt;/CODE&gt; returns the information from the
         &lt;CODE&gt;"C"&lt;/CODE&gt; locale.  It is therefore possible to use this function as
         shown in the example below.
         &lt;br&gt;&lt;br&gt; If the argument &lt;VAR&gt;item&lt;/VAR&gt; is not valid, a pointer to an empty string is
         returned.
        </synopsis>
    </function>
  </construct>
  <construct id="function-strfmon" type="function">
    <function returntype="ssize_t">
      <prototype>
        <parameter content="char *s"/>
        <parameter content="size_t maxsize"/>
        <parameter content="const char *format"/>
        <parameter content="..."/>
      </prototype>
        <synopsis>
        The &lt;CODE&gt;strfmon&lt;/CODE&gt; function is similar to the &lt;CODE&gt;strftime&lt;/CODE&gt; function
         in that it takes a buffer, its size, a format string,
         and values to write into the buffer as text in a form specified
         by the format string.  Like &lt;CODE&gt;strftime&lt;/CODE&gt;, the function
         also returns the number of bytes written into the buffer.
         &lt;br&gt;&lt;br&gt; There are two differences: &lt;CODE&gt;strfmon&lt;/CODE&gt; can take more than one
         argument, and, of course, the format specification is different.  Like
         &lt;CODE&gt;strftime&lt;/CODE&gt;, the format string consists of normal text, which is
         output as is, and format specifiers, which are indicated by a &lt;samp&gt;%&lt;/samp&gt;.
         Immediately after the &lt;samp&gt;%&lt;/samp&gt;, you can optionally specify various flags
         and formatting information before the main formatting character, in a
         similar way to &lt;CODE&gt;printf&lt;/CODE&gt;:
         &lt;br&gt;&lt;br&gt; &lt;OL&gt;
         &lt;LI&gt;
         Immediately following the &lt;samp&gt;%&lt;/samp&gt; there can be one or more of the
         following flags:
         &lt;DL&gt;

         &lt;LI&gt; &lt;samp&gt;=&lt;VAR&gt;f&lt;/VAR&gt;&lt;/samp&gt;
         The single byte character &lt;VAR&gt;f&lt;/VAR&gt; is used for this field as the numeric
         fill character.  By default this character is a space character.
         Filling with this character is only performed if a left precision
         is specified.  It is not just to fill to the given field width.
         &lt;LI&gt; &lt;samp&gt;^&lt;/samp&gt;
         The number is printed without grouping the digits according to the rules
         of the current locale.  By default grouping is enabled.
         &lt;LI&gt; &lt;samp&gt;+&lt;/samp&gt;, &lt;samp&gt;(&lt;/samp&gt;
         At most one of these flags can be used.  They select which format to
         represent the sign of a currency amount.  By default, and if
         &lt;samp&gt;+&lt;/samp&gt; is given, the locale equivalent of +/- is used.  If
         &lt;samp&gt;(&lt;/samp&gt; is given, negative amounts are enclosed in parentheses.  The
         exact format is determined by the values of the &lt;CODE&gt;LC_MONETARY&lt;/CODE&gt;
         category of the locale selected at program runtime.
         &lt;LI&gt; &lt;samp&gt;!&lt;/samp&gt;
         The output will not contain the currency symbol.
         &lt;LI&gt; &lt;samp&gt;-&lt;/samp&gt;
         The output will be formatted left-justified instead of right-justified if
         it does not fill the entire field width.
         &lt;/DL&gt;
         &lt;/OL&gt;
         &lt;br&gt;&lt;br&gt; The next part of a specification is an optional field width.  If no
         width is specified 0 is taken.  During output, the function first
         determines how much space is required.  If it requires at least as many
         characters as given by the field width, it is output using as much space
         as necessary.  Otherwise, it is extended to use the full width by
         filling with the space character.  The presence or absence of the
         &lt;samp&gt;-&lt;/samp&gt; flag determines the side at which such padding occurs.  If
         present, the spaces are added at the right making the output
         left-justified, and vice versa.
         &lt;br&gt;&lt;br&gt; So far the format looks familiar, being similar to the &lt;CODE&gt;printf&lt;/CODE&gt; and
         &lt;CODE&gt;strftime&lt;/CODE&gt; formats.  However, the next two optional fields
         introduce something new.  The first one is a &lt;samp&gt;#&lt;/samp&gt; character followed
         by a decimal digit string.  The value of the digit string specifies the
         number of &lt;EM&gt;digit&lt;/EM&gt; positions to the left of the decimal point (or
         equivalent).  This does &lt;EM&gt;not&lt;/EM&gt; include the grouping character when
         the &lt;samp&gt;^&lt;/samp&gt; flag is not given.  If the space needed to print the number
         does not fill the whole width, the field is padded at the left side with
         the fill character, which can be selected using the &lt;samp&gt;=&lt;/samp&gt; flag and by
         default is a space.  For example, if the field width is selected as 6
         and the number is 123, the fill character is &lt;samp&gt;*&lt;/samp&gt; the result
         will be &lt;samp&gt;***123&lt;/samp&gt;.
         &lt;br&gt;&lt;br&gt; The second optional field starts with a &lt;samp&gt;.&lt;/samp&gt; (period) and consists
         of another decimal digit string.  Its value describes the number of
         characters printed after the decimal point.  The default is selected
         from the current locale (&lt;CODE&gt;frac_digits&lt;/CODE&gt;, &lt;CODE&gt;int_frac_digits&lt;/CODE&gt;, see
         ).  If the exact representation needs more digits
         than given by the field width, the displayed value is rounded.  If the
         number of fractional digits is selected to be zero, no decimal point is
         printed.
         &lt;br&gt;&lt;br&gt; As a GNU extension, the &lt;CODE&gt;strfmon&lt;/CODE&gt; implementation in the GNU libc
         allows an optional &lt;samp&gt;L&lt;/samp&gt; next as a format modifier.  If this modifier
         is given, the argument is expected to be a &lt;CODE&gt;long double&lt;/CODE&gt; instead of
         a &lt;CODE&gt;double&lt;/CODE&gt; value.
         &lt;br&gt;&lt;br&gt; Finally, the last component is a format specifier.  There are three
         specifiers defined:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;LI&gt; &lt;samp&gt;i&lt;/samp&gt;
         Use the locale's rules for formatting an international currency value.
         &lt;LI&gt; &lt;samp&gt;n&lt;/samp&gt;
         Use the locale's rules for formatting a national currency value.
         &lt;LI&gt; &lt;samp&gt;%&lt;/samp&gt;
         Place a &lt;samp&gt;%&lt;/samp&gt; in the output.  There must be no flag, width
         specifier or modifier given, only &lt;samp&gt;%%&lt;/samp&gt; is allowed.
         &lt;/DL&gt;
         &lt;br&gt;&lt;br&gt; As for &lt;CODE&gt;printf&lt;/CODE&gt;, the function reads the format string
         from left to right and uses the values passed to the function following
         the format string.  The values are expected to be either of type
         &lt;CODE&gt;double&lt;/CODE&gt; or &lt;CODE&gt;long double&lt;/CODE&gt;, depending on the presence of the
         modifier &lt;samp&gt;L&lt;/samp&gt;.  The result is stored in the buffer pointed to by
         &lt;VAR&gt;s&lt;/VAR&gt;.  At most &lt;VAR&gt;maxsize&lt;/VAR&gt; characters are stored.
         &lt;br&gt;&lt;br&gt; The return value of the function is the number of characters stored in
         &lt;VAR&gt;s&lt;/VAR&gt;, including the terminating &lt;CODE&gt;NULL&lt;/CODE&gt; byte.  If the number of
         characters stored would exceed &lt;VAR&gt;maxsize&lt;/VAR&gt;, the function returns
         -1 and the content of the buffer &lt;VAR&gt;s&lt;/VAR&gt; is unspecified.  In this
         case &lt;CODE&gt;errno&lt;/CODE&gt; is set to &lt;CODE&gt;E2BIG&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-rpmatch" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *response"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The function &lt;CODE&gt;rpmatch&lt;/CODE&gt; checks the string in &lt;VAR&gt;response&lt;/VAR&gt; whether
         or not it is a correct yes-or-no answer and if yes, which one.  The
         check uses the &lt;CODE&gt;YESEXPR&lt;/CODE&gt; and &lt;CODE&gt;NOEXPR&lt;/CODE&gt; data in the
         &lt;CODE&gt;LC_MESSAGES&lt;/CODE&gt; category of the currently selected locale.  The
         return value is as follows:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;1&lt;/CODE&gt;
&lt;DD&gt;
         The user entered an affirmative answer.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; 0
         The user entered a negative answer.
         &lt;br&gt;&lt;br&gt; &lt;LI&gt; -1
         The answer matched neither the &lt;CODE&gt;YESEXPR&lt;/CODE&gt; nor the &lt;CODE&gt;NOEXPR&lt;/CODE&gt;
         regular expression.

         &lt;br&gt;&lt;br&gt; This function is not standardized but available beside in GNU libc at
         least also in the IBM AIX library.
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-FILE" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="function-fopen" type="function">
    <function returntype="FILE *">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="const char *opentype"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fopen&lt;/CODE&gt; function opens a stream for I/O to the file
         &lt;VAR&gt;filename&lt;/VAR&gt;, and returns a pointer to the stream.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;opentype&lt;/VAR&gt; argument is a string that controls how the file is
         opened and specifies attributes of the resulting stream.  It must begin
         with one of the following sequences of characters:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;SAMP&gt;r&lt;/SAMP&gt;
&lt;DD&gt;
         Open an existing file for reading only.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;SAMP&gt;w&lt;/SAMP&gt;
&lt;DD&gt;
         Open the file for writing only.  If the file already exists, it is
         truncated to zero length.  Otherwise a new file is created.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;SAMP&gt;a&lt;/SAMP&gt;
&lt;DD&gt;
         Open a file for append access; that is, writing at the end of file only.
         If the file already exists, its initial contents are unchanged and
         output to the stream is appended to the end of the file.
         Otherwise, a new, empty file is created.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;SAMP&gt;r+&lt;/SAMP&gt;
&lt;DD&gt;
         Open an existing file for both reading and writing.  The initial contents
         of the file are unchanged and the initial file position is at the
         beginning of the file.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;SAMP&gt;w+&lt;/SAMP&gt;
&lt;DD&gt;
         Open a file for both reading and writing.  If the file already exists, it
         is truncated to zero length.  Otherwise, a new file is created.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;SAMP&gt;a+&lt;/SAMP&gt;
&lt;DD&gt;
         Open or create file for both reading and appending.  If the file exists,
         its initial contents are unchanged.  Otherwise, a new file is created.
         The initial file position for reading is at the beginning of the file,
         but output is always appended to the end of the file.
         &lt;/DL&gt;
         &lt;br&gt;&lt;br&gt; As you can see, &lt;samp&gt;+&lt;/samp&gt; requests a stream that can do both input and
         output.  When using such a stream, you must call &lt;CODE&gt;fflush&lt;/CODE&gt;
          or a file positioning function such as
         &lt;CODE&gt;fseek&lt;/CODE&gt;  when switching from reading
         to writing or vice versa.  Otherwise, internal buffers might not be
         emptied properly.
         &lt;br&gt;&lt;br&gt; Additional characters may appear after these to specify flags for the
         call.  Always put the mode (&lt;samp&gt;r&lt;/samp&gt;, &lt;samp&gt;w+&lt;/samp&gt;, etc.) first; that is
         the only part you are guaranteed will be understood by all systems.
         &lt;br&gt;&lt;br&gt; The GNU C library defines one additional character for use in
         &lt;VAR&gt;opentype&lt;/VAR&gt;: the character &lt;samp&gt;x&lt;/samp&gt; insists on creating a new
         file---if a file &lt;VAR&gt;filename&lt;/VAR&gt; already exists, &lt;CODE&gt;fopen&lt;/CODE&gt; fails
         rather than opening it.  If you use &lt;samp&gt;x&lt;/samp&gt; you are guaranteed that
         you will not clobber an existing file.  This is equivalent to the
         &lt;CODE&gt;O_EXCL&lt;/CODE&gt; option to the &lt;CODE&gt;open&lt;/CODE&gt; function .
         &lt;br&gt;&lt;br&gt; The character &lt;samp&gt;b&lt;/samp&gt; in &lt;VAR&gt;opentype&lt;/VAR&gt; has a standard meaning; it
         requests a binary stream rather than a text stream.  But this makes no
         difference in POSIX systems (including the GNU system).  If both
         &lt;samp&gt;+&lt;/samp&gt; and &lt;samp&gt;b&lt;/samp&gt; are specified, they can appear in either order.
         .
         &lt;br&gt;&lt;br&gt;  orientation
         , stream
         If the &lt;VAR&gt;opentype&lt;/VAR&gt; string contains the sequence
         &lt;CODE&gt;,ccs=&lt;VAR&gt;STRING&lt;/VAR&gt;&lt;/CODE&gt; then &lt;VAR&gt;STRING&lt;/VAR&gt; is taken as the name of a
         coded character set and &lt;CODE&gt;fopen&lt;/CODE&gt; will mark the stream as
         wide-oriented which appropriate conversion functions in place to convert
         from and to the character set &lt;VAR&gt;STRING&lt;/VAR&gt; is place.  Any other stream
         is opened initially unoriented and the orientation is decided with the
         first file operation.  If the first operation is a wide character
         operation, the stream is not only marked as wide-oriented, also the
         conversion functions to convert to the coded character set used for the
         current locale are loaded.  This will not change anymore from this point
         on even if the locale selected for the &lt;CODE&gt;LC_CTYPE&lt;/CODE&gt; category is
         changed.
         &lt;br&gt;&lt;br&gt; Any other characters in &lt;VAR&gt;opentype&lt;/VAR&gt; are simply ignored.  They may be
         meaningful in other systems.
         &lt;br&gt;&lt;br&gt; If the open fails, &lt;CODE&gt;fopen&lt;/CODE&gt; returns a null pointer.
         &lt;br&gt;&lt;br&gt; When the sources are compiling with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; on a
         32 bit machine this function is in fact &lt;CODE&gt;fopen64&lt;/CODE&gt; since the LFS
         interface replaces transparently the old interface.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fopen64" type="function">
    <function returntype="FILE *">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="const char *opentype"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;fopen&lt;/CODE&gt; but the stream it returns a
         pointer for is opened using &lt;CODE&gt;open64&lt;/CODE&gt;.  Therefore this stream can be
         used even on files larger then 2^31 bytes on 32 bit machines.
         &lt;br&gt;&lt;br&gt; Please note that the return type is still &lt;CODE&gt;FILE *&lt;/CODE&gt;.  There is no
         special &lt;CODE&gt;FILE&lt;/CODE&gt; type for the LFS interface.
         &lt;br&gt;&lt;br&gt; If the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; on a 32
         bits machine this function is available under the name &lt;CODE&gt;fopen&lt;/CODE&gt;
         and so transparently replaces the old interface.
        </synopsis>
    </function>
  </construct>
  <construct id="function-freopen" type="function">
    <function returntype="FILE *">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="const char *opentype"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function is like a combination of &lt;CODE&gt;fclose&lt;/CODE&gt; and &lt;CODE&gt;fopen&lt;/CODE&gt;.
         It first closes the stream referred to by &lt;VAR&gt;stream&lt;/VAR&gt;, ignoring any
         errors that are detected in the process.  (Because errors are ignored,
         you should not use &lt;CODE&gt;freopen&lt;/CODE&gt; on an output stream if you have
         actually done any output using the stream.)  Then the file named by
         &lt;VAR&gt;filename&lt;/VAR&gt; is opened with mode &lt;VAR&gt;opentype&lt;/VAR&gt; as for &lt;CODE&gt;fopen&lt;/CODE&gt;,
         and associated with the same stream object &lt;VAR&gt;stream&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; If the operation fails, a null pointer is returned; otherwise,
         &lt;CODE&gt;freopen&lt;/CODE&gt; returns &lt;VAR&gt;stream&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;freopen&lt;/CODE&gt; has traditionally been used to connect a standard stream
         such as &lt;CODE&gt;stdin&lt;/CODE&gt; with a file of your own choice.  This is useful in
         programs in which use of a standard stream for certain purposes is
         hard-coded.  In the GNU C library, you can simply close the standard
         streams and open new ones with &lt;CODE&gt;fopen&lt;/CODE&gt;.  But other systems lack
         this ability, so using &lt;CODE&gt;freopen&lt;/CODE&gt; is more portable.
         &lt;br&gt;&lt;br&gt; When the sources are compiling with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; on a
         32 bit machine this function is in fact &lt;CODE&gt;freopen64&lt;/CODE&gt; since the LFS
         interface replaces transparently the old interface.
        </synopsis>
    </function>
  </construct>
  <construct id="function-freopen64" type="function">
    <function returntype="FILE *">
      <prototype>
        <parameter content="const char *filename"/>
        <parameter content="const char *opentype"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;freopen&lt;/CODE&gt;.  The only difference is that
         on 32 bit machine the stream returned is able to read beyond the
         2^31 bytes limits imposed by the normal interface.  It should be
         noted that the stream pointed to by &lt;VAR&gt;stream&lt;/VAR&gt; need not be opened
         using &lt;CODE&gt;fopen64&lt;/CODE&gt; or &lt;CODE&gt;freopen64&lt;/CODE&gt; since its mode is not important
         for this function.
         &lt;br&gt;&lt;br&gt; If the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; on a 32
         bits machine this function is available under the name &lt;CODE&gt;freopen&lt;/CODE&gt;
         and so transparently replaces the old interface.
        </synopsis>
    </function>
  </construct>
  <construct id="function-__freadable" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio_ext.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;__freadable&lt;/CODE&gt; function determines whether the stream
         &lt;VAR&gt;stream&lt;/VAR&gt; was opened to allow reading.  In this case the return value
         is nonzero.  For write-only streams the function returns zero.
         &lt;br&gt;&lt;br&gt; This function is declared in &lt;TT&gt;stdio_ext.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-__fwritable" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio_ext.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;__fwritable&lt;/CODE&gt; function determines whether the stream
         &lt;VAR&gt;stream&lt;/VAR&gt; was opened to allow writing.  In this case the return value
         is nonzero.  For read-only streams the function returns zero.
         &lt;br&gt;&lt;br&gt; This function is declared in &lt;TT&gt;stdio_ext.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-__freading" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio_ext.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;__freading&lt;/CODE&gt; function determines whether the stream
         &lt;VAR&gt;stream&lt;/VAR&gt; was last read from or whether it is opened read-only.  In
         this case the return value is nonzero, otherwise it is zero.
         Determining whether a stream opened for reading and writing was last
         used for writing allows to draw conclusions about the content about the
         buffer, among other things.
         &lt;br&gt;&lt;br&gt; This function is declared in &lt;TT&gt;stdio_ext.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-__fwriting" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio_ext.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;__fwriting&lt;/CODE&gt; function determines whether the stream
         &lt;VAR&gt;stream&lt;/VAR&gt; was last written to or whether it is opened write-only.  In
         this case the return value is nonzero, otherwise it is zero.
         &lt;br&gt;&lt;br&gt; This function is declared in &lt;TT&gt;stdio_ext.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fclose" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function causes &lt;VAR&gt;stream&lt;/VAR&gt; to be closed and the connection to
         the corresponding file to be broken.  Any buffered output is written
         and any buffered input is discarded.  The &lt;CODE&gt;fclose&lt;/CODE&gt; function returns
         a value of &lt;CODE&gt;0&lt;/CODE&gt; if the file was closed successfully, and &lt;CODE&gt;EOF&lt;/CODE&gt;
         if an error was detected.
         &lt;br&gt;&lt;br&gt; It is important to check for errors when you call &lt;CODE&gt;fclose&lt;/CODE&gt; to close
         an output stream, because real, everyday errors can be detected at this
         time.  For example, when &lt;CODE&gt;fclose&lt;/CODE&gt; writes the remaining buffered
         output, it might get an error because the disk is full.  Even if you
         know the buffer is empty, errors can still occur when closing a file if
         you are using NFS.
         &lt;br&gt;&lt;br&gt; The function &lt;CODE&gt;fclose&lt;/CODE&gt; is declared in &lt;TT&gt;stdio.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fcloseall" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function causes all open streams of the process to be closed and
         the connection to corresponding files to be broken.  All buffered data
         is written and any buffered input is discarded.  The &lt;CODE&gt;fcloseall&lt;/CODE&gt;
         function returns a value of &lt;CODE&gt;0&lt;/CODE&gt; if all the files were closed
         successfully, and &lt;CODE&gt;EOF&lt;/CODE&gt; if an error was detected.
         &lt;br&gt;&lt;br&gt; This function should be used only in special situations, e.g., when an
         error occurred and the program must be aborted.  Normally each single
         stream should be closed separately so that problems with individual
         streams can be identified.  It is also problematic since the standard
         streams  will also be closed.
         &lt;br&gt;&lt;br&gt; The function &lt;CODE&gt;fcloseall&lt;/CODE&gt; is declared in &lt;TT&gt;stdio.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-flockfile" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;flockfile&lt;/CODE&gt; function acquires the internal locking object
         associated with the stream &lt;VAR&gt;stream&lt;/VAR&gt;.  This ensures that no other
         thread can explicitly through &lt;CODE&gt;flockfile&lt;/CODE&gt;/&lt;CODE&gt;ftrylockfile&lt;/CODE&gt; or
         implicit through a call of a stream function lock the stream.  The
         thread will block until the lock is acquired.  An explicit call to
         &lt;CODE&gt;funlockfile&lt;/CODE&gt; has to be used to release the lock.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ftrylockfile" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;ftrylockfile&lt;/CODE&gt; function tries to acquire the internal locking
         object associated with the stream &lt;VAR&gt;stream&lt;/VAR&gt; just like
         &lt;CODE&gt;flockfile&lt;/CODE&gt;.  But unlike &lt;CODE&gt;flockfile&lt;/CODE&gt; this function does not
         block if the lock is not available.  &lt;CODE&gt;ftrylockfile&lt;/CODE&gt; returns zero if
         the lock was successfully acquired.  Otherwise the stream is locked by
         another thread.
        </synopsis>
    </function>
  </construct>
  <construct id="function-funlockfile" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;funlockfile&lt;/CODE&gt; function releases the internal locking object of
         the stream &lt;VAR&gt;stream&lt;/VAR&gt;. The stream must have been locked before by a
         call to &lt;CODE&gt;flockfile&lt;/CODE&gt; or a successful call of &lt;CODE&gt;ftrylockfile&lt;/CODE&gt;.
         The implicit locking performed by the stream operations do not count.
         The &lt;CODE&gt;funlockfile&lt;/CODE&gt; function does not return an error status and the
         behavior of a call for a stream which is not locked by the current
         thread is undefined.
        </synopsis>
    </function>
  </construct>
  <construct id="function-__fsetlocking" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
        <parameter content="int type"/>
      </prototype>
      <headers>
        <header filename = "stdio_ext.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;__fsetlocking&lt;/CODE&gt; function can be used to select whether the
         stream operations will implicitly acquire the locking object of the
         stream &lt;VAR&gt;stream&lt;/VAR&gt;.  By default this is done but it can be disabled and
         reinstated using this function.  There are three values defined for the
         &lt;VAR&gt;type&lt;/VAR&gt; parameter.
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;FSETLOCKING_INTERNAL&lt;/CODE&gt;
&lt;DD&gt;
         The stream &lt;CODE&gt;stream&lt;/CODE&gt; will from now on use the default internal
         locking.  Every stream operation with exception of the &lt;CODE&gt;_unlocked&lt;/CODE&gt;
         variants will implicitly lock the stream.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;FSETLOCKING_BYCALLER&lt;/CODE&gt;
&lt;DD&gt;
         After the &lt;CODE&gt;__fsetlocking&lt;/CODE&gt; function returns the user is responsible
         for locking the stream.  None of the stream operations will implicitly
         do this anymore until the state is set back to
         &lt;CODE&gt;FSETLOCKING_INTERNAL&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;DT&gt;&lt;CODE&gt;FSETLOCKING_QUERY&lt;/CODE&gt;
&lt;DD&gt;
         &lt;CODE&gt;__fsetlocking&lt;/CODE&gt; only queries the current locking state of the
         stream.  The return value will be &lt;CODE&gt;FSETLOCKING_INTERNAL&lt;/CODE&gt; or
         &lt;CODE&gt;FSETLOCKING_BYCALLER&lt;/CODE&gt; depending on the state.
         &lt;/DL&gt;
         &lt;br&gt;&lt;br&gt; The return value of &lt;CODE&gt;__fsetlocking&lt;/CODE&gt; is either
         &lt;CODE&gt;FSETLOCKING_INTERNAL&lt;/CODE&gt; or &lt;CODE&gt;FSETLOCKING_BYCALLER&lt;/CODE&gt; depending on
         the state of the stream before the call.
         &lt;br&gt;&lt;br&gt; This function and the values for the &lt;VAR&gt;type&lt;/VAR&gt; parameter are declared
         in &lt;TT&gt;stdio_ext.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fwide" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
        <parameter content="int mode"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;fwide&lt;/CODE&gt; function can be used to set and query the state of the
         orientation of the stream &lt;VAR&gt;stream&lt;/VAR&gt;.  If the &lt;VAR&gt;mode&lt;/VAR&gt; parameter has
         a positive value the streams get wide oriented, for negative values
         narrow oriented.  It is not possible to overwrite previous orientations
         with &lt;CODE&gt;fwide&lt;/CODE&gt;.  I.e., if the stream &lt;VAR&gt;stream&lt;/VAR&gt; was already
         oriented before the call nothing is done.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;mode&lt;/VAR&gt; is zero the current orientation state is queried and
         nothing is changed.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;fwide&lt;/CODE&gt; function returns a negative value, zero, or a positive
         value if the stream is narrow, not at all, or wide oriented
         respectively.
         &lt;br&gt;&lt;br&gt; This function was introduced in Amendment 1 to ISO C90 and is
         declared in &lt;TT&gt;wchar.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fputc" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int c"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fputc&lt;/CODE&gt; function converts the character &lt;VAR&gt;c&lt;/VAR&gt; to type
         &lt;CODE&gt;unsigned char&lt;/CODE&gt;, and writes it to the stream &lt;VAR&gt;stream&lt;/VAR&gt;.
         &lt;CODE&gt;EOF&lt;/CODE&gt; is returned if a write error occurs; otherwise the
         character &lt;VAR&gt;c&lt;/VAR&gt; is returned.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fputwc" type="function">
    <function returntype="wint_t">
      <prototype>
        <parameter content="wchar_t wc"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fputwc&lt;/CODE&gt; function writes the wide character &lt;VAR&gt;wc&lt;/VAR&gt; to the
         stream &lt;VAR&gt;stream&lt;/VAR&gt;.  &lt;CODE&gt;WEOF&lt;/CODE&gt; is returned if a write error occurs;
         otherwise the character &lt;VAR&gt;wc&lt;/VAR&gt; is returned.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fputc_unlocked" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int c"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fputc_unlocked&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;fputc&lt;/CODE&gt;
         function except that it does not implicitly lock the stream.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fputwc_unlocked" type="function">
    <function returntype="wint_t">
      <prototype>
        <parameter content="wint_t wc"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fputwc_unlocked&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;fputwc&lt;/CODE&gt;
         function except that it does not implicitly lock the stream.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-putc" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int c"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This is just like &lt;CODE&gt;fputc&lt;/CODE&gt;, except that most systems implement it as
         a macro, making it faster.  One consequence is that it may evaluate the
         &lt;VAR&gt;stream&lt;/VAR&gt; argument more than once, which is an exception to the
         general rule for macros.  &lt;CODE&gt;putc&lt;/CODE&gt; is usually the best function to
         use for writing a single character.
        </synopsis>
    </function>
  </construct>
  <construct id="function-putwc" type="function">
    <function returntype="wint_t">
      <prototype>
        <parameter content="wchar_t wc"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        This is just like &lt;CODE&gt;fputwc&lt;/CODE&gt;, except that it can be implement as
         a macro, making it faster.  One consequence is that it may evaluate the
         &lt;VAR&gt;stream&lt;/VAR&gt; argument more than once, which is an exception to the
         general rule for macros.  &lt;CODE&gt;putwc&lt;/CODE&gt; is usually the best function to
         use for writing a single wide character.
        </synopsis>
    </function>
  </construct>
  <construct id="function-putc_unlocked" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int c"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;putc_unlocked&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;putc&lt;/CODE&gt;
         function except that it does not implicitly lock the stream.
        </synopsis>
    </function>
  </construct>
  <construct id="function-putwc_unlocked" type="function">
    <function returntype="wint_t">
      <prototype>
        <parameter content="wchar_t wc"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;putwc_unlocked&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;putwc&lt;/CODE&gt;
         function except that it does not implicitly lock the stream.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-putchar" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int c"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;putchar&lt;/CODE&gt; function is equivalent to &lt;CODE&gt;putc&lt;/CODE&gt; with
         &lt;CODE&gt;stdout&lt;/CODE&gt; as the value of the &lt;VAR&gt;stream&lt;/VAR&gt; argument.
        </synopsis>
    </function>
  </construct>
  <construct id="function-putwchar" type="function">
    <function returntype="wint_t">
      <prototype>
        <parameter content="wchar_t wc"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;putwchar&lt;/CODE&gt; function is equivalent to &lt;CODE&gt;putwc&lt;/CODE&gt; with
         &lt;CODE&gt;stdout&lt;/CODE&gt; as the value of the &lt;VAR&gt;stream&lt;/VAR&gt; argument.
        </synopsis>
    </function>
  </construct>
  <construct id="function-putchar_unlocked" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int c"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;putchar_unlocked&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;putchar&lt;/CODE&gt;
         function except that it does not implicitly lock the stream.
        </synopsis>
    </function>
  </construct>
  <construct id="function-putwchar_unlocked" type="function">
    <function returntype="wint_t">
      <prototype>
        <parameter content="wchar_t wc"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;putwchar_unlocked&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;putwchar&lt;/CODE&gt;
         function except that it does not implicitly lock the stream.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fputs" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *s"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The function &lt;CODE&gt;fputs&lt;/CODE&gt; writes the string &lt;VAR&gt;s&lt;/VAR&gt; to the stream
         &lt;VAR&gt;stream&lt;/VAR&gt;.  The terminating null character is not written.
         This function does &lt;EM&gt;not&lt;/EM&gt; add a newline character, either.
         It outputs only the characters in the string.
         &lt;br&gt;&lt;br&gt; This function returns &lt;CODE&gt;EOF&lt;/CODE&gt; if a write error occurs, and otherwise
         a non-negative value.
         &lt;br&gt;&lt;br&gt; For example:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         fputs ("Are ", stdout);&lt;br&gt;
         fputs ("you ", stdout);&lt;br&gt;
         fputs ("hungry?\n", stdout);&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt;
         outputs the text &lt;samp&gt;Are you hungry?&lt;/samp&gt; followed by a newline.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fputws" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const wchar_t *ws"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The function &lt;CODE&gt;fputws&lt;/CODE&gt; writes the wide character string &lt;VAR&gt;ws&lt;/VAR&gt; to
         the stream &lt;VAR&gt;stream&lt;/VAR&gt;.  The terminating null character is not written.
         This function does &lt;EM&gt;not&lt;/EM&gt; add a newline character, either.  It
         outputs only the characters in the string.
         &lt;br&gt;&lt;br&gt; This function returns &lt;CODE&gt;WEOF&lt;/CODE&gt; if a write error occurs, and otherwise
         a non-negative value.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fputs_unlocked" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *s"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fputs_unlocked&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;fputs&lt;/CODE&gt;
         function except that it does not implicitly lock the stream.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fputws_unlocked" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const wchar_t *ws"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fputws_unlocked&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;fputws&lt;/CODE&gt;
         function except that it does not implicitly lock the stream.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-puts" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *s"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;puts&lt;/CODE&gt; function writes the string &lt;VAR&gt;s&lt;/VAR&gt; to the stream
         &lt;CODE&gt;stdout&lt;/CODE&gt; followed by a newline.  The terminating null character of
         the string is not written.  (Note that &lt;CODE&gt;fputs&lt;/CODE&gt; does &lt;EM&gt;not&lt;/EM&gt;
         write a newline as this function does.)
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;puts&lt;/CODE&gt; is the most convenient function for printing simple
         messages.  For example:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         puts ("This is a message.");&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt;
         outputs the text &lt;samp&gt;This is a message.&lt;/samp&gt; followed by a newline.
        </synopsis>
    </function>
  </construct>
  <construct id="function-putw" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int w"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function writes the word &lt;VAR&gt;w&lt;/VAR&gt; (that is, an &lt;CODE&gt;int&lt;/CODE&gt;) to
         &lt;VAR&gt;stream&lt;/VAR&gt;.  It is provided for compatibility with SVID, but we
         recommend you use &lt;CODE&gt;fwrite&lt;/CODE&gt; instead .
        </synopsis>
    </function>
  </construct>
  <construct id="function-fgetc" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function reads the next character as an &lt;CODE&gt;unsigned char&lt;/CODE&gt; from
         the stream &lt;VAR&gt;stream&lt;/VAR&gt; and returns its value, converted to an
         &lt;CODE&gt;int&lt;/CODE&gt;.  If an end-of-file condition or read error occurs,
         &lt;CODE&gt;EOF&lt;/CODE&gt; is returned instead.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fgetwc" type="function">
    <function returntype="wint_t">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        This function reads the next wide character from the stream &lt;VAR&gt;stream&lt;/VAR&gt;
         and returns its value.  If an end-of-file condition or read error
         occurs, &lt;CODE&gt;WEOF&lt;/CODE&gt; is returned instead.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fgetc_unlocked" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fgetc_unlocked&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;fgetc&lt;/CODE&gt;
         function except that it does not implicitly lock the stream.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fgetwc_unlocked" type="function">
    <function returntype="wint_t">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fgetwc_unlocked&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;fgetwc&lt;/CODE&gt;
         function except that it does not implicitly lock the stream.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getc" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This is just like &lt;CODE&gt;fgetc&lt;/CODE&gt;, except that it is permissible (and
         typical) for it to be implemented as a macro that evaluates the
         &lt;VAR&gt;stream&lt;/VAR&gt; argument more than once.  &lt;CODE&gt;getc&lt;/CODE&gt; is often highly
         optimized, so it is usually the best function to use to read a single
         character.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getwc" type="function">
    <function returntype="wint_t">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        This is just like &lt;CODE&gt;fgetwc&lt;/CODE&gt;, except that it is permissible for it to
         be implemented as a macro that evaluates the &lt;VAR&gt;stream&lt;/VAR&gt; argument more
         than once.  &lt;CODE&gt;getwc&lt;/CODE&gt; can be highly optimized, so it is usually the
         best function to use to read a single wide character.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getc_unlocked" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getc_unlocked&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;getc&lt;/CODE&gt;
         function except that it does not implicitly lock the stream.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getwc_unlocked" type="function">
    <function returntype="wint_t">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getwc_unlocked&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;getwc&lt;/CODE&gt;
         function except that it does not implicitly lock the stream.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getchar" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getchar&lt;/CODE&gt; function is equivalent to &lt;CODE&gt;getc&lt;/CODE&gt; with &lt;CODE&gt;stdin&lt;/CODE&gt;
         as the value of the &lt;VAR&gt;stream&lt;/VAR&gt; argument.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getwchar" type="function">
    <function returntype="wint_t">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getwchar&lt;/CODE&gt; function is equivalent to &lt;CODE&gt;getwc&lt;/CODE&gt; with &lt;CODE&gt;stdin&lt;/CODE&gt;
         as the value of the &lt;VAR&gt;stream&lt;/VAR&gt; argument.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getchar_unlocked" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getchar_unlocked&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;getchar&lt;/CODE&gt;
         function except that it does not implicitly lock the stream.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getwchar_unlocked" type="function">
    <function returntype="wint_t">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;getwchar_unlocked&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;getwchar&lt;/CODE&gt;
         function except that it does not implicitly lock the stream.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getw" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function reads a word (that is, an &lt;CODE&gt;int&lt;/CODE&gt;) from &lt;VAR&gt;stream&lt;/VAR&gt;.
         It's provided for compatibility with SVID.  We recommend you use
         &lt;CODE&gt;fread&lt;/CODE&gt; instead. Unlike &lt;CODE&gt;getc&lt;/CODE&gt;,
         any &lt;CODE&gt;int&lt;/CODE&gt; value could be a valid result.  &lt;CODE&gt;getw&lt;/CODE&gt; returns
         &lt;CODE&gt;EOF&lt;/CODE&gt; when it encounters end-of-file or an error, but there is no
         way to distinguish this from an input word with value -1.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getline" type="function">
    <function returntype="ssize_t">
      <prototype>
        <parameter content="char **lineptr"/>
        <parameter content="size_t *n"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function reads an entire line from &lt;VAR&gt;stream&lt;/VAR&gt;, storing the text
         (including the newline and a terminating null character) in a buffer
         and storing the buffer address in &lt;CODE&gt;*&lt;VAR&gt;lineptr&lt;/VAR&gt;&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; Before calling &lt;CODE&gt;getline&lt;/CODE&gt;, you should place in &lt;CODE&gt;*&lt;VAR&gt;lineptr&lt;/VAR&gt;&lt;/CODE&gt;
         the address of a buffer &lt;CODE&gt;*&lt;VAR&gt;n&lt;/VAR&gt;&lt;/CODE&gt; bytes long, allocated with
         &lt;CODE&gt;malloc&lt;/CODE&gt;.  If this buffer is long enough to hold the line,
         &lt;CODE&gt;getline&lt;/CODE&gt; stores the line in this buffer.  Otherwise,
         &lt;CODE&gt;getline&lt;/CODE&gt; makes the buffer bigger using &lt;CODE&gt;realloc&lt;/CODE&gt;, storing the
         new buffer address back in &lt;CODE&gt;*&lt;VAR&gt;lineptr&lt;/VAR&gt;&lt;/CODE&gt; and the increased size
         back in &lt;CODE&gt;*&lt;VAR&gt;n&lt;/VAR&gt;&lt;/CODE&gt;.
         .
         &lt;br&gt;&lt;br&gt; If you set &lt;CODE&gt;*&lt;VAR&gt;lineptr&lt;/VAR&gt;&lt;/CODE&gt; to a null pointer, and &lt;CODE&gt;*&lt;VAR&gt;n&lt;/VAR&gt;&lt;/CODE&gt;
         to zero, before the call, then &lt;CODE&gt;getline&lt;/CODE&gt; allocates the initial
         buffer for you by calling &lt;CODE&gt;malloc&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; In either case, when &lt;CODE&gt;getline&lt;/CODE&gt; returns,  &lt;CODE&gt;*&lt;VAR&gt;lineptr&lt;/VAR&gt;&lt;/CODE&gt; is
         a &lt;CODE&gt;char *&lt;/CODE&gt; which points to the text of the line.
         &lt;br&gt;&lt;br&gt; When &lt;CODE&gt;getline&lt;/CODE&gt; is successful, it returns the number of characters
         read (including the newline, but not including the terminating null).
         This value enables you to distinguish null characters that are part of
         the line from the null character inserted as a terminator.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension, but it is the recommended way to read
         lines from a stream.  The alternative standard functions are unreliable.
         &lt;br&gt;&lt;br&gt; If an error occurs or end of file is reached without any bytes read,
         &lt;CODE&gt;getline&lt;/CODE&gt; returns &lt;CODE&gt;-1&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-getdelim" type="function">
    <function returntype="ssize_t">
      <prototype>
        <parameter content="char **lineptr"/>
        <parameter content="size_t *n"/>
        <parameter content="int delimiter"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function is like &lt;CODE&gt;getline&lt;/CODE&gt; except that the character which
         tells it to stop reading is not necessarily newline.  The argument
         &lt;VAR&gt;delimiter&lt;/VAR&gt; specifies the delimiter character; &lt;CODE&gt;getdelim&lt;/CODE&gt; keeps
         reading until it sees that character (or end of file).
         &lt;br&gt;&lt;br&gt; The text is stored in &lt;VAR&gt;lineptr&lt;/VAR&gt;, including the delimiter character
         and a terminating null.  Like &lt;CODE&gt;getline&lt;/CODE&gt;, &lt;CODE&gt;getdelim&lt;/CODE&gt; makes
         &lt;VAR&gt;lineptr&lt;/VAR&gt; bigger if it isn't big enough.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;getline&lt;/CODE&gt; is in fact implemented in terms of &lt;CODE&gt;getdelim&lt;/CODE&gt;, just
         like this:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         ssize_t&lt;br&gt;
         getline (char **lineptr, size_t *n, FILE *stream)&lt;br&gt;
         {&lt;br&gt;
           return getdelim (lineptr, n, '\n', stream);&lt;br&gt;
         }&lt;br&gt;
         &lt;/pre&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-fgets" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="char *s"/>
        <parameter content="int count"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fgets&lt;/CODE&gt; function reads characters from the stream &lt;VAR&gt;stream&lt;/VAR&gt;
         up to and including a newline character and stores them in the string
         &lt;VAR&gt;s&lt;/VAR&gt;, adding a null character to mark the end of the string.  You
         must supply &lt;VAR&gt;count&lt;/VAR&gt; characters worth of space in &lt;VAR&gt;s&lt;/VAR&gt;, but the
         number of characters read is at most &lt;VAR&gt;count&lt;/VAR&gt;  1.  The extra
         character space is used to hold the null character at the end of the
         string.
         &lt;br&gt;&lt;br&gt; If the system is already at end of file when you call &lt;CODE&gt;fgets&lt;/CODE&gt;, then
         the contents of the array &lt;VAR&gt;s&lt;/VAR&gt; are unchanged and a null pointer is
         returned.  A null pointer is also returned if a read error occurs.
         Otherwise, the return value is the pointer &lt;VAR&gt;s&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; Warning:  If the input data has a null character, you can't tell.
         So don't use &lt;CODE&gt;fgets&lt;/CODE&gt; unless you know the data cannot contain a null.
         Don't use it to read files edited by the user because, if the user inserts
         a null character, you should either handle it properly or print a clear
         error message.  We recommend using &lt;CODE&gt;getline&lt;/CODE&gt; instead of &lt;CODE&gt;fgets&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fgetws" type="function">
    <function returntype="wchar_t *">
      <prototype>
        <parameter content="wchar_t *ws"/>
        <parameter content="int count"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fgetws&lt;/CODE&gt; function reads wide characters from the stream
         &lt;VAR&gt;stream&lt;/VAR&gt; up to and including a newline character and stores them in
         the string &lt;VAR&gt;ws&lt;/VAR&gt;, adding a null wide character to mark the end of the
         string.  You must supply &lt;VAR&gt;count&lt;/VAR&gt; wide characters worth of space in
         &lt;VAR&gt;ws&lt;/VAR&gt;, but the number of characters read is at most &lt;VAR&gt;count&lt;/VAR&gt;
          1.  The extra character space is used to hold the null wide
         character at the end of the string.
         &lt;br&gt;&lt;br&gt; If the system is already at end of file when you call &lt;CODE&gt;fgetws&lt;/CODE&gt;, then
         the contents of the array &lt;VAR&gt;ws&lt;/VAR&gt; are unchanged and a null pointer is
         returned.  A null pointer is also returned if a read error occurs.
         Otherwise, the return value is the pointer &lt;VAR&gt;ws&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; Warning: If the input data has a null wide character (which are
         null bytes in the input stream), you can't tell.  So don't use
         &lt;CODE&gt;fgetws&lt;/CODE&gt; unless you know the data cannot contain a null.  Don't use
         it to read files edited by the user because, if the user inserts a null
         character, you should either handle it properly or print a clear error
         message.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fgets_unlocked" type="function">
    <function returntype="char *">
      <prototype>
        <parameter content="char *s"/>
        <parameter content="int count"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fgets_unlocked&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;fgets&lt;/CODE&gt;
         function except that it does not implicitly lock the stream.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fgetws_unlocked" type="function">
    <function returntype="wchar_t *">
      <prototype>
        <parameter content="wchar_t *ws"/>
        <parameter content="int count"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fgetws_unlocked&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;fgetws&lt;/CODE&gt;
         function except that it does not implicitly lock the stream.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ungetc" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int c"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;ungetc&lt;/CODE&gt; function pushes back the character &lt;VAR&gt;c&lt;/VAR&gt; onto the
         input stream &lt;VAR&gt;stream&lt;/VAR&gt;.  So the next input from &lt;VAR&gt;stream&lt;/VAR&gt; will
         read &lt;VAR&gt;c&lt;/VAR&gt; before anything else.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;c&lt;/VAR&gt; is &lt;CODE&gt;EOF&lt;/CODE&gt;, &lt;CODE&gt;ungetc&lt;/CODE&gt; does nothing and just returns
         &lt;CODE&gt;EOF&lt;/CODE&gt;.  This lets you call &lt;CODE&gt;ungetc&lt;/CODE&gt; with the return value of
         &lt;CODE&gt;getc&lt;/CODE&gt; without needing to check for an error from &lt;CODE&gt;getc&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The character that you push back doesn't have to be the same as the last
         character that was actually read from the stream.  In fact, it isn't
         necessary to actually read any characters from the stream before
         unreading them with &lt;CODE&gt;ungetc&lt;/CODE&gt;!  But that is a strange way to write a
         program; usually &lt;CODE&gt;ungetc&lt;/CODE&gt; is used only to unread a character that
         was just read from the same stream.  The GNU C library supports this
         even on files opened in binary mode, but other systems might not.
         &lt;br&gt;&lt;br&gt; The GNU C library only supports one character of pushback---in other
         words, it does not work to call &lt;CODE&gt;ungetc&lt;/CODE&gt; twice without doing input
         in between.  Other systems might let you push back multiple characters;
         then reading from the stream retrieves the characters in the reverse
         order that they were pushed.
         &lt;br&gt;&lt;br&gt; Pushing back characters doesn't alter the file; only the internal
         buffering for the stream is affected.  If a file positioning function
         (such as &lt;CODE&gt;fseek&lt;/CODE&gt;, &lt;CODE&gt;fseeko&lt;/CODE&gt; or &lt;CODE&gt;rewind&lt;/CODE&gt;; ) is called, any pending pushed-back characters are
         discarded.
         &lt;br&gt;&lt;br&gt; Unreading a character on a stream that is at end of file clears the
         end-of-file indicator for the stream, because it makes the character of
         input available.  After you read that character, trying to read again
         will encounter end of file.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ungetwc" type="function">
    <function returntype="wint_t">
      <prototype>
        <parameter content="wint_t wc"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;ungetwc&lt;/CODE&gt; function behaves just like &lt;CODE&gt;ungetc&lt;/CODE&gt; just that it
         pushes back a wide character.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fread" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="void *data"/>
        <parameter content="size_t size"/>
        <parameter content="size_t count"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function reads up to &lt;VAR&gt;count&lt;/VAR&gt; objects of size &lt;VAR&gt;size&lt;/VAR&gt; into
         the array &lt;VAR&gt;data&lt;/VAR&gt;, from the stream &lt;VAR&gt;stream&lt;/VAR&gt;.  It returns the
         number of objects actually read, which might be less than &lt;VAR&gt;count&lt;/VAR&gt; if
         a read error occurs or the end of the file is reached.  This function
         returns a value of zero (and doesn't read anything) if either &lt;VAR&gt;size&lt;/VAR&gt;
         or &lt;VAR&gt;count&lt;/VAR&gt; is zero.
         &lt;br&gt;&lt;br&gt; If &lt;CODE&gt;fread&lt;/CODE&gt; encounters end of file in the middle of an object, it
         returns the number of complete objects read, and discards the partial
         object.  Therefore, the stream remains at the actual end of the file.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fread_unlocked" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="void *data"/>
        <parameter content="size_t size"/>
        <parameter content="size_t count"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fread_unlocked&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;fread&lt;/CODE&gt;
         function except that it does not implicitly lock the stream.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fwrite" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="const void *data"/>
        <parameter content="size_t size"/>
        <parameter content="size_t count"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function writes up to &lt;VAR&gt;count&lt;/VAR&gt; objects of size &lt;VAR&gt;size&lt;/VAR&gt; from
         the array &lt;VAR&gt;data&lt;/VAR&gt;, to the stream &lt;VAR&gt;stream&lt;/VAR&gt;.  The return value is
         normally &lt;VAR&gt;count&lt;/VAR&gt;, if the call succeeds.  Any other value indicates
         some sort of error, such as running out of space.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fwrite_unlocked" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="const void *data"/>
        <parameter content="size_t size"/>
        <parameter content="size_t count"/>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fwrite_unlocked&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;fwrite&lt;/CODE&gt;
         function except that it does not implicitly lock the stream.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-printf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *template"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;printf&lt;/CODE&gt; function prints the optional arguments under the
         control of the template string &lt;VAR&gt;template&lt;/VAR&gt; to the stream
         &lt;CODE&gt;stdout&lt;/CODE&gt;.  It returns the number of characters printed, or a
         negative value if there was an output error.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wprintf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const wchar_t *template"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wprintf&lt;/CODE&gt; function prints the optional arguments under the
         control of the wide template string &lt;VAR&gt;template&lt;/VAR&gt; to the stream
         &lt;CODE&gt;stdout&lt;/CODE&gt;.  It returns the number of wide characters printed, or a
         negative value if there was an output error.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fprintf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
        <parameter content="const char *template"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function is just like &lt;CODE&gt;printf&lt;/CODE&gt;, except that the output is
         written to the stream &lt;VAR&gt;stream&lt;/VAR&gt; instead of &lt;CODE&gt;stdout&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fwprintf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
        <parameter content="const wchar_t *template"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        This function is just like &lt;CODE&gt;wprintf&lt;/CODE&gt;, except that the output is
         written to the stream &lt;VAR&gt;stream&lt;/VAR&gt; instead of &lt;CODE&gt;stdout&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-sprintf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="char *s"/>
        <parameter content="const char *template"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This is like &lt;CODE&gt;printf&lt;/CODE&gt;, except that the output is stored in the character
         array &lt;VAR&gt;s&lt;/VAR&gt; instead of written to a stream.  A null character is written
         to mark the end of the string.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;sprintf&lt;/CODE&gt; function returns the number of characters stored in
         the array &lt;VAR&gt;s&lt;/VAR&gt;, not including the terminating null character.
         &lt;br&gt;&lt;br&gt; The behavior of this function is undefined if copying takes place
         between objects that overlap---for example, if &lt;VAR&gt;s&lt;/VAR&gt; is also given
         as an argument to be printed under control of the &lt;samp&gt;%s&lt;/samp&gt; conversion.
         .
         &lt;br&gt;&lt;br&gt; Warning: The &lt;CODE&gt;sprintf&lt;/CODE&gt; function can be &lt;h3&gt;dangerous&lt;/h3&gt;
         because it can potentially output more characters than can fit in the
         allocation size of the string &lt;VAR&gt;s&lt;/VAR&gt;.  Remember that the field width
         given in a conversion specification is only a &lt;EM&gt;minimum&lt;/EM&gt; value.
         &lt;br&gt;&lt;br&gt; To avoid this problem, you can use &lt;CODE&gt;snprintf&lt;/CODE&gt; or &lt;CODE&gt;asprintf&lt;/CODE&gt;,
         described below.
        </synopsis>
    </function>
  </construct>
  <construct id="function-swprintf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="wchar_t *s"/>
        <parameter content="size_t size"/>
        <parameter content="const wchar_t *template"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        This is like &lt;CODE&gt;wprintf&lt;/CODE&gt;, except that the output is stored in the
         wide character array &lt;VAR&gt;ws&lt;/VAR&gt; instead of written to a stream.  A null
         wide character is written to mark the end of the string.  The &lt;VAR&gt;size&lt;/VAR&gt;
         argument specifies the maximum number of characters to produce.  The
         trailing null character is counted towards this limit, so you should
         allocate at least &lt;VAR&gt;size&lt;/VAR&gt; wide characters for the string &lt;VAR&gt;ws&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The return value is the number of characters generated for the given
         input, excluding the trailing null.  If not all output fits into the
         provided buffer a negative value is returned.  You should try again with
         a bigger output string.  &lt;EM&gt;Note:&lt;/EM&gt; this is different from how
         &lt;CODE&gt;snprintf&lt;/CODE&gt; handles this situation.
         &lt;br&gt;&lt;br&gt; Note that the corresponding narrow stream function takes fewer
         parameters.  &lt;CODE&gt;swprintf&lt;/CODE&gt; in fact corresponds to the &lt;CODE&gt;snprintf&lt;/CODE&gt;
         function.  Since the &lt;CODE&gt;sprintf&lt;/CODE&gt; function can be dangerous and should
         be avoided the ISO C committee refused to make the same mistake
         again and decided to not define an function exactly corresponding to
         &lt;CODE&gt;sprintf&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-snprintf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="char *s"/>
        <parameter content="size_t size"/>
        <parameter content="const char *template"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;snprintf&lt;/CODE&gt; function is similar to &lt;CODE&gt;sprintf&lt;/CODE&gt;, except that
         the &lt;VAR&gt;size&lt;/VAR&gt; argument specifies the maximum number of characters to
         produce.  The trailing null character is counted towards this limit, so
         you should allocate at least &lt;VAR&gt;size&lt;/VAR&gt; characters for the string &lt;VAR&gt;s&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The return value is the number of characters which would be generated
         for the given input, excluding the trailing null.  If this value is
         greater or equal to &lt;VAR&gt;size&lt;/VAR&gt;, not all characters from the result have
         been stored in &lt;VAR&gt;s&lt;/VAR&gt;.  You should try again with a bigger output
         string.  Here is an example of doing this:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         &lt;br&gt;
         /* Construct a message describing the value of a variable&lt;br&gt;
            whose name is &lt;VAR&gt;name&lt;/VAR&gt; and whose value is &lt;VAR&gt;value&lt;/VAR&gt;. */&lt;br&gt;
         char *&lt;br&gt;
         make_message (char *name, char *value)&lt;br&gt;
         {&lt;br&gt;
           /* Guess we need no more than 100 chars of space. */&lt;br&gt;
           int size = 100;&lt;br&gt;
           char *buffer = (char *) xmalloc (size);&lt;br&gt;
           int nchars;&lt;br&gt;
         &lt;br&gt;
         &lt;br&gt;
           if (buffer == NULL)&lt;br&gt;
             return NULL;&lt;br&gt;
         &lt;br&gt;&lt;br&gt;  /* Try to print in the allocated space. */&lt;br&gt;
           nchars = snprintf (buffer, size, "value of %s is %s",&lt;br&gt;
                      name, value);&lt;br&gt;
         &lt;br&gt;
         &lt;br&gt;
           if (nchars &gt;= size)&lt;br&gt;
             {&lt;br&gt;
               /* Reallocate buffer now that we know&lt;br&gt;
              how much space is needed. */&lt;br&gt;
               size = nchars + 1;&lt;br&gt;
               buffer = (char *) xrealloc (buffer, size);&lt;br&gt;
         &lt;br&gt;&lt;br&gt;       if (buffer != NULL)&lt;br&gt;
             /* Try again. */&lt;br&gt;
             snprintf (buffer, size, "value of %s is %s",&lt;br&gt;
                   name, value);&lt;br&gt;
             }&lt;br&gt;
           /* The last call worked, return the string. */&lt;br&gt;
           return buffer;&lt;br&gt;
         }&lt;br&gt;
         &lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; In practice, it is often easier just to use &lt;CODE&gt;asprintf&lt;/CODE&gt;, below.
         &lt;br&gt;&lt;br&gt; Attention: In versions of the GNU C library prior to 2.1 the
         return value is the number of characters stored, not including the
         terminating null; unless there was not enough space in &lt;VAR&gt;s&lt;/VAR&gt; to
         store the result in which case &lt;CODE&gt;-1&lt;/CODE&gt; is returned.  This was
         changed in order to comply with the ISO C99 standard.
        </synopsis>
    </function>
  </construct>
  <construct id="function-asprintf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="char **ptr"/>
        <parameter content="const char *template"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;sprintf&lt;/CODE&gt;, except that it dynamically
         allocates a string (as with &lt;CODE&gt;malloc&lt;/CODE&gt;; ) to hold the output, instead of putting the output in a
         buffer you allocate in advance.  The &lt;VAR&gt;ptr&lt;/VAR&gt; argument should be the
         address of a &lt;CODE&gt;char *&lt;/CODE&gt; object, and a successful call to
         &lt;CODE&gt;asprintf&lt;/CODE&gt; stores a pointer to the newly allocated string at that
         location.
         &lt;br&gt;&lt;br&gt; The return value is the number of characters allocated for the buffer, or
         less than zero if an error occurred. Usually this means that the buffer
         could not be allocated.
         &lt;br&gt;&lt;br&gt; Here is how to use &lt;CODE&gt;asprintf&lt;/CODE&gt; to get the same result as the
         &lt;CODE&gt;snprintf&lt;/CODE&gt; example, but more easily:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         /* Construct a message describing the value of a variable&lt;br&gt;
            whose name is &lt;VAR&gt;name&lt;/VAR&gt; and whose value is &lt;VAR&gt;value&lt;/VAR&gt;. */&lt;br&gt;
         char *&lt;br&gt;
         make_message (char *name, char *value)&lt;br&gt;
         {&lt;br&gt;
           char *result;&lt;br&gt;
           if (asprintf (&amp;result, "value of %s is %s", name, value) &lt; 0)&lt;br&gt;
             return NULL;&lt;br&gt;
           return result;&lt;br&gt;
         }&lt;br&gt;
         &lt;/pre&gt;
        </synopsis>
    </function>
  </construct>
  <construct id="function-obstack_printf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="struct obstack *obstack"/>
        <parameter content="const char *template"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;asprintf&lt;/CODE&gt;, except that it uses the
         obstack &lt;VAR&gt;obstack&lt;/VAR&gt; to allocate the space.  .
         &lt;br&gt;&lt;br&gt; The characters are written onto the end of the current object.
         To get at them, you must finish the object with &lt;CODE&gt;obstack_finish&lt;/CODE&gt;
         .
        </synopsis>
    </function>
  </construct>
  <construct id="function-vprintf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *template"/>
        <parameter content="va_list ap"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;printf&lt;/CODE&gt; except that, instead of taking
         a variable number of arguments directly, it takes an argument list
         pointer &lt;VAR&gt;ap&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-vwprintf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const wchar_t *template"/>
        <parameter content="va_list ap"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;wprintf&lt;/CODE&gt; except that, instead of taking
         a variable number of arguments directly, it takes an argument list
         pointer &lt;VAR&gt;ap&lt;/VAR&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-vfprintf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
        <parameter content="const char *template"/>
        <parameter content="va_list ap"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This is the equivalent of &lt;CODE&gt;fprintf&lt;/CODE&gt; with the variable argument list
         specified directly as for &lt;CODE&gt;vprintf&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-vfwprintf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
        <parameter content="const wchar_t *template"/>
        <parameter content="va_list ap"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        This is the equivalent of &lt;CODE&gt;fwprintf&lt;/CODE&gt; with the variable argument list
         specified directly as for &lt;CODE&gt;vwprintf&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-vsprintf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="char *s"/>
        <parameter content="const char *template"/>
        <parameter content="va_list ap"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This is the equivalent of &lt;CODE&gt;sprintf&lt;/CODE&gt; with the variable argument list
         specified directly as for &lt;CODE&gt;vprintf&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-vswprintf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="wchar_t *s"/>
        <parameter content="size_t size"/>
        <parameter content="const wchar_t *template"/>
        <parameter content="va_list ap"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        This is the equivalent of &lt;CODE&gt;swprintf&lt;/CODE&gt; with the variable argument list
         specified directly as for &lt;CODE&gt;vwprintf&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-vsnprintf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="char *s"/>
        <parameter content="size_t size"/>
        <parameter content="const char *template"/>
        <parameter content="va_list ap"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This is the equivalent of &lt;CODE&gt;snprintf&lt;/CODE&gt; with the variable argument list
         specified directly as for &lt;CODE&gt;vprintf&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-vasprintf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="char **ptr"/>
        <parameter content="const char *template"/>
        <parameter content="va_list ap"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;vasprintf&lt;/CODE&gt; function is the equivalent of &lt;CODE&gt;asprintf&lt;/CODE&gt; with the
         variable argument list specified directly as for &lt;CODE&gt;vprintf&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-obstack_vprintf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="struct obstack *obstack"/>
        <parameter content="const char *template"/>
        <parameter content="va_list ap"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;obstack_vprintf&lt;/CODE&gt; function is the equivalent of
         &lt;CODE&gt;obstack_printf&lt;/CODE&gt; with the variable argument list specified directly
         as for &lt;CODE&gt;vprintf&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-parse_printf_format" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="const char *template"/>
        <parameter content="size_t n"/>
        <parameter content="int *argtypes"/>
      </prototype>
      <headers>
        <header filename = "printf.h"/>
      </headers>
        <synopsis>
        This function returns information about the number and types of
         arguments expected by the &lt;CODE&gt;printf&lt;/CODE&gt; template string &lt;VAR&gt;template&lt;/VAR&gt;.
         The information is stored in the array &lt;VAR&gt;argtypes&lt;/VAR&gt;; each element of
         this array describes one argument.  This information is encoded using
         the various &lt;samp&gt;PA_&lt;/samp&gt; macros, listed below.
         &lt;br&gt;&lt;br&gt; The argument &lt;VAR&gt;n&lt;/VAR&gt; specifies the number of elements in the array
         &lt;VAR&gt;argtypes&lt;/VAR&gt;.  This is the maximum number of elements that
         &lt;CODE&gt;parse_printf_format&lt;/CODE&gt; will try to write.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;parse_printf_format&lt;/CODE&gt; returns the total number of arguments required
         by &lt;VAR&gt;template&lt;/VAR&gt;.  If this number is greater than &lt;VAR&gt;n&lt;/VAR&gt;, then the
         information returned describes only the first &lt;VAR&gt;n&lt;/VAR&gt; arguments.  If you
         want information about additional arguments, allocate a bigger
         array and call &lt;CODE&gt;parse_printf_format&lt;/CODE&gt; again.
        </synopsis>
    </function>
  </construct>
  <construct id="function-register_printf_function" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int spec"/>
        <parameter content="printf_function handler-function"/>
        <parameter content="printf_arginfo_function arginfo-function"/>
      </prototype>
      <headers>
        <header filename = "printf.h"/>
      </headers>
        <synopsis>
        This function defines the conversion specifier character &lt;VAR&gt;spec&lt;/VAR&gt;.
         Thus, if &lt;VAR&gt;spec&lt;/VAR&gt; is &lt;CODE&gt;'Y'&lt;/CODE&gt;, it defines the conversion &lt;samp&gt;%Y&lt;/samp&gt;.
         You can redefine the built-in conversions like &lt;samp&gt;%s&lt;/samp&gt;, but flag
         characters like &lt;samp&gt;#&lt;/samp&gt; and type modifiers like &lt;samp&gt;l&lt;/samp&gt; can never be
         used as conversions; calling &lt;CODE&gt;register_printf_function&lt;/CODE&gt; for those
         characters has no effect.  It is advisable not to use lowercase letters,
         since the ISO C standard warns that additional lowercase letters may be
         standardized in future editions of the standard.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;handler-function&lt;/VAR&gt; is the function called by &lt;CODE&gt;printf&lt;/CODE&gt; and
         friends when this conversion appears in a template string.
         , for information about how to define
         a function to pass as this argument.  If you specify a null pointer, any
         existing handler function for &lt;VAR&gt;spec&lt;/VAR&gt; is removed.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;arginfo-function&lt;/VAR&gt; is the function called by
         &lt;CODE&gt;parse_printf_format&lt;/CODE&gt; when this conversion appears in a
         template string.  , for information
         about this.
         &lt;br&gt;&lt;br&gt;
         &lt;br&gt;&lt;br&gt; Attention: In the GNU C library versions before 2.0 the
         &lt;VAR&gt;arginfo-function&lt;/VAR&gt; function did not need to be installed unless
         the user used the &lt;CODE&gt;parse_printf_format&lt;/CODE&gt; function.  This has changed.
         Now a call to any of the &lt;CODE&gt;printf&lt;/CODE&gt; functions will call this
         function when this format specifier appears in the format string.
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;0&lt;/CODE&gt; on success, and &lt;CODE&gt;-1&lt;/CODE&gt; on failure
         (which occurs if &lt;VAR&gt;spec&lt;/VAR&gt; is out of range).
         &lt;br&gt;&lt;br&gt; You can redefine the standard output conversions, but this is probably
         not a good idea because of the potential for confusion.  Library routines
         written by other people could break if you do this.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-printf_info" type="struct">
    <structure>
        <synopsis>
        This structure is used to pass information about the options appearing
         in an instance of a conversion specifier in a &lt;CODE&gt;printf&lt;/CODE&gt; template
         string to the handler and arginfo functions for that specifier.  It
         contains the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="int prec">
            <synopsis>
            This is the precision specified.  The value is &lt;CODE&gt;-1&lt;/CODE&gt; if no precision
             was specified.  If the precision was given as &lt;samp&gt;*&lt;/samp&gt;, the
             &lt;CODE&gt;printf_info&lt;/CODE&gt; structure passed to the handler function contains the
             actual value retrieved from the argument list.  But the structure passed
             to the arginfo function contains a value of &lt;CODE&gt;INT_MIN&lt;/CODE&gt;, since the
             actual value is not known.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="int width">
            <synopsis>
            This is the minimum field width specified.  The value is &lt;CODE&gt;0&lt;/CODE&gt; if no
             width was specified.  If the field width was given as &lt;samp&gt;*&lt;/samp&gt;, the
             &lt;CODE&gt;printf_info&lt;/CODE&gt; structure passed to the handler function contains the
             actual value retrieved from the argument list.  But the structure passed
             to the arginfo function contains a value of &lt;CODE&gt;INT_MIN&lt;/CODE&gt;, since the
             actual value is not known.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="wchar_t spec">
            <synopsis>
            This is the conversion specifier character specified.  It's stored in
             the structure so that you can register the same handler function for
             multiple characters, but still have a way to tell them apart when the
             handler function is called.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="unsigned int is_long_double">
            <synopsis>
            This is a boolean that is true if the &lt;samp&gt;L&lt;/samp&gt;, &lt;samp&gt;ll&lt;/samp&gt;, or &lt;samp&gt;q&lt;/samp&gt;
             type modifier was specified.  For integer conversions, this indicates
             &lt;CODE&gt;long long int&lt;/CODE&gt;, as opposed to &lt;CODE&gt;long double&lt;/CODE&gt; for floating
             point conversions.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="unsigned int is_char">
            <synopsis>
            This is a boolean that is true if the &lt;samp&gt;hh&lt;/samp&gt; type modifier was specified.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="unsigned int is_short">
            <synopsis>
            This is a boolean that is true if the &lt;samp&gt;h&lt;/samp&gt; type modifier was specified.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="unsigned int is_long">
            <synopsis>
            This is a boolean that is true if the &lt;samp&gt;l&lt;/samp&gt; type modifier was specified.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="unsigned int alt">
            <synopsis>
            This is a boolean that is true if the &lt;samp&gt;#&lt;/samp&gt; flag was specified.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="unsigned int space">
            <synopsis>
            This is a boolean that is true if the &lt;samp&gt; &lt;/samp&gt; flag was specified.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="unsigned int left">
            <synopsis>
            This is a boolean that is true if the &lt;samp&gt;-&lt;/samp&gt; flag was specified.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="unsigned int showsign">
            <synopsis>
            This is a boolean that is true if the &lt;samp&gt;+&lt;/samp&gt; flag was specified.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="unsigned int group">
            <synopsis>
            This is a boolean that is true if the &lt;samp&gt;'&lt;/samp&gt; flag was specified.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="unsigned int extra">
            <synopsis>
            This flag has a special meaning depending on the context.  It could
             be used freely by the user-defined handlers but when called from
             the &lt;CODE&gt;printf&lt;/CODE&gt; function this variable always contains the value
             &lt;CODE&gt;0&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="unsigned int wide">
            <synopsis>
            This flag is set if the stream is wide oriented.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="dtype-printf_function" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="dtype-printf_arginfo_function" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="function-printf_size" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *fp"/>
        <parameter content="const struct printf_info *info"/>
        <parameter content="const void *const *args"/>
      </prototype>
      <headers>
        <header filename = "printf.h"/>
      </headers>
        <synopsis>
        Print a given floating point number as for the format &lt;CODE&gt;%f&lt;/CODE&gt; except
         that there is a postfix character indicating the divisor for the
         number to make this less than 1000.  There are two possible divisors:
         powers of 1024 or powers of 1000.  Which one is used depends on the
         format character specified while registered this handler.  If the
         character is of lower case, 1024 is used.  For upper case characters,
         1000 is used.
         &lt;br&gt;&lt;br&gt; The postfix tag corresponds to bytes, kilobytes, megabytes, gigabytes,
         etc.  The full table is:
         &lt;br&gt;&lt;br&gt;
         &lt;DL&gt;
&lt;DT&gt;&lt;pre&gt;low  Multiplier   From   Upper  Multiplier&lt;/pre&gt;
&lt;DD&gt;&lt;br&gt; &lt;DT&gt;&lt;pre&gt;' '  1                   ' '    1&lt;/pre&gt;
&lt;DD&gt;&lt;br&gt; &lt;DT&gt;&lt;pre&gt;k    2^10 (1024)  kilo   K      10^3 (1000)&lt;/pre&gt;
&lt;DD&gt;&lt;br&gt; &lt;DT&gt;&lt;pre&gt;m    2^20         mega   M      10^6&lt;/pre&gt;
&lt;DD&gt;&lt;br&gt; &lt;DT&gt;&lt;pre&gt;g    2^30         giga   G      10^9&lt;/pre&gt;
&lt;DD&gt;&lt;br&gt; &lt;DT&gt;&lt;pre&gt;t    2^40         tera   T      10^12&lt;/pre&gt;
&lt;DD&gt;&lt;br&gt; &lt;DT&gt;&lt;pre&gt;p    2^50         peta   P      10^15&lt;/pre&gt;
&lt;DD&gt;&lt;br&gt; &lt;DT&gt;&lt;pre&gt;e    2^60         exa    E      10^18&lt;/pre&gt;
&lt;DD&gt;&lt;br&gt; &lt;DT&gt;&lt;pre&gt;z    2^70         zetta  Z      10^21&lt;/pre&gt;
&lt;DD&gt;&lt;br&gt; &lt;DT&gt;&lt;pre&gt;y    2^80         yotta  Y      10^24&lt;/pre&gt;
&lt;DD&gt;&lt;br&gt; &lt;/DL&gt;


         &lt;br&gt;&lt;br&gt; The default precision is 3, i.e., 1024 is printed with a lower-case
         format character as if it were &lt;CODE&gt;%.3fk&lt;/CODE&gt; and will yield &lt;CODE&gt;1.000k&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-printf_size_info" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const struct printf_info *info"/>
        <parameter content="size_t n"/>
        <parameter content="int *argtypes"/>
      </prototype>
      <headers>
        <header filename = "printf.h"/>
      </headers>
        <synopsis>
        This function will return in &lt;VAR&gt;argtypes&lt;/VAR&gt; the information about the
         used parameters in the way the &lt;CODE&gt;vfprintf&lt;/CODE&gt; implementation expects
         it.  The format always takes one argument.
        </synopsis>
    </function>
  </construct>
  <construct id="function-scanf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *template"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;scanf&lt;/CODE&gt; function reads formatted input from the stream
         &lt;CODE&gt;stdin&lt;/CODE&gt; under the control of the template string &lt;VAR&gt;template&lt;/VAR&gt;.
         The optional arguments are pointers to the places which receive the
         resulting values.
         &lt;br&gt;&lt;br&gt; The return value is normally the number of successful assignments.  If
         an end-of-file condition is detected before any matches are performed,
         including matches against whitespace and literal characters in the
         template, then &lt;CODE&gt;EOF&lt;/CODE&gt; is returned.
        </synopsis>
    </function>
  </construct>
  <construct id="function-wscanf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const wchar_t *template"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;wscanf&lt;/CODE&gt; function reads formatted input from the stream
         &lt;CODE&gt;stdin&lt;/CODE&gt; under the control of the template string &lt;VAR&gt;template&lt;/VAR&gt;.
         The optional arguments are pointers to the places which receive the
         resulting values.
         &lt;br&gt;&lt;br&gt; The return value is normally the number of successful assignments.  If
         an end-of-file condition is detected before any matches are performed,
         including matches against whitespace and literal characters in the
         template, then &lt;CODE&gt;WEOF&lt;/CODE&gt; is returned.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fscanf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
        <parameter content="const char *template"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function is just like &lt;CODE&gt;scanf&lt;/CODE&gt;, except that the input is read
         from the stream &lt;VAR&gt;stream&lt;/VAR&gt; instead of &lt;CODE&gt;stdin&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fwscanf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
        <parameter content="const wchar_t *template"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        This function is just like &lt;CODE&gt;wscanf&lt;/CODE&gt;, except that the input is read
         from the stream &lt;VAR&gt;stream&lt;/VAR&gt; instead of &lt;CODE&gt;stdin&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-sscanf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *s"/>
        <parameter content="const char *template"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This is like &lt;CODE&gt;scanf&lt;/CODE&gt;, except that the characters are taken from the
         null-terminated string &lt;VAR&gt;s&lt;/VAR&gt; instead of from a stream.  Reaching the
         end of the string is treated as an end-of-file condition.
         &lt;br&gt;&lt;br&gt; The behavior of this function is undefined if copying takes place
         between objects that overlap---for example, if &lt;VAR&gt;s&lt;/VAR&gt; is also given
         as an argument to receive a string read under control of the &lt;samp&gt;%s&lt;/samp&gt;,
         &lt;samp&gt;%S&lt;/samp&gt;, or &lt;samp&gt;%[&lt;/samp&gt; conversion.
        </synopsis>
    </function>
  </construct>
  <construct id="function-swscanf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const wchar_t *ws"/>
        <parameter content="const char *template"/>
        <parameter content="..."/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        This is like &lt;CODE&gt;wscanf&lt;/CODE&gt;, except that the characters are taken from the
         null-terminated string &lt;VAR&gt;ws&lt;/VAR&gt; instead of from a stream.  Reaching the
         end of the string is treated as an end-of-file condition.
         &lt;br&gt;&lt;br&gt; The behavior of this function is undefined if copying takes place
         between objects that overlap---for example, if &lt;VAR&gt;ws&lt;/VAR&gt; is also given as
         an argument to receive a string read under control of the &lt;samp&gt;%s&lt;/samp&gt;,
         &lt;samp&gt;%S&lt;/samp&gt;, or &lt;samp&gt;%[&lt;/samp&gt; conversion.
        </synopsis>
    </function>
  </construct>
  <construct id="function-vscanf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *template"/>
        <parameter content="va_list ap"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;scanf&lt;/CODE&gt;, but instead of taking
         a variable number of arguments directly, it takes an argument list
         pointer &lt;VAR&gt;ap&lt;/VAR&gt; of type &lt;CODE&gt;va_list&lt;/CODE&gt; .
        </synopsis>
    </function>
  </construct>
  <construct id="function-vwscanf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const wchar_t *template"/>
        <parameter content="va_list ap"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;wscanf&lt;/CODE&gt;, but instead of taking
         a variable number of arguments directly, it takes an argument list
         pointer &lt;VAR&gt;ap&lt;/VAR&gt; of type &lt;CODE&gt;va_list&lt;/CODE&gt; .
        </synopsis>
    </function>
  </construct>
  <construct id="function-vfscanf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
        <parameter content="const char *template"/>
        <parameter content="va_list ap"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This is the equivalent of &lt;CODE&gt;fscanf&lt;/CODE&gt; with the variable argument list
         specified directly as for &lt;CODE&gt;vscanf&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-vfwscanf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
        <parameter content="const wchar_t *template"/>
        <parameter content="va_list ap"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        This is the equivalent of &lt;CODE&gt;fwscanf&lt;/CODE&gt; with the variable argument list
         specified directly as for &lt;CODE&gt;vwscanf&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-vsscanf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const char *s"/>
        <parameter content="const char *template"/>
        <parameter content="va_list ap"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This is the equivalent of &lt;CODE&gt;sscanf&lt;/CODE&gt; with the variable argument list
         specified directly as for &lt;CODE&gt;vscanf&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-vswscanf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="const wchar_t *s"/>
        <parameter content="const wchar_t *template"/>
        <parameter content="va_list ap"/>
      </prototype>
      <headers>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        This is the equivalent of &lt;CODE&gt;swscanf&lt;/CODE&gt; with the variable argument list
         specified directly as for &lt;CODE&gt;vwscanf&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-feof" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
        <header filename = "wchar.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;feof&lt;/CODE&gt; function returns nonzero if and only if the end-of-file
         indicator for the stream &lt;VAR&gt;stream&lt;/VAR&gt; is set.
         &lt;br&gt;&lt;br&gt; This symbol is declared in &lt;TT&gt;stdio.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-feof_unlocked" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;feof_unlocked&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;feof&lt;/CODE&gt;
         function except that it does not implicitly lock the stream.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
         &lt;br&gt;&lt;br&gt; This symbol is declared in &lt;TT&gt;stdio.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ferror" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;ferror&lt;/CODE&gt; function returns nonzero if and only if the error
         indicator for the stream &lt;VAR&gt;stream&lt;/VAR&gt; is set, indicating that an error
         has occurred on a previous operation on the stream.
         &lt;br&gt;&lt;br&gt; This symbol is declared in &lt;TT&gt;stdio.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ferror_unlocked" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;ferror_unlocked&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;ferror&lt;/CODE&gt;
         function except that it does not implicitly lock the stream.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
         &lt;br&gt;&lt;br&gt; This symbol is declared in &lt;TT&gt;stdio.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-clearerr" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function clears the end-of-file and error indicators for the
         stream &lt;VAR&gt;stream&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The file positioning functions  also clear the
         end-of-file indicator for the stream.
        </synopsis>
    </function>
  </construct>
  <construct id="function-clearerr_unlocked" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;clearerr_unlocked&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;clearerr&lt;/CODE&gt;
         function except that it does not implicitly lock the stream.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ftell" type="function">
    <function returntype="long int">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function returns the current file position of the stream
         &lt;VAR&gt;stream&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; This function can fail if the stream doesn't support file positioning,
         or if the file position can't be represented in a &lt;CODE&gt;long int&lt;/CODE&gt;, and
         possibly for other reasons as well.  If a failure occurs, a value of
         &lt;CODE&gt;-1&lt;/CODE&gt; is returned.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ftello" type="function">
    <function returntype="off_t">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;ftello&lt;/CODE&gt; function is similar to &lt;CODE&gt;ftell&lt;/CODE&gt;, except that it
         returns a value of type &lt;CODE&gt;off_t&lt;/CODE&gt;.  Systems which support this type
         use it to describe all file positions, unlike the POSIX specification
         which uses a long int.  The two are not necessarily the same size.
         Therefore, using ftell can lead to problems if the implementation is
         written on top of a POSIX compliant low-level I/O implementation, and using
         &lt;CODE&gt;ftello&lt;/CODE&gt; is preferable whenever it is available.
         &lt;br&gt;&lt;br&gt; If this function fails it returns &lt;CODE&gt;(off_t) -1&lt;/CODE&gt;.  This can happen due
         to missing support for file positioning or internal errors.  Otherwise
         the return value is the current file position.
         &lt;br&gt;&lt;br&gt; The function is an extension defined in the Unix Single Specification
         version 2.
         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; on a
         32 bit system this function is in fact &lt;CODE&gt;ftello64&lt;/CODE&gt;.  I.e., the
         LFS interface transparently replaces the old interface.
        </synopsis>
    </function>
  </construct>
  <construct id="function-ftello64" type="function">
    <function returntype="off64_t">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;ftello&lt;/CODE&gt; with the only difference that
         the return value is of type &lt;CODE&gt;off64_t&lt;/CODE&gt;.  This also requires that the
         stream &lt;VAR&gt;stream&lt;/VAR&gt; was opened using either &lt;CODE&gt;fopen64&lt;/CODE&gt;,
         &lt;CODE&gt;freopen64&lt;/CODE&gt;, or &lt;CODE&gt;tmpfile64&lt;/CODE&gt; since otherwise the underlying
         file operations to position the file pointer beyond the 2^31
         bytes limit might fail.
         &lt;br&gt;&lt;br&gt; If the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; on a 32
         bits machine this function is available under the name &lt;CODE&gt;ftello&lt;/CODE&gt;
         and so transparently replaces the old interface.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fseek" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
        <parameter content="long int offset"/>
        <parameter content="int whence"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fseek&lt;/CODE&gt; function is used to change the file position of the
         stream &lt;VAR&gt;stream&lt;/VAR&gt;.  The value of &lt;VAR&gt;whence&lt;/VAR&gt; must be one of the
         constants &lt;CODE&gt;SEEK_SET&lt;/CODE&gt;, &lt;CODE&gt;SEEK_CUR&lt;/CODE&gt;, or &lt;CODE&gt;SEEK_END&lt;/CODE&gt;, to
         indicate whether the &lt;VAR&gt;offset&lt;/VAR&gt; is relative to the beginning of the
         file, the current file position, or the end of the file, respectively.
         &lt;br&gt;&lt;br&gt; This function returns a value of zero if the operation was successful,
         and a nonzero value to indicate failure.  A successful call also clears
         the end-of-file indicator of &lt;VAR&gt;stream&lt;/VAR&gt; and discards any characters
         that were ``pushed back'' by the use of &lt;CODE&gt;ungetc&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; &lt;CODE&gt;fseek&lt;/CODE&gt; either flushes any buffered output before setting the file
         position or else remembers it so it will be written later in its proper
         place in the file.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fseeko" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
        <parameter content="off_t offset"/>
        <parameter content="int whence"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;fseek&lt;/CODE&gt; but it corrects a problem with
         &lt;CODE&gt;fseek&lt;/CODE&gt; in a system with POSIX types.  Using a value of type
         &lt;CODE&gt;long int&lt;/CODE&gt; for the offset is not compatible with POSIX.
         &lt;CODE&gt;fseeko&lt;/CODE&gt; uses the correct type &lt;CODE&gt;off_t&lt;/CODE&gt; for the &lt;VAR&gt;offset&lt;/VAR&gt;
         parameter.
         &lt;br&gt;&lt;br&gt; For this reason it is a good idea to prefer &lt;CODE&gt;ftello&lt;/CODE&gt; whenever it is
         available since its functionality is (if different at all) closer the
         underlying definition.
         &lt;br&gt;&lt;br&gt; The functionality and return value is the same as for &lt;CODE&gt;fseek&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The function is an extension defined in the Unix Single Specification
         version 2.
         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; on a
         32 bit system this function is in fact &lt;CODE&gt;fseeko64&lt;/CODE&gt;.  I.e., the
         LFS interface transparently replaces the old interface.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fseeko64" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
        <parameter content="off64_t offset"/>
        <parameter content="int whence"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;fseeko&lt;/CODE&gt; with the only difference that
         the &lt;VAR&gt;offset&lt;/VAR&gt; parameter is of type &lt;CODE&gt;off64_t&lt;/CODE&gt;.  This also
         requires that the stream &lt;VAR&gt;stream&lt;/VAR&gt; was opened using either
         &lt;CODE&gt;fopen64&lt;/CODE&gt;, &lt;CODE&gt;freopen64&lt;/CODE&gt;, or &lt;CODE&gt;tmpfile64&lt;/CODE&gt; since otherwise
         the underlying file operations to position the file pointer beyond the
         2^31 bytes limit might fail.
         &lt;br&gt;&lt;br&gt; If the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; on a 32
         bits machine this function is available under the name &lt;CODE&gt;fseeko&lt;/CODE&gt;
         and so transparently replaces the old interface.
        </synopsis>
    </function>
  </construct>
  <construct id="function-rewind" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;rewind&lt;/CODE&gt; function positions the stream &lt;VAR&gt;stream&lt;/VAR&gt; at the
         beginning of the file.  It is equivalent to calling &lt;CODE&gt;fseek&lt;/CODE&gt; or
         &lt;CODE&gt;fseeko&lt;/CODE&gt; on the &lt;VAR&gt;stream&lt;/VAR&gt; with an &lt;VAR&gt;offset&lt;/VAR&gt; argument of
         &lt;CODE&gt;0L&lt;/CODE&gt; and a &lt;VAR&gt;whence&lt;/VAR&gt; argument of &lt;CODE&gt;SEEK_SET&lt;/CODE&gt;, except that
         the return value is discarded and the error indicator for the stream is
         reset.
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-fpos_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="dtype-fpos64_t" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="function-fgetpos" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
        <parameter content="fpos_t *position"/>
      </prototype>
      <headers>
        <header filename = "sys/file.h"/>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function stores the value of the file position indicator for the
         stream &lt;VAR&gt;stream&lt;/VAR&gt; in the &lt;CODE&gt;fpos_t&lt;/CODE&gt; object pointed to by
         &lt;VAR&gt;position&lt;/VAR&gt;.  If successful, &lt;CODE&gt;fgetpos&lt;/CODE&gt; returns zero; otherwise
         it returns a nonzero value and stores an implementation-defined positive
         value in &lt;CODE&gt;errno&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; on a
         32 bit system the function is in fact &lt;CODE&gt;fgetpos64&lt;/CODE&gt;.  I.e., the LFS
         interface transparently replaces the old interface.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fgetpos64" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
        <parameter content="fpos64_t *position"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;fgetpos&lt;/CODE&gt; but the file position is
         returned in a variable of type &lt;CODE&gt;fpos64_t&lt;/CODE&gt; to which &lt;VAR&gt;position&lt;/VAR&gt;
         points.
         &lt;br&gt;&lt;br&gt; If the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; on a 32
         bits machine this function is available under the name &lt;CODE&gt;fgetpos&lt;/CODE&gt;
         and so transparently replaces the old interface.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fsetpos" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
        <parameter content="const fpos_t *position"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function sets the file position indicator for the stream &lt;VAR&gt;stream&lt;/VAR&gt;
         to the position &lt;VAR&gt;position&lt;/VAR&gt;, which must have been set by a previous
         call to &lt;CODE&gt;fgetpos&lt;/CODE&gt; on the same stream.  If successful, &lt;CODE&gt;fsetpos&lt;/CODE&gt;
         clears the end-of-file indicator on the stream, discards any characters
         that were ``pushed back'' by the use of &lt;CODE&gt;ungetc&lt;/CODE&gt;, and returns a value
         of zero.  Otherwise, &lt;CODE&gt;fsetpos&lt;/CODE&gt; returns a nonzero value and stores
         an implementation-defined positive value in &lt;CODE&gt;errno&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; When the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; on a
         32 bit system the function is in fact &lt;CODE&gt;fsetpos64&lt;/CODE&gt;.  I.e., the LFS
         interface transparently replaces the old interface.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fsetpos64" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
        <parameter content="const fpos64_t *position"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function is similar to &lt;CODE&gt;fsetpos&lt;/CODE&gt; but the file position used
         for positioning is provided in a variable of type &lt;CODE&gt;fpos64_t&lt;/CODE&gt; to
         which &lt;VAR&gt;position&lt;/VAR&gt; points.
         &lt;br&gt;&lt;br&gt; If the sources are compiled with &lt;CODE&gt;_FILE_OFFSET_BITS == 64&lt;/CODE&gt; on a 32
         bits machine this function is available under the name &lt;CODE&gt;fsetpos&lt;/CODE&gt;
         and so transparently replaces the old interface.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fflush" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function causes any buffered output on &lt;VAR&gt;stream&lt;/VAR&gt; to be delivered
         to the file.  If &lt;VAR&gt;stream&lt;/VAR&gt; is a null pointer, then
         &lt;CODE&gt;fflush&lt;/CODE&gt; causes buffered output on &lt;EM&gt;all&lt;/EM&gt; open output streams
         to be flushed.
         &lt;br&gt;&lt;br&gt; This function returns &lt;CODE&gt;EOF&lt;/CODE&gt; if a write error occurs, or zero
         otherwise.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fflush_unlocked" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;fflush_unlocked&lt;/CODE&gt; function is equivalent to the &lt;CODE&gt;fflush&lt;/CODE&gt;
         function except that it does not implicitly lock the stream.
        </synopsis>
    </function>
  </construct>
  <construct id="function-_flushlbf" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "stdio_ext.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;_flushlbf&lt;/CODE&gt; function flushes all line buffered streams
         currently opened.
         &lt;br&gt;&lt;br&gt; This function is declared in the &lt;TT&gt;stdio_ext.h&lt;/TT&gt; header.
        </synopsis>
    </function>
  </construct>
  <construct id="function-__fpurge" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio_ext.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;__fpurge&lt;/CODE&gt; function causes the buffer of the stream
         &lt;VAR&gt;stream&lt;/VAR&gt; to be emptied.  If the stream is currently in read mode all
         input in the buffer is lost.  If the stream is in output mode the
         buffered output is not written to the device (or whatever other
         underlying storage) and the buffer the cleared.
         &lt;br&gt;&lt;br&gt; This function is declared in &lt;TT&gt;stdio_ext.h&lt;/TT&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-setvbuf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
        <parameter content="char *buf"/>
        <parameter content="int mode"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function is used to specify that the stream &lt;VAR&gt;stream&lt;/VAR&gt; should
         have the buffering mode &lt;VAR&gt;mode&lt;/VAR&gt;, which can be either &lt;CODE&gt;_IOFBF&lt;/CODE&gt;
         (for full buffering), &lt;CODE&gt;_IOLBF&lt;/CODE&gt; (for line buffering), or
         &lt;CODE&gt;_IONBF&lt;/CODE&gt; (for unbuffered input/output).
         &lt;br&gt;&lt;br&gt; If you specify a null pointer as the &lt;VAR&gt;buf&lt;/VAR&gt; argument, then &lt;CODE&gt;setvbuf&lt;/CODE&gt;
         allocates a buffer itself using &lt;CODE&gt;malloc&lt;/CODE&gt;.  This buffer will be freed
         when you close the stream.
         &lt;br&gt;&lt;br&gt; Otherwise, &lt;VAR&gt;buf&lt;/VAR&gt; should be a character array that can hold at least
         &lt;VAR&gt;size&lt;/VAR&gt; characters.  You should not free the space for this array as
         long as the stream remains open and this array remains its buffer.  You
         should usually either allocate it statically, or &lt;CODE&gt;malloc&lt;/CODE&gt;
          the buffer.  Using an automatic array
         is not a good idea unless you close the file before exiting the block
         that declares the array.
         &lt;br&gt;&lt;br&gt; While the array remains a stream buffer, the stream I/O functions will
         use the buffer for their internal purposes.  You shouldn't try to access
         the values in the array directly while the stream is using it for
         buffering.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;setvbuf&lt;/CODE&gt; function returns zero on success, or a nonzero value
         if the value of &lt;VAR&gt;mode&lt;/VAR&gt; is not valid or if the request could not
         be honored.
        </synopsis>
    </function>
  </construct>
  <construct id="function-setbuf" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="FILE *stream"/>
        <parameter content="char *buf"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        If &lt;VAR&gt;buf&lt;/VAR&gt; is a null pointer, the effect of this function is
         equivalent to calling &lt;CODE&gt;setvbuf&lt;/CODE&gt; with a &lt;VAR&gt;mode&lt;/VAR&gt; argument of
         &lt;CODE&gt;_IONBF&lt;/CODE&gt;.  Otherwise, it is equivalent to calling &lt;CODE&gt;setvbuf&lt;/CODE&gt;
         with &lt;VAR&gt;buf&lt;/VAR&gt;, and a &lt;VAR&gt;mode&lt;/VAR&gt; of &lt;CODE&gt;_IOFBF&lt;/CODE&gt; and a &lt;VAR&gt;size&lt;/VAR&gt;
         argument of &lt;CODE&gt;BUFSIZ&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;setbuf&lt;/CODE&gt; function is provided for compatibility with old code;
         use &lt;CODE&gt;setvbuf&lt;/CODE&gt; in all new programs.
        </synopsis>
    </function>
  </construct>
  <construct id="function-setbuffer" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="FILE *stream"/>
        <parameter content="char *buf"/>
        <parameter content="size_t size"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        If &lt;VAR&gt;buf&lt;/VAR&gt; is a null pointer, this function makes &lt;VAR&gt;stream&lt;/VAR&gt; unbuffered.
         Otherwise, it makes &lt;VAR&gt;stream&lt;/VAR&gt; fully buffered using &lt;VAR&gt;buf&lt;/VAR&gt; as the
         buffer.  The &lt;VAR&gt;size&lt;/VAR&gt; argument specifies the length of &lt;VAR&gt;buf&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; This function is provided for compatibility with old BSD code.  Use
         &lt;CODE&gt;setvbuf&lt;/CODE&gt; instead.
        </synopsis>
    </function>
  </construct>
  <construct id="function-setlinebuf" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function makes &lt;VAR&gt;stream&lt;/VAR&gt; be line buffered, and allocates the
         buffer for you.
         &lt;br&gt;&lt;br&gt; This function is provided for compatibility with old BSD code.  Use
         &lt;CODE&gt;setvbuf&lt;/CODE&gt; instead.
        </synopsis>
    </function>
  </construct>
  <construct id="function-__flbf" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio_ext.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;__flbf&lt;/CODE&gt; function will return a nonzero value in case the
         stream &lt;VAR&gt;stream&lt;/VAR&gt; is line buffered.  Otherwise the return value is
         zero.
         &lt;br&gt;&lt;br&gt; This function is declared in the &lt;TT&gt;stdio_ext.h&lt;/TT&gt; header.
        </synopsis>
    </function>
  </construct>
  <construct id="function-__fbufsize" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio_ext.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;__fbufsize&lt;/CODE&gt; function return the size of the buffer in the
         stream &lt;VAR&gt;stream&lt;/VAR&gt;.  This value can be used to optimize the use of the
         stream.
         &lt;br&gt;&lt;br&gt; This function is declared in the &lt;TT&gt;stdio_ext.h&lt;/TT&gt; header.
        </synopsis>
    </function>
  </construct>
  <construct id="function-__fpending" type="function">
    <function returntype="size_t">
      <prototype>
        <parameter content="FILE *stream"/>
      </prototype>
      <headers>
        <header filename = "stdio_ext.h"/>
      </headers>
        <synopsis>
        function returns the number of bytes currently in the output buffer.
         For wide-oriented stream the measuring unit is wide characters.  This
         function should not be used on buffers in read mode or opened read-only.
         &lt;br&gt;&lt;br&gt; This function is declared in the &lt;TT&gt;stdio_ext.h&lt;/TT&gt; header.
        </synopsis>
    </function>
  </construct>
  <construct id="function-fmemopen" type="function">
    <function returntype="FILE *">
      <prototype>
        <parameter content="void *buf"/>
        <parameter content="size_t size"/>
        <parameter content="const char *opentype"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function opens a stream that allows the access specified by the
         &lt;VAR&gt;opentype&lt;/VAR&gt; argument, that reads from or writes to the buffer specified
         by the argument &lt;VAR&gt;buf&lt;/VAR&gt;.  This array must be at least &lt;VAR&gt;size&lt;/VAR&gt; bytes long.
         &lt;br&gt;&lt;br&gt; If you specify a null pointer as the &lt;VAR&gt;buf&lt;/VAR&gt; argument, &lt;CODE&gt;fmemopen&lt;/CODE&gt;
         dynamically allocates an array &lt;VAR&gt;size&lt;/VAR&gt; bytes long (as with &lt;CODE&gt;malloc&lt;/CODE&gt;;
         ).  This is really only useful
         if you are going to write things to the buffer and then read them back
         in again, because you have no way of actually getting a pointer to the
         buffer (for this, try &lt;CODE&gt;open_memstream&lt;/CODE&gt;, below).  The buffer is
         freed when the stream is closed.
         &lt;br&gt;&lt;br&gt; The argument &lt;VAR&gt;opentype&lt;/VAR&gt; is the same as in &lt;CODE&gt;fopen&lt;/CODE&gt;
         .  If the &lt;VAR&gt;opentype&lt;/VAR&gt; specifies
         append mode, then the initial file position is set to the first null
         character in the buffer.  Otherwise the initial file position is at the
         beginning of the buffer.
         &lt;br&gt;&lt;br&gt; When a stream open for writing is flushed or closed, a null character
         (zero byte) is written at the end of the buffer if it fits.  You
         should add an extra byte to the &lt;VAR&gt;size&lt;/VAR&gt; argument to account for this.
         Attempts to write more than &lt;VAR&gt;size&lt;/VAR&gt; bytes to the buffer result
         in an error.
         &lt;br&gt;&lt;br&gt; For a stream open for reading, null characters (zero bytes) in the
         buffer do not count as ``end of file''.  Read operations indicate end of
         file only when the file position advances past &lt;VAR&gt;size&lt;/VAR&gt; bytes.  So, if
         you want to read characters from a null-terminated string, you should
         supply the length of the string as the &lt;VAR&gt;size&lt;/VAR&gt; argument.
        </synopsis>
    </function>
  </construct>
  <construct id="function-open_memstream" type="function">
    <function returntype="FILE *">
      <prototype>
        <parameter content="char **ptr"/>
        <parameter content="size_t *sizeloc"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function opens a stream for writing to a buffer.  The buffer is
         allocated dynamically and grown as necessary, using &lt;CODE&gt;malloc&lt;/CODE&gt;.
         After you've closed the stream, this buffer is your responsibility to
         clean up using &lt;CODE&gt;free&lt;/CODE&gt; or &lt;CODE&gt;realloc&lt;/CODE&gt;.  .
         &lt;br&gt;&lt;br&gt; When the stream is closed with &lt;CODE&gt;fclose&lt;/CODE&gt; or flushed with
         &lt;CODE&gt;fflush&lt;/CODE&gt;, the locations &lt;VAR&gt;ptr&lt;/VAR&gt; and &lt;VAR&gt;sizeloc&lt;/VAR&gt; are updated to
         contain the pointer to the buffer and its size.  The values thus stored
         remain valid only as long as no further output on the stream takes
         place.  If you do more output, you must flush the stream again to store
         new values before you use them again.
         &lt;br&gt;&lt;br&gt; A null character is written at the end of the buffer.  This null character
         is &lt;EM&gt;not&lt;/EM&gt; included in the size value stored at &lt;VAR&gt;sizeloc&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; You can move the stream's file position with &lt;CODE&gt;fseek&lt;/CODE&gt; or
         &lt;CODE&gt;fseeko&lt;/CODE&gt; .  Moving the file position past
         the end of the data already written fills the intervening space with
         zeroes.
        </synopsis>
    </function>
  </construct>
  <construct id="function-open_obstack_stream" type="function">
    <function returntype="FILE *">
      <prototype>
        <parameter content="struct obstack *obstack"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function opens a stream for writing data into the obstack &lt;VAR&gt;obstack&lt;/VAR&gt;.
         This starts an object in the obstack and makes it grow as data is
         written .
         &lt;br&gt;&lt;br&gt; Calling &lt;CODE&gt;fflush&lt;/CODE&gt; on this stream updates the current size of the
         object to match the amount of data that has been written.  After a call
         to &lt;CODE&gt;fflush&lt;/CODE&gt;, you can examine the object temporarily.
         &lt;br&gt;&lt;br&gt; You can move the file position of an obstack stream with &lt;CODE&gt;fseek&lt;/CODE&gt; or
         &lt;CODE&gt;fseeko&lt;/CODE&gt; .  Moving the file position past
         the end of the data written fills the intervening space with zeros.
         &lt;br&gt;&lt;br&gt; To make the object permanent, update the obstack with &lt;CODE&gt;fflush&lt;/CODE&gt;, and
         then use &lt;CODE&gt;obstack_finish&lt;/CODE&gt; to finalize the object and get its address.
         The following write to the stream starts a new object in the obstack,
         and later writes add to that object until you do another &lt;CODE&gt;fflush&lt;/CODE&gt;
         and &lt;CODE&gt;obstack_finish&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; But how do you find out how long the object is?  You can get the length
         in bytes by calling &lt;CODE&gt;obstack_object_size&lt;/CODE&gt; , or you can null-terminate the object like this:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         obstack_1grow (&lt;VAR&gt;obstack&lt;/VAR&gt;, 0);&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; Whichever one you do, you must do it &lt;EM&gt;before&lt;/EM&gt; calling
         &lt;CODE&gt;obstack_finish&lt;/CODE&gt;.  (You can do both if you wish.)
        </synopsis>
    </function>
  </construct>
  <construct id="type-cookie_io_functions_t" type="type">
    <structure>
        <synopsis>
        This is a structure type that holds the functions that define the
         communications protocol between the stream and its cookie.  It has
         the following members:
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="cookie_read_function_t *read">
            <synopsis>
            This is the function that reads data from the cookie.  If the value is a
             null pointer instead of a function, then read operations on this stream
             always return &lt;CODE&gt;EOF&lt;/CODE&gt;.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="cookie_write_function_t *write">
            <synopsis>
            This is the function that writes data to the cookie.  If the value is a
             null pointer instead of a function, then data written to the stream is
             discarded.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
        <element content="cookie_seek_function_t *seek">
            <synopsis>
            This is the function that performs the equivalent of file positioning on
             the cookie.  If the value is a null pointer instead of a function, calls
             to &lt;CODE&gt;fseek&lt;/CODE&gt; or &lt;CODE&gt;fseeko&lt;/CODE&gt; on this stream can only seek to
             locations within the buffer; any attempt to seek outside the buffer will
             return an &lt;CODE&gt;ESPIPE&lt;/CODE&gt; error.
             &lt;br&gt;&lt;br&gt;
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-fopencookie" type="function">
    <function returntype="FILE *">
      <prototype>
        <parameter content="void *cookie"/>
        <parameter content="const char *opentype"/>
        <parameter content="cookie_io_functions_t io-functions"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
      </headers>
        <synopsis>
        This function actually creates the stream for communicating with the
         &lt;VAR&gt;cookie&lt;/VAR&gt; using the functions in the &lt;VAR&gt;io-functions&lt;/VAR&gt; argument.
         The &lt;VAR&gt;opentype&lt;/VAR&gt; argument is interpreted as for &lt;CODE&gt;fopen&lt;/CODE&gt;;
         see Opening Streams.  (But note that the ``truncate on
         open'' option is ignored.)  The new stream is fully buffered.
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;fopencookie&lt;/CODE&gt; function returns the newly created stream, or a null
         pointer in case of an error.
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-cookie_read_function" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="dtype-cookie_write_function" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="dtype-cookie_seek_function" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="dtype-cookie_close_function" type="dtype">
    <structure>
    </structure>
  </construct>
  <construct id="function-fmtmsg" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="long int classification"/>
        <parameter content="const char *label"/>
        <parameter content="int severity"/>
        <parameter content="const char *text"/>
        <parameter content="const char *action"/>
        <parameter content="const char *tag"/>
      </prototype>
      <headers>
        <header filename = "stdio.h"/>
        <header filename = "fmtmsg.h"/>
      </headers>
        <synopsis>
        Display a message described by its parameters on the device(s) specified
         in the &lt;VAR&gt;classification&lt;/VAR&gt; parameter.  The &lt;VAR&gt;label&lt;/VAR&gt; parameter
         identifies the source of the message.  The string should consist of two
         colon separated parts where the first part has not more than 10 and the
         second part not more than 14 characters.  The &lt;VAR&gt;text&lt;/VAR&gt; parameter
         describes the condition of the error, the &lt;VAR&gt;action&lt;/VAR&gt; parameter possible
         steps to recover from the error and the &lt;VAR&gt;tag&lt;/VAR&gt; parameter is a
         reference to the online documentation where more information can be
         found.  It should contain the &lt;VAR&gt;label&lt;/VAR&gt; value and a unique
         identification number.
         &lt;br&gt;&lt;br&gt; Each of the parameters can be a special value which means this value
         is to be omitted.  The symbolic names for these values are:
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;MM_NULLLBL&lt;/CODE&gt;
&lt;DD&gt;
         Ignore &lt;VAR&gt;label&lt;/VAR&gt; parameter.
         &lt;DT&gt;&lt;CODE&gt;MM_NULLSEV&lt;/CODE&gt;
&lt;DD&gt;
         Ignore &lt;VAR&gt;severity&lt;/VAR&gt; parameter.
         &lt;DT&gt;&lt;CODE&gt;MM_NULLMC&lt;/CODE&gt;
&lt;DD&gt;
         Ignore &lt;VAR&gt;classification&lt;/VAR&gt; parameter.  This implies that nothing is
         actually printed.
         &lt;DT&gt;&lt;CODE&gt;MM_NULLTXT&lt;/CODE&gt;
&lt;DD&gt;
         Ignore &lt;VAR&gt;text&lt;/VAR&gt; parameter.
         &lt;DT&gt;&lt;CODE&gt;MM_NULLACT&lt;/CODE&gt;
&lt;DD&gt;
         Ignore &lt;VAR&gt;action&lt;/VAR&gt; parameter.
         &lt;DT&gt;&lt;CODE&gt;MM_NULLTAG&lt;/CODE&gt;
&lt;DD&gt;
         Ignore &lt;VAR&gt;tag&lt;/VAR&gt; parameter.
         &lt;/DL&gt;
         &lt;br&gt;&lt;br&gt; There is another way certain fields can be omitted from the output to
         standard error.  This is described below in the description of
         environment variables influencing the behavior.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;severity&lt;/VAR&gt; parameter can have one of the values in the following
         table:
          class
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;MM_NOSEV&lt;/CODE&gt;
&lt;DD&gt;
         Nothing is printed, this value is the same as &lt;CODE&gt;MM_NULLSEV&lt;/CODE&gt;.
         &lt;DT&gt;&lt;CODE&gt;MM_HALT&lt;/CODE&gt;
&lt;DD&gt;
         This value is printed as &lt;CODE&gt;HALT&lt;/CODE&gt;.
         &lt;DT&gt;&lt;CODE&gt;MM_ERROR&lt;/CODE&gt;
&lt;DD&gt;
         This value is printed as &lt;CODE&gt;ERROR&lt;/CODE&gt;.
         &lt;DT&gt;&lt;CODE&gt;MM_WARNING&lt;/CODE&gt;
&lt;DD&gt;
         This value is printed as &lt;CODE&gt;WARNING&lt;/CODE&gt;.
         &lt;DT&gt;&lt;CODE&gt;MM_INFO&lt;/CODE&gt;
&lt;DD&gt;
         This value is printed as &lt;CODE&gt;INFO&lt;/CODE&gt;.
         &lt;/DL&gt;
         &lt;br&gt;&lt;br&gt; The numeric value of these five macros are between &lt;CODE&gt;0&lt;/CODE&gt; and
         &lt;CODE&gt;4&lt;/CODE&gt;.  Using the environment variable &lt;CODE&gt;SEV_LEVEL&lt;/CODE&gt; or using the
         &lt;CODE&gt;addseverity&lt;/CODE&gt; function one can add more severity levels with their
         corresponding string to print.  This is described below
         .
         &lt;br&gt;&lt;br&gt;
         If no parameter is ignored the output looks like this:
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         &lt;VAR&gt;label&lt;/VAR&gt;: &lt;VAR&gt;severity-string&lt;/VAR&gt;: &lt;VAR&gt;text&lt;/VAR&gt;&lt;br&gt;
         TO FIX: &lt;VAR&gt;action&lt;/VAR&gt; &lt;VAR&gt;tag&lt;/VAR&gt;&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; The colons, new line characters and the &lt;CODE&gt;TO FIX&lt;/CODE&gt; string are
         inserted if necessary, i.e., if the corresponding parameter is not
         ignored.
         &lt;br&gt;&lt;br&gt; This function is specified in the X/Open Portability Guide.  It is also
         available on all systems derived from System V.
         &lt;br&gt;&lt;br&gt; The function returns the value &lt;CODE&gt;MM_OK&lt;/CODE&gt; if no error occurred.  If
         only the printing to standard error failed, it returns &lt;CODE&gt;MM_NOMSG&lt;/CODE&gt;.
         If printing to the console fails, it returns &lt;CODE&gt;MM_NOCON&lt;/CODE&gt;.  If
         nothing is printed &lt;CODE&gt;MM_NOTOK&lt;/CODE&gt; is returned.  Among situations where
         all outputs fail this last value is also returned if a parameter value
         is incorrect.
        </synopsis>
    </function>
  </construct>
  <construct id="function-addseverity" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="int severity"/>
        <parameter content="const char *string"/>
      </prototype>
        <synopsis>
        This function allows the introduction of new severity classes which can be
         addressed by the &lt;VAR&gt;severity&lt;/VAR&gt; parameter of the &lt;CODE&gt;fmtmsg&lt;/CODE&gt; function.
         The &lt;VAR&gt;severity&lt;/VAR&gt; parameter of &lt;CODE&gt;addseverity&lt;/CODE&gt; must match the value
         for the parameter with the same name of &lt;CODE&gt;fmtmsg&lt;/CODE&gt;, and &lt;VAR&gt;string&lt;/VAR&gt;
         is the string printed in the actual messages instead of the numeric
         value.
         &lt;br&gt;&lt;br&gt; If &lt;VAR&gt;string&lt;/VAR&gt; is &lt;CODE&gt;NULL&lt;/CODE&gt; the severity class with the numeric value
         according to &lt;VAR&gt;severity&lt;/VAR&gt; is removed.
         &lt;br&gt;&lt;br&gt; It is not possible to overwrite or remove one of the default severity
         classes.  All calls to &lt;CODE&gt;addseverity&lt;/CODE&gt; with &lt;VAR&gt;severity&lt;/VAR&gt; set to one
         of the values for the default classes will fail.
         &lt;br&gt;&lt;br&gt; The return value is &lt;CODE&gt;MM_OK&lt;/CODE&gt; if the task was successfully performed.
         If the return value is &lt;CODE&gt;MM_NOTOK&lt;/CODE&gt; something went wrong.  This could
         mean that no more memory is available or a class is not available when
         it has to be removed.
         &lt;br&gt;&lt;br&gt; This function is not specified in the X/Open Portability Guide although
         the &lt;CODE&gt;fmtsmg&lt;/CODE&gt; function is.  It is available on System V systems.
        </synopsis>
    </function>
  </construct>
  <construct id="function-lfind" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="const void *key"/>
        <parameter content="void *base"/>
        <parameter content="size_t *nmemb"/>
        <parameter content="size_t size"/>
        <parameter content="comparison_fn_t compar"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
        <header filename = "search.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;lfind&lt;/CODE&gt; function searches in the array with &lt;CODE&gt;*&lt;VAR&gt;nmemb&lt;/VAR&gt;&lt;/CODE&gt;
         elements of &lt;VAR&gt;size&lt;/VAR&gt; bytes pointed to by &lt;VAR&gt;base&lt;/VAR&gt; for an element
         which matches the one pointed to by &lt;VAR&gt;key&lt;/VAR&gt;.  The function pointed to
         by &lt;VAR&gt;compar&lt;/VAR&gt; is used decide whether two elements match.
         &lt;br&gt;&lt;br&gt; The return value is a pointer to the matching element in the array
         starting at &lt;VAR&gt;base&lt;/VAR&gt; if it is found.  If no matching element is
         available &lt;CODE&gt;NULL&lt;/CODE&gt; is returned.
         &lt;br&gt;&lt;br&gt; The mean runtime of this function is &lt;CODE&gt;*&lt;VAR&gt;nmemb&lt;/VAR&gt;&lt;/CODE&gt;/2.  This
         function should only be used if elements often get added to or deleted from
         the array in which case it might not be useful to sort the array before
         searching.
        </synopsis>
    </function>
  </construct>
  <construct id="function-lsearch" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="const void *key"/>
        <parameter content="void *base"/>
        <parameter content="size_t *nmemb"/>
        <parameter content="size_t size"/>
        <parameter content="comparison_fn_t compar"/>
      </prototype>
      <headers>
        <header filename = "search.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;lsearch&lt;/CODE&gt; function is similar to the &lt;CODE&gt;lfind&lt;/CODE&gt; function.  It
         searches the given array for an element and returns it if found.  The
         difference is that if no matching element is found the &lt;CODE&gt;lsearch&lt;/CODE&gt;
         function adds the object pointed to by &lt;VAR&gt;key&lt;/VAR&gt; (with a size of
         &lt;VAR&gt;size&lt;/VAR&gt; bytes) at the end of the array and it increments the value of
         &lt;CODE&gt;*&lt;VAR&gt;nmemb&lt;/VAR&gt;&lt;/CODE&gt; to reflect this addition.
         &lt;br&gt;&lt;br&gt; This means for the caller that if it is not sure that the array contains
         the element one is searching for the memory allocated for the array
         starting at &lt;VAR&gt;base&lt;/VAR&gt; must have room for at least &lt;VAR&gt;size&lt;/VAR&gt; more
         bytes.  If one is sure the element is in the array it is better to use
         &lt;CODE&gt;lfind&lt;/CODE&gt; so having more room in the array is always necessary when
         calling &lt;CODE&gt;lsearch&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-bsearch" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="const void *key"/>
        <parameter content="const void *array"/>
        <parameter content="size_t count"/>
        <parameter content="size_t size"/>
        <parameter content="comparison_fn_t compare"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;bsearch&lt;/CODE&gt; function searches the sorted array &lt;VAR&gt;array&lt;/VAR&gt; for an object
         that is equivalent to &lt;VAR&gt;key&lt;/VAR&gt;.  The array contains &lt;VAR&gt;count&lt;/VAR&gt; elements,
         each of which is of size &lt;VAR&gt;size&lt;/VAR&gt; bytes.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;compare&lt;/VAR&gt; function is used to perform the comparison.  This
         function is called with two pointer arguments and should return an
         integer less than, equal to, or greater than zero corresponding to
         whether its first argument is considered less than, equal to, or greater
         than its second argument.  The elements of the &lt;VAR&gt;array&lt;/VAR&gt; must already
         be sorted in ascending order according to this comparison function.
         &lt;br&gt;&lt;br&gt; The return value is a pointer to the matching array element, or a null
         pointer if no match is found.  If the array contains more than one element
         that matches, the one that is returned is unspecified.
         &lt;br&gt;&lt;br&gt; This function derives its name from the fact that it is implemented
         using the binary search algorithm.
        </synopsis>
    </function>
  </construct>
  <construct id="function-qsort" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="void *array"/>
        <parameter content="size_t count"/>
        <parameter content="size_t size"/>
        <parameter content="comparison_fn_t compare"/>
      </prototype>
      <headers>
        <header filename = "stdlib.h"/>
      </headers>
        <synopsis>
        The &lt;VAR&gt;qsort&lt;/VAR&gt; function sorts the array &lt;VAR&gt;array&lt;/VAR&gt;.  The array contains
         &lt;VAR&gt;count&lt;/VAR&gt; elements, each of which is of size &lt;VAR&gt;size&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; The &lt;VAR&gt;compare&lt;/VAR&gt; function is used to perform the comparison on the
         array elements.  This function is called with two pointer arguments and
         should return an integer less than, equal to, or greater than zero
         corresponding to whether its first argument is considered less than,
         equal to, or greater than its second argument.
         &lt;br&gt;&lt;br&gt;  sorting
         Warning: If two objects compare as equal, their order after
         sorting is unpredictable.  That is to say, the sorting is not stable.
         This can make a difference when the comparison considers only part of
         the elements.  Two elements with the same sort key may differ in other
         respects.
         &lt;br&gt;&lt;br&gt; If you want the effect of a stable sort, you can get this result by
         writing the comparison function so that, lacking other reason
         distinguish between two elements, it compares them by their addresses.
         Note that doing this may make the sorting algorithm less efficient, so
         do it only if necessary.
         &lt;br&gt;&lt;br&gt; Here is a simple example of sorting an array of doubles in numerical
         order, using the comparison function defined above :
         &lt;br&gt;&lt;br&gt; &lt;pre&gt;&lt;br&gt;
         {&lt;br&gt;
           double *array;&lt;br&gt;
           int size;&lt;br&gt;
           &lt;small&gt;...&lt;/small&gt;&lt;br&gt;
           qsort (array, size, sizeof (double), compare_doubles);&lt;br&gt;
         }&lt;br&gt;
         &lt;/pre&gt;
         &lt;br&gt;&lt;br&gt; The &lt;CODE&gt;qsort&lt;/CODE&gt; function derives its name from the fact that it was
         originally implemented using the ``quick sort'' algorithm.
         &lt;br&gt;&lt;br&gt; The implementation of &lt;CODE&gt;qsort&lt;/CODE&gt; in this library might not be an
         in-place sort and might thereby use an extra amount of memory to store
         the array.
        </synopsis>
    </function>
  </construct>
  <construct id="function-hcreate" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="size_t nel"/>
      </prototype>
      <headers>
        <header filename = "search.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;hcreate&lt;/CODE&gt; function creates a hashing table which can contain at
         least &lt;VAR&gt;nel&lt;/VAR&gt; elements.  There is no possibility to grow this table so
         it is necessary to choose the value for &lt;VAR&gt;nel&lt;/VAR&gt; wisely.  The method
         used to implement this function might make it necessary to make the
         number of elements in the hashing table larger than the expected maximal
         number of elements.  Hashing tables usually work inefficiently if they are
         filled 80% or more.  The constant access time guaranteed by hashing can
         only be achieved if few collisions exist.  See Knuth's ``The Art of
         Computer Programming, Part 3: Searching and Sorting'' for more
         information.
         &lt;br&gt;&lt;br&gt; The weakest aspect of this function is that there can be at most one
         hashing table used through the whole program.  The table is allocated
         in local memory out of control of the programmer.  As an extension the
         GNU C library provides an additional set of functions with an reentrant
         interface which provide a similar interface but which allow to keep
         arbitrarily many hashing tables.
         &lt;br&gt;&lt;br&gt; It is possible to use more than one hashing table in the program run if
         the former table is first destroyed by a call to &lt;CODE&gt;hdestroy&lt;/CODE&gt;.
         &lt;br&gt;&lt;br&gt; The function returns a non-zero value if successful.  If it return zero
         something went wrong.  This could either mean there is already a hashing
         table in use or the program runs out of memory.
        </synopsis>
    </function>
  </construct>
  <construct id="function-hdestroy" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="void"/>
      </prototype>
      <headers>
        <header filename = "search.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;hdestroy&lt;/CODE&gt; function can be used to free all the resources
         allocated in a previous call of &lt;CODE&gt;hcreate&lt;/CODE&gt;.  After a call to this
         function it is again possible to call &lt;CODE&gt;hcreate&lt;/CODE&gt; and allocate a new
         table with possibly different size.
         &lt;br&gt;&lt;br&gt; It is important to remember that the elements contained in the hashing
         table at the time &lt;CODE&gt;hdestroy&lt;/CODE&gt; is called are &lt;EM&gt;not&lt;/EM&gt; freed by this
         function.  It is the responsibility of the program code to free those
         strings (if necessary at all).  Freeing all the element memory is not
         possible without extra, separately kept information since there is no
         function to iterate through all available elements in the hashing table.
         If it is really necessary to free a table and all elements the
         programmer has to keep a list of all table elements and before calling
         &lt;CODE&gt;hdestroy&lt;/CODE&gt; s/he has to free all element's data using this list.
         This is a very unpleasant mechanism and it also shows that this kind of
         hashing tables is mainly meant for tables which are created once and
         used until the end of the program run.
        </synopsis>
    </function>
  </construct>
  <construct id="struct-ENTRY" type="struct">
    <structure>
        <synopsis>
        Both elements of this structure are pointers to zero-terminated strings.
         This is a limiting restriction of the functionality of the
         &lt;CODE&gt;hsearch&lt;/CODE&gt; functions.  They can only be used for data sets which use
         the NUL character always and solely to terminate the records.  It is not
         possible to handle general binary data.
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="char *key">
            <synopsis>
            Pointer to a zero-terminated string of characters describing the key for
             the search or the element in the hashing table.
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-hsearch" type="function">
    <function returntype="ENTRY *">
      <prototype>
        <parameter content="ENTRY item"/>
        <parameter content="ACTION action"/>
      </prototype>
      <headers>
        <header filename = "search.h"/>
      </headers>
        <synopsis>
        To search in a hashing table created using &lt;CODE&gt;hcreate&lt;/CODE&gt; the
         &lt;CODE&gt;hsearch&lt;/CODE&gt; function must be used.  This function can perform simple
         search for an element (if &lt;VAR&gt;action&lt;/VAR&gt; has the &lt;CODE&gt;FIND&lt;/CODE&gt;) or it can
         alternatively insert the key element into the hashing table.  Entries
         are never replaced.
         &lt;br&gt;&lt;br&gt; The key is denoted by a pointer to an object of type &lt;CODE&gt;ENTRY&lt;/CODE&gt;.  For
         locating the corresponding position in the hashing table only the
         &lt;CODE&gt;key&lt;/CODE&gt; element of the structure is used.
         &lt;br&gt;&lt;br&gt; If an entry with matching key is found the &lt;VAR&gt;action&lt;/VAR&gt; parameter is
         irrelevant.  The found entry is returned.  If no matching entry is found
         and the &lt;VAR&gt;action&lt;/VAR&gt; parameter has the value &lt;CODE&gt;FIND&lt;/CODE&gt; the function
         returns a &lt;CODE&gt;NULL&lt;/CODE&gt; pointer.  If no entry is found and the
         &lt;VAR&gt;action&lt;/VAR&gt; parameter has the value &lt;CODE&gt;ENTER&lt;/CODE&gt; a new entry is added
         to the hashing table which is initialized with the parameter &lt;VAR&gt;item&lt;/VAR&gt;.
         A pointer to the newly added entry is returned.
        </synopsis>
    </function>
  </construct>
  <construct id="function-hcreate_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="size_t nel"/>
        <parameter content="struct hsearch_data *htab"/>
      </prototype>
      <headers>
        <header filename = "search.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;hcreate_r&lt;/CODE&gt; function initializes the object pointed to by
         &lt;VAR&gt;htab&lt;/VAR&gt; to contain a hashing table with at least &lt;VAR&gt;nel&lt;/VAR&gt; elements.
         So this function is equivalent to the &lt;CODE&gt;hcreate&lt;/CODE&gt; function except
         that the initialized data structure is controlled by the user.
         &lt;br&gt;&lt;br&gt; This allows having more than one hashing table at one time.  The memory
         necessary for the &lt;CODE&gt;struct hsearch_data&lt;/CODE&gt; object can be allocated
         dynamically.  It must be initialized with zero before calling this
         function.
         &lt;br&gt;&lt;br&gt; The return value is non-zero if the operation was successful.  If the
         return value is zero, something went wrong, which probably means the
         programs ran out of memory.
        </synopsis>
    </function>
  </construct>
  <construct id="function-hdestroy_r" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="struct hsearch_data *htab"/>
      </prototype>
      <headers>
        <header filename = "search.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;hdestroy_r&lt;/CODE&gt; function frees all resources allocated by the
         &lt;CODE&gt;hcreate_r&lt;/CODE&gt; function for this very same object &lt;VAR&gt;htab&lt;/VAR&gt;.  As for
         &lt;CODE&gt;hdestroy&lt;/CODE&gt; it is the programs responsibility to free the strings
         for the elements of the table.
        </synopsis>
    </function>
  </construct>
  <construct id="function-hsearch_r" type="function">
    <function returntype="int">
      <prototype>
        <parameter content="ENTRY item"/>
        <parameter content="ACTION action"/>
        <parameter content="ENTRY **retval"/>
        <parameter content="struct hsearch_data *htab"/>
      </prototype>
      <headers>
        <header filename = "search.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;hsearch_r&lt;/CODE&gt; function is equivalent to &lt;CODE&gt;hsearch&lt;/CODE&gt;.  The
         meaning of the first two arguments is identical.  But instead of
         operating on a single global hashing table the function works on the
         table described by the object pointed to by &lt;VAR&gt;htab&lt;/VAR&gt; (which is
         initialized by a call to &lt;CODE&gt;hcreate_r&lt;/CODE&gt;).
         &lt;br&gt;&lt;br&gt; Another difference to &lt;CODE&gt;hcreate&lt;/CODE&gt; is that the pointer to the found
         entry in the table is not the return value of the functions.  It is
         returned by storing it in a pointer variables pointed to by the
         &lt;VAR&gt;retval&lt;/VAR&gt; parameter.  The return value of the function is an integer
         value indicating success if it is non-zero and failure if it is zero.
         In the latter case the global variable &lt;VAR&gt;errno&lt;/VAR&gt; signals the reason for
         the failure.
         &lt;br&gt;&lt;br&gt; &lt;DL&gt;

         &lt;DT&gt;&lt;CODE&gt;ENOMEM&lt;/CODE&gt;
&lt;DD&gt;
         The table is filled and &lt;CODE&gt;hsearch_r&lt;/CODE&gt; was called with an so far
         unknown key and &lt;VAR&gt;action&lt;/VAR&gt; set to &lt;CODE&gt;ENTER&lt;/CODE&gt;.
         &lt;LI&gt; ESRCH
         The &lt;VAR&gt;action&lt;/VAR&gt; parameter is &lt;CODE&gt;FIND&lt;/CODE&gt; and no corresponding element
         is found in the table.

        </synopsis>
    </function>
  </construct>
  <construct id="function-tsearch" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="const void *key"/>
        <parameter content="void **rootp"/>
        <parameter content="comparison_fn_t compar"/>
      </prototype>
      <headers>
        <header filename = "search.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;tsearch&lt;/CODE&gt; function searches in the tree pointed to by
         &lt;CODE&gt;*&lt;VAR&gt;rootp&lt;/VAR&gt;&lt;/CODE&gt; for an element matching &lt;VAR&gt;key&lt;/VAR&gt;.  The function
         pointed to by &lt;VAR&gt;compar&lt;/VAR&gt; is used to determine whether two elements
         match.  , for a specification of the functions
         which can be used for the &lt;VAR&gt;compar&lt;/VAR&gt; parameter.
         &lt;br&gt;&lt;br&gt; If the tree does not contain a matching entry the &lt;VAR&gt;key&lt;/VAR&gt; value will
         be added to the tree.  &lt;CODE&gt;tsearch&lt;/CODE&gt; does not make a copy of the object
         pointed to by &lt;VAR&gt;key&lt;/VAR&gt; (how could it since the size is unknown).
         Instead it adds a reference to this object which means the object must
         be available as long as the tree data structure is used.
         &lt;br&gt;&lt;br&gt; The tree is represented by a pointer to a pointer since it is sometimes
         necessary to change the root node of the tree.  So it must not be
         assumed that the variable pointed to by &lt;VAR&gt;rootp&lt;/VAR&gt; has the same value
         after the call.  This also shows that it is not safe to call the
         &lt;CODE&gt;tsearch&lt;/CODE&gt; function more than once at the same time using the same
         tree.  It is no problem to run it more than once at a time on different
         trees.
         &lt;br&gt;&lt;br&gt; The return value is a pointer to the matching element in the tree.  If a
         new element was created the pointer points to the new data (which is in
         fact &lt;VAR&gt;key&lt;/VAR&gt;).  If an entry had to be created and the program ran out
         of space &lt;CODE&gt;NULL&lt;/CODE&gt; is returned.
        </synopsis>
    </function>
  </construct>
  <construct id="function-tfind" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="const void *key"/>
        <parameter content="void *const *rootp"/>
        <parameter content="comparison_fn_t compar"/>
      </prototype>
      <headers>
        <header filename = "search.h"/>
      </headers>
        <synopsis>
        The &lt;CODE&gt;tfind&lt;/CODE&gt; function is similar to the &lt;CODE&gt;tsearch&lt;/CODE&gt; function.  It
         locates an element matching the one pointed to by &lt;VAR&gt;key&lt;/VAR&gt; and returns
         a pointer to this element.  But if no matching element is available no
         new element is entered (note that the &lt;VAR&gt;rootp&lt;/VAR&gt; parameter points to a
         constant pointer).  Instead the function returns &lt;CODE&gt;NULL&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-tdelete" type="function">
    <function returntype="void *">
      <prototype>
        <parameter content="const void *key"/>
        <parameter content="void **rootp"/>
        <parameter content="comparison_fn_t compar"/>
      </prototype>
      <headers>
        <header filename = "search.h"/>
      </headers>
        <synopsis>
        To remove a specific element matching &lt;VAR&gt;key&lt;/VAR&gt; from the tree
         &lt;CODE&gt;tdelete&lt;/CODE&gt; can be used.  It locates the matching element using the
         same method as &lt;CODE&gt;tfind&lt;/CODE&gt;.  The corresponding element is then removed
         and a pointer to the parent of the deleted node is returned by the
         function.  If there is no matching entry in the tree nothing can be
         deleted and the function returns &lt;CODE&gt;NULL&lt;/CODE&gt;.  If the root of the tree
         is deleted &lt;CODE&gt;tdelete&lt;/CODE&gt; returns some unspecified value not equal to
         &lt;CODE&gt;NULL&lt;/CODE&gt;.
        </synopsis>
    </function>
  </construct>
  <construct id="function-tdestroy" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="void *vroot"/>
        <parameter content="__free_fn_t freefct"/>
      </prototype>
      <headers>
        <header filename = "search.h"/>
      </headers>
        <synopsis>
        If the complete search tree has to be removed one can use
         &lt;CODE&gt;tdestroy&lt;/CODE&gt;.  It frees all resources allocated by the &lt;CODE&gt;tsearch&lt;/CODE&gt;
         function to generate the tree pointed to by &lt;VAR&gt;vroot&lt;/VAR&gt;.
         &lt;br&gt;&lt;br&gt; For the data in each tree node the function &lt;VAR&gt;freefct&lt;/VAR&gt; is called.
         The pointer to the data is passed as the argument to the function.  If
         no such work is necessary &lt;VAR&gt;freefct&lt;/VAR&gt; must point to a function doing
         nothing.  It is called in any case.
         &lt;br&gt;&lt;br&gt; This function is a GNU extension and not covered by the System V or
         X/Open specifications.
        </synopsis>
    </function>
  </construct>
  <construct id="dtype-VISIT" type="dtype">
    <structure>
        <synopsis>
        The &lt;CODE&gt;VISIT&lt;/CODE&gt; value indicates the status of the current node in the
         tree and how the function is called.  The status of a node is either
         `leaf' or `internal node'.  For each leaf node the function is called
         exactly once, for each internal node it is called three times: before
         the first child is processed, after the first child is processed and
         after both children are processed.  This makes it possible to handle all
         three methods of tree traversal (or even a combination of them).
         &lt;br&gt;&lt;br&gt;
        </synopsis>
      <elements>
        <element content="preorder">
            <synopsis>
            The current node is an internal node and the function is called before
             the first child was processed.
            </synopsis>
        </element>
        <element content="postorder">
            <synopsis>
            The current node is an internal node and the function is called after
             the first child was processed.
            </synopsis>
        </element>
        <element content="endorder">
            <synopsis>
            The current node is an internal node and the function is called after
             the second child was processed.
            </synopsis>
        </element>
      </elements>
    </structure>
  </construct>
  <construct id="function-twalk" type="function">
    <function returntype="void">
      <prototype>
        <parameter content="const void *root"/>
        <parameter content="__action_fn_t action"/>
      </prototype>
      <headers>
        <header filename = "search.h"/>
      </headers>
        <synopsis>
        For each node in the tree with a node pointed to by &lt;VAR&gt;root&lt;/VAR&gt;, the
         &lt;CODE&gt;twalk&lt;/CODE&gt; function calls the function provided by the parameter
         &lt;VAR&gt;action&lt;/VAR&gt;.  For leaf nodes the function is called exactly once with
         &lt;VAR&gt;value&lt;/VAR&gt; set to &lt;CODE&gt;leaf&lt;/CODE&gt;.  For internal nodes the function is
         called three times, setting the &lt;VAR&gt;value&lt;/VAR&gt; parameter or &lt;VAR&gt;action&lt;/VAR&gt; to
         the appropriate value.  The &lt;VAR&gt;level&lt;/VAR&gt; argument for the &lt;VAR&gt;action&lt;/VAR&gt;
         function is computed while descending the tree with increasing the value
         by one for the descend to a child, starting with the value 0 for
         the root node.
         &lt;br&gt;&lt;br&gt; Since the functions used for the &lt;VAR&gt;action&lt;/VAR&gt; parameter to &lt;CODE&gt;twalk&lt;/CODE&gt;
         must not modify the tree data, it is safe to run &lt;CODE&gt;twalk&lt;/CODE&gt; in more
         than one thread at the same time, working on the same tree.  It is also
         safe to call &lt;CODE&gt;tfind&lt;/CODE&gt; in parallel.  Functions which modify the tree
         must not be used, otherwise the behavior is undefined.
        </synopsis>
    </function>
  </construct>
</descriptions>
